//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// File: DDRTCM.cpp
//
// Code generated for Simulink model 'DDRTCM'.
//
// Model version                  : 3.3
// Simulink Coder version         : 9.8 (R2022b) 13-May-2022
// C/C++ source code generated on : Fri Dec  9 14:23:41 2022
//
// Target selection: ert.tlc
// Embedded hardware selection: Intel->x86-64 (Linux 64)
// Code generation objectives: Unspecified
// Validation result: Not run
//
#include "DDRTCM.h"
#include "DDRTCM_types.h"
#include "rtwtypes.h"
#include <cstring>
#include <cmath>
#include <emmintrin.h>
#include "rt_defines.h"
#include "DDRTCM_private.h"

extern "C"
{

#include "rt_nonfinite.h"

}

// Named constants for Chart: '<S130>/choose correction mode'
const uint8_T DDRTCM_IN_DGPS{ 1U };

const uint8_T DDRTCM_IN_DGPS_Galileo{ 1U };

const uint8_T DDRTCM_IN_DGPS_only{ 2U };

const uint8_T DDRTCM_IN_Dualfrequency{ 2U };

const uint8_T DDRTCM_IN_GPS_Klobuchar_Galileo{ 3U };

const uint8_T DDRTCM_IN_NO_ACTIVE_CHILD{ 0U };

const uint8_T DDRTCM_IN_Waiting_for_more_sat{ 3U };

const uint8_T DDRTCM_IN_waiting_for_RTCM{ 4U };

const uint8_T DD_IN_GPS_Dualfrequency_Galileo{ 1U };

const uint8_T DD_IN_Waiting_for_more_dual_sat{ 2U };

void DDRTCM::DDRTCM_binary_expand_op(real_T in1[3], const real_T in2_data[],
  const int32_T in2_size[2], int32_T in3, const real_T in4[3],
  B_ConvertGNSSMeasuremendVaria_T *localB)
{
  localB->stride_0_1 = (in2_size[1] != 1);
  in1[0] = in2_data[in3] - in4[0];
  in1[1] = in2_data[in2_size[0] * localB->stride_0_1 + in3] - in4[1];
  in1[2] = in2_data[(localB->stride_0_1 << 1) * in2_size[0] + in3] - in4[2];
}

real_T DDRTCM::DDRTCM_rt_atan2d_snf(real_T u0, real_T u1,
  B_ConvertGNSSMeasuremendVaria_T *localB)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = (rtNaN);
  } else if (std::isinf(u0) && std::isinf(u1)) {
    if (u0 > 0.0) {
      localB->i1 = 1;
    } else {
      localB->i1 = -1;
    }

    if (u1 > 0.0) {
      localB->i2 = 1;
    } else {
      localB->i2 = -1;
    }

    y = std::atan2(static_cast<real_T>(localB->i1), static_cast<real_T>
                   (localB->i2));
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = std::atan2(u0, u1);
  }

  return y;
}

// Function for MATLAB Function: '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles'
void DDRTCM::calculate_Satellite_Elevation_A(const real_T user_Position_llh[3],
  const real_T satellite_Position_ecef_data[], const int32_T
  satellite_Position_ecef_size[2], real_T elevation_Angle_data[], int32_T
  *elevation_Angle_size, real_T azimuth_Angle_data[], int32_T
  *azimuth_Angle_size, B_ConvertGNSSMeasuremendVaria_T *localB)
{
  *elevation_Angle_size = satellite_Position_ecef_size[0];
  localB->loop_ub_f = satellite_Position_ecef_size[0];
  if (localB->loop_ub_f - 1 >= 0) {
    std::memset(&elevation_Angle_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub_f) * sizeof(real_T));
  }

  *azimuth_Angle_size = satellite_Position_ecef_size[0];
  localB->loop_ub_f = satellite_Position_ecef_size[0];
  if (localB->loop_ub_f - 1 >= 0) {
    std::memset(&azimuth_Angle_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub_f) * sizeof(real_T));
  }

  localB->scale = std::cos(user_Position_llh[0]);
  localB->N = 6.3995936257584924E+6 / std::sqrt(localB->scale * localB->scale *
    0.0067394967422761756 + 1.0);
  localB->t = std::cos(user_Position_llh[1]);
  localB->user_Position_ecef[0] = (localB->N + user_Position_llh[2]) *
    localB->scale * localB->t;
  localB->u_unit_c = std::sin(user_Position_llh[1]);
  localB->user_Position_ecef[1] = (localB->N + user_Position_llh[2]) * std::cos
    (user_Position_llh[0]) * localB->u_unit_c;
  localB->d = std::sin(user_Position_llh[0]);
  localB->user_Position_ecef[2] = (0.99330562000985889 * localB->N +
    user_Position_llh[2]) * localB->d;
  localB->e_unit_tmp[0] = -localB->u_unit_c;
  localB->e_unit_tmp[1] = localB->t;
  localB->e_unit_tmp[2] = 0.0;
  localB->e_unit_tmp[3] = -localB->d * localB->t;
  localB->e_unit_tmp[4] = -std::sin(user_Position_llh[0]) * localB->u_unit_c;
  localB->e_unit_tmp[5] = localB->scale;
  localB->e_unit_tmp[6] = localB->scale * localB->t;
  localB->e_unit_tmp[7] = localB->scale * localB->u_unit_c;
  localB->e_unit_tmp[8] = localB->d;
  for (localB->i_c = 0; localB->i_c <= 0; localB->i_c += 2) {
    __m128d tmp;
    __m128d tmp_0;
    __m128d tmp_1;
    __m128d tmp_2;
    __m128d tmp_3;
    __m128d tmp_4;
    __m128d tmp_5;
    tmp = _mm_loadu_pd(&localB->e_unit_tmp[localB->i_c]);
    tmp_2 = _mm_set1_pd(0.0);
    tmp_3 = _mm_mul_pd(tmp, tmp_2);
    tmp_0 = _mm_loadu_pd(&localB->e_unit_tmp[localB->i_c + 3]);
    tmp_4 = _mm_mul_pd(tmp_0, tmp_2);
    tmp_1 = _mm_loadu_pd(&localB->e_unit_tmp[localB->i_c + 6]);
    tmp_5 = _mm_mul_pd(tmp_1, tmp_2);
    _mm_storeu_pd(&localB->e_unit[localB->i_c], _mm_add_pd(tmp_5, _mm_add_pd
      (tmp_4, _mm_add_pd(tmp_2, tmp))));
    tmp = _mm_add_pd(tmp_3, tmp_2);
    _mm_storeu_pd(&localB->n_unit[localB->i_c], _mm_add_pd(tmp_5, _mm_add_pd(tmp,
      tmp_0)));
    _mm_storeu_pd(&localB->u_unit[localB->i_c], _mm_add_pd(_mm_add_pd(tmp_4, tmp),
      tmp_1));
  }

  for (localB->i_c = 2; localB->i_c < 3; localB->i_c++) {
    localB->scale = localB->e_unit_tmp[localB->i_c];
    localB->N = localB->scale;
    localB->u_unit_c = localB->scale * 0.0;
    localB->scale = localB->e_unit_tmp[localB->i_c + 3];
    localB->N += localB->scale * 0.0;
    localB->t = localB->u_unit_c + localB->scale;
    localB->u_unit_c += localB->scale * 0.0;
    localB->scale = localB->e_unit_tmp[localB->i_c + 6];
    localB->e_unit[localB->i_c] = localB->scale * 0.0 + localB->N;
    localB->n_unit[localB->i_c] = localB->scale * 0.0 + localB->t;
    localB->u_unit[localB->i_c] = localB->u_unit_c + localB->scale;
  }

  localB->loop_ub_f = satellite_Position_ecef_size[0];
  for (localB->i_p = 0; localB->i_p < localB->loop_ub_f; localB->i_p++) {
    if (satellite_Position_ecef_size[1] == 3) {
      for (localB->i_c = 0; localB->i_c < 3; localB->i_c++) {
        localB->line_of_sight[localB->i_c] =
          satellite_Position_ecef_data[satellite_Position_ecef_size[0] *
          localB->i_c + localB->i_p] - localB->user_Position_ecef[localB->i_c];
      }
    } else {
      DDRTCM_binary_expand_op(localB->line_of_sight,
        satellite_Position_ecef_data, satellite_Position_ecef_size, localB->i_p,
        localB->user_Position_ecef, localB);
    }

    localB->scale = 3.3121686421112381E-170;
    localB->N = std::abs(localB->line_of_sight[0]);
    if (localB->N > 3.3121686421112381E-170) {
      localB->u_unit_c = 1.0;
      localB->scale = localB->N;
    } else {
      localB->t = localB->N / 3.3121686421112381E-170;
      localB->u_unit_c = localB->t * localB->t;
    }

    localB->N = std::abs(localB->line_of_sight[1]);
    if (localB->N > localB->scale) {
      localB->t = localB->scale / localB->N;
      localB->u_unit_c = localB->u_unit_c * localB->t * localB->t + 1.0;
      localB->scale = localB->N;
    } else {
      localB->t = localB->N / localB->scale;
      localB->u_unit_c += localB->t * localB->t;
    }

    localB->N = std::abs(localB->line_of_sight[2]);
    if (localB->N > localB->scale) {
      localB->t = localB->scale / localB->N;
      localB->u_unit_c = localB->u_unit_c * localB->t * localB->t + 1.0;
      localB->scale = localB->N;
    } else {
      localB->t = localB->N / localB->scale;
      localB->u_unit_c += localB->t * localB->t;
    }

    localB->u_unit_c = localB->scale * std::sqrt(localB->u_unit_c);
    localB->line_of_sight[0] /= localB->u_unit_c;
    localB->line_of_sight[1] /= localB->u_unit_c;
    localB->line_of_sight[2] /= localB->u_unit_c;
    elevation_Angle_data[localB->i_p] = std::asin((localB->line_of_sight[0] *
      localB->u_unit[0] + localB->line_of_sight[1] * localB->u_unit[1]) +
      localB->line_of_sight[2] * localB->u_unit[2]);
    azimuth_Angle_data[localB->i_p] = DDRTCM_rt_atan2d_snf
      ((localB->line_of_sight[0] * localB->e_unit[0] + localB->line_of_sight[1] *
        localB->e_unit[1]) + localB->line_of_sight[2] * localB->e_unit[2],
       (localB->line_of_sight[0] * localB->n_unit[0] + localB->line_of_sight[1] *
        localB->n_unit[1]) + localB->line_of_sight[2] * localB->n_unit[2],
       localB);
  }
}

//
// Output and update for atomic system:
//    '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles'
//    '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles1'
//    '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles2'
//    '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles'
//    '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles1'
//    '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles2'
//
void DDRTCM::ConvertGNSSMeasuremendVariableT(const GNSS_Measurement
  *rtu_GNSSMeasurementVariable, const GNSS_Measurement_size
  *rtu_GNSSMeasurementVariab_DIMS1, const real_T rtu_user_pos_llh[3],
  GNSSMeasurementFixed *rty_GNSSMeasurementFixed, real_T
  *rty_sizeOfMesasurements, B_ConvertGNSSMeasuremendVaria_T *localB)
{
  std::memset(&rty_GNSSMeasurementFixed->satellite_position[0], 0, 120U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->satellite_velocity[0], 0, 120U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->PRN[0], 0, 40U * sizeof(uint16_T));
  std::memset(&rty_GNSSMeasurementFixed->pseudorange[0], 0, 40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->pseudorange_raw[0], 0, 40U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->pseudorange_satclk_corrected[0], 0, 40U
              * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->deltarange[0], 0, 40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->deltarange_raw[0], 0, 40U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->deltarange_satclk_corrected[0], 0, 40U *
              sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->variance_pseudorange[0], 0, 40U *
              sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->variance_pseudorange_measured[0], 0,
              40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->variance_deltarange[0], 0, 40U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->carrierphase[0], 0, 40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->carrierphase_raw[0], 0, 40U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->carrierphase_satclk_corrected[0], 0,
              40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->variance_carrierphase_measured[0], 0,
              40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->locktime[0], 0, 40U * sizeof(real32_T));
  std::memset(&rty_GNSSMeasurementFixed->CN0[0], 0, 40U * sizeof(real_T));
  std::memset(&rty_GNSSMeasurementFixed->elevation_angle[0], 0, 40U * sizeof
              (real_T));
  std::memset(&rty_GNSSMeasurementFixed->azimuth_angle[0], 0, 40U * sizeof
              (real_T));
  rty_GNSSMeasurementFixed->time_receive =
    rtu_GNSSMeasurementVariable->time_receive;
  localB->rtu_GNSSMeasurementVariab_DIMS1 =
    rtu_GNSSMeasurementVariab_DIMS1->satellite_position[0];
  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  localB->loop_ub_c = rtu_GNSSMeasurementVariab_DIMS1->satellite_position[1];
  for (localB->i = 0; localB->i < localB->loop_ub_c; localB->i++) {
    for (localB->nb = 0; localB->nb <= localB->loop_ub; localB->nb++) {
      rty_GNSSMeasurementFixed->satellite_position[localB->nb + 40 * localB->i] =
        rtu_GNSSMeasurementVariable->satellite_position
        [localB->rtu_GNSSMeasurementVariab_DIMS1 * localB->i + localB->nb];
    }
  }

  localB->rtu_GNSSMeasurementVariab_DIMS1 =
    rtu_GNSSMeasurementVariab_DIMS1->satellite_velocity[0];
  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  localB->loop_ub_c = rtu_GNSSMeasurementVariab_DIMS1->satellite_velocity[1];
  for (localB->i = 0; localB->i < localB->loop_ub_c; localB->i++) {
    for (localB->nb = 0; localB->nb <= localB->loop_ub; localB->nb++) {
      rty_GNSSMeasurementFixed->satellite_velocity[localB->nb + 40 * localB->i] =
        rtu_GNSSMeasurementVariable->satellite_velocity
        [localB->rtu_GNSSMeasurementVariab_DIMS1 * localB->i + localB->nb];
    }
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->PRN[0],
                &rtu_GNSSMeasurementVariable->PRN[0], static_cast<uint32_T>
                (localB->loop_ub + 1) * sizeof(uint16_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->CN0[0],
                &rtu_GNSSMeasurementVariable->CN0[0], static_cast<uint32_T>
                (localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->locktime[0],
                &rtu_GNSSMeasurementVariable->locktime[0], static_cast<uint32_T>
                (localB->loop_ub + 1) * sizeof(real32_T));
  }

  rty_GNSSMeasurementFixed->base_position[0] =
    rtu_GNSSMeasurementVariable->base_position[0];
  rty_GNSSMeasurementFixed->base_position[1] =
    rtu_GNSSMeasurementVariable->base_position[1];
  rty_GNSSMeasurementFixed->base_position[2] =
    rtu_GNSSMeasurementVariable->base_position[2];
  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->pseudorange[0],
                &rtu_GNSSMeasurementVariable->pseudorange[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->pseudorange_raw[0],
                &rtu_GNSSMeasurementVariable->pseudorange_raw[0], static_cast<
                uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->pseudorange_satclk_corrected[0],
                &rtu_GNSSMeasurementVariable->pseudorange_satclk_corrected[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->deltarange[0],
                &rtu_GNSSMeasurementVariable->deltarange[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->deltarange_raw[0],
                &rtu_GNSSMeasurementVariable->deltarange_raw[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->deltarange_satclk_corrected[0],
                &rtu_GNSSMeasurementVariable->deltarange_satclk_corrected[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->carrierphase[0],
                &rtu_GNSSMeasurementVariable->carrierphase[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->carrierphase_raw[0],
                &rtu_GNSSMeasurementVariable->carrierphase_raw[0], static_cast<
                uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->carrierphase_satclk_corrected[0],
                &rtu_GNSSMeasurementVariable->carrierphase_satclk_corrected[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->variance_pseudorange[0],
                &rtu_GNSSMeasurementVariable->variance_pseudorange[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->variance_deltarange[0],
                &rtu_GNSSMeasurementVariable->variance_deltarange[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->variance_pseudorange_measured[0],
                &rtu_GNSSMeasurementVariable->variance_pseudorange_measured[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  if (localB->loop_ub >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->variance_carrierphase_measured[0],
                &rtu_GNSSMeasurementVariable->variance_carrierphase_measured[0],
                static_cast<uint32_T>(localB->loop_ub + 1) * sizeof(real_T));
  }

  localB->rtu_GNSSMeasurementVariab_DIMS1 =
    rtu_GNSSMeasurementVariab_DIMS1->satellite_position[0];
  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = rtu_GNSSMeasurementVariab_DIMS1->PRN - 1;
  }

  localB->loop_ub_c = rtu_GNSSMeasurementVariab_DIMS1->satellite_position[1];
  localB->rtu_GNSSMeasurementVariable_siz[0] = localB->loop_ub + 1;
  localB->rtu_GNSSMeasurementVariable_siz[1] =
    rtu_GNSSMeasurementVariab_DIMS1->satellite_position[1];
  for (localB->i = 0; localB->i < localB->loop_ub_c; localB->i++) {
    for (localB->nb = 0; localB->nb <= localB->loop_ub; localB->nb++) {
      localB->rtu_GNSSMeasurementVariable_dat[localB->nb + (localB->loop_ub + 1)
        * localB->i] = rtu_GNSSMeasurementVariable->satellite_position
        [localB->rtu_GNSSMeasurementVariab_DIMS1 * localB->i + localB->nb];
    }
  }

  calculate_Satellite_Elevation_A(rtu_user_pos_llh,
    localB->rtu_GNSSMeasurementVariable_dat,
    localB->rtu_GNSSMeasurementVariable_siz, localB->elevation_angle_data,
    &localB->elevation_angle_size, localB->azimuth_angle_data,
    &localB->azimuth_angle_size, localB);
  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->nb = 0;
  } else {
    localB->nb = rtu_GNSSMeasurementVariab_DIMS1->PRN;
  }

  if (localB->nb - 1 >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->elevation_angle[0],
                &localB->elevation_angle_data[0], static_cast<uint32_T>
                (localB->nb) * sizeof(real_T));
  }

  if (rtu_GNSSMeasurementVariab_DIMS1->PRN < 1) {
    localB->nb = 0;
  } else {
    localB->nb = rtu_GNSSMeasurementVariab_DIMS1->PRN;
  }

  if (localB->nb - 1 >= 0) {
    std::memcpy(&rty_GNSSMeasurementFixed->azimuth_angle[0],
                &localB->azimuth_angle_data[0], static_cast<uint32_T>(localB->nb)
                * sizeof(real_T));
  }

  *rty_sizeOfMesasurements = rtu_GNSSMeasurementVariab_DIMS1->PRN;
}

//
// Output and update for atomic system:
//    '<S4>/Dummy GNSS Measurement'
//    '<S5>/Dummy GNSS Measurement'
//
void DDRTCM::DDRTCM_DummyGNSSMeasurement(B_DummyGNSSMeasurement_DDRTCM_T *localB,
  DW_DummyGNSSMeasurement_DDRTC_T *localDW)
{
  localB->dummy_GNSS_Measurement_Bus.time_receive = 0.0;
  localB->dummy_GNSS_Measurement_Bus.satellite_position[0] = 0.0;
  localDW->SFunction_DIMS2.satellite_position[0] = 1;
  localDW->SFunction_DIMS2.satellite_velocity[0] = 1;
  localDW->SFunction_DIMS2.satellite_position[1] = 1;
  localDW->SFunction_DIMS2.satellite_velocity[1] = 1;
  localB->dummy_GNSS_Measurement_Bus.satellite_velocity[0] = 0.0;
  localDW->SFunction_DIMS2.PRN = 1;
  localB->dummy_GNSS_Measurement_Bus.PRN[0] = 0U;
  localDW->SFunction_DIMS2.pseudorange = 1;
  localB->dummy_GNSS_Measurement_Bus.pseudorange[0] = 0.0;
  localDW->SFunction_DIMS2.pseudorange_raw = 1;
  localB->dummy_GNSS_Measurement_Bus.pseudorange_raw[0] = 0.0;
  localDW->SFunction_DIMS2.pseudorange_satclk_corrected = 1;
  localB->dummy_GNSS_Measurement_Bus.pseudorange_satclk_corrected[0] = 0.0;
  localDW->SFunction_DIMS2.deltarange = 1;
  localB->dummy_GNSS_Measurement_Bus.deltarange[0] = 0.0;
  localDW->SFunction_DIMS2.deltarange_raw = 1;
  localB->dummy_GNSS_Measurement_Bus.deltarange_raw[0] = 0.0;
  localDW->SFunction_DIMS2.deltarange_satclk_corrected = 1;
  localB->dummy_GNSS_Measurement_Bus.deltarange_satclk_corrected[0] = 0.0;
  localDW->SFunction_DIMS2.variance_pseudorange = 1;
  localB->dummy_GNSS_Measurement_Bus.variance_pseudorange[0] = 0.0;
  localDW->SFunction_DIMS2.variance_pseudorange_measured = 1;
  localB->dummy_GNSS_Measurement_Bus.variance_pseudorange_measured[0] = 0.0;
  localDW->SFunction_DIMS2.variance_deltarange = 1;
  localB->dummy_GNSS_Measurement_Bus.variance_deltarange[0] = 0.0;
  localDW->SFunction_DIMS2.carrierphase = 1;
  localB->dummy_GNSS_Measurement_Bus.carrierphase[0] = 0.0;
  localDW->SFunction_DIMS2.carrierphase_raw = 1;
  localB->dummy_GNSS_Measurement_Bus.carrierphase_raw[0] = 0.0;
  localDW->SFunction_DIMS2.carrierphase_satclk_corrected = 1;
  localB->dummy_GNSS_Measurement_Bus.carrierphase_satclk_corrected[0] = 0.0;
  localDW->SFunction_DIMS2.variance_carrierphase_measured = 1;
  localB->dummy_GNSS_Measurement_Bus.variance_carrierphase_measured[0] = 0.0;
  localDW->SFunction_DIMS2.locktime = 1;
  localB->dummy_GNSS_Measurement_Bus.locktime[0] = 0.0F;
  localDW->SFunction_DIMS2.CN0 = 1;
  localB->dummy_GNSS_Measurement_Bus.CN0[0] = 0.0;
  localB->dummy_GNSS_Measurement_Bus.base_position[0] = 0.0;
  localB->dummy_GNSS_Measurement_Bus.base_position[1] = 0.0;
  localB->dummy_GNSS_Measurement_Bus.base_position[2] = 0.0;
}

//
// Output and update for atomic system:
//    '<S4>/Fuse'
//    '<S5>/Fuse'
//
void DDRTCM::DDRTCM_Fuse(const uint16_T rtu_u1[40], const int32_T *rtu_u1_DIMS1,
  const uint16_T rtu_u2[40], const int32_T *rtu_u2_DIMS1, B_Fuse_DDRTCM_T
  *localB, DW_Fuse_DDRTCM_T *localDW)
{
  localDW->SFunction_DIMS2 = *rtu_u1_DIMS1 + *rtu_u2_DIMS1;
  for (int32_T i{0}; i < *rtu_u1_DIMS1; i++) {
    localB->tmp_data[i] = rtu_u1[i];
  }

  for (int32_T i{0}; i < *rtu_u2_DIMS1; i++) {
    localB->tmp_data[i + *rtu_u1_DIMS1] = rtu_u2[i];
  }

  if (localDW->SFunction_DIMS2 - 1 >= 0) {
    std::memcpy(&localB->y[0], &localB->tmp_data[0], static_cast<uint32_T>
                (localDW->SFunction_DIMS2) * sizeof(uint16_T));
  }
}

// Function for MATLAB Function: '<S60>/Apply Elevation and NaN and Zero Mask'
void DDRTCM::DDRTCM_any_j(const boolean_T x_data[], const int32_T x_size[2],
  boolean_T y_data[], int32_T *y_size)
{
  int32_T c;
  int32_T i1;
  int32_T i2;
  int32_T vstride;
  *y_size = static_cast<int8_T>(x_size[0]);
  vstride = static_cast<int8_T>(x_size[0]);
  if (vstride - 1 >= 0) {
    std::memset(&y_data[0], 0, static_cast<uint32_T>(vstride) * sizeof(boolean_T));
  }

  vstride = x_size[0];
  i2 = (x_size[1] - 1) * x_size[0];
  i1 = 0;
  c = x_size[0];
  for (int32_T j{0}; j < c; j++) {
    int32_T ix;
    boolean_T exitg1;
    i1++;
    i2++;
    ix = i1;
    exitg1 = false;
    while ((!exitg1) && ((vstride > 0) && (ix <= i2))) {
      if (x_data[ix - 1]) {
        y_data[j] = true;
        exitg1 = true;
      } else {
        ix += vstride;
      }
    }
  }
}

// Function for MATLAB Function: '<S60>/Apply Elevation and NaN and Zero Mask'
void DDRTCM::DDRTCM_any_jt(const boolean_T x_data[], const int32_T *x_size,
  boolean_T y_data[], int32_T *y_size)
{
  int32_T c;
  int32_T i1;
  int32_T i2;
  *y_size = static_cast<int8_T>(*x_size);
  if (static_cast<int8_T>(*x_size) - 1 >= 0) {
    std::memset(&y_data[0], 0, static_cast<uint32_T>(static_cast<int8_T>(*x_size))
                * sizeof(boolean_T));
  }

  i1 = 0;
  i2 = 0;
  c = *x_size;
  for (int32_T j{0}; j < c; j++) {
    int32_T ix;
    boolean_T exitg1;
    i1++;
    i2++;
    ix = i1;
    exitg1 = false;
    while ((!exitg1) && ((*x_size > 0) && (ix <= i2))) {
      if (x_data[ix - 1]) {
        y_data[j] = true;
        exitg1 = true;
      } else {
        ix += *x_size;
      }
    }
  }
}

void DDRTCM::DDRTCM_binary_expand_op_ofr(boolean_T in1_data[], int32_T *in1_size,
  const GNSS_Measurement *in2, const GNSS_Measurement_size *in3,
  B_ApplyElevationandNaNandZero_T *localB)
{
  int32_T in3_idx_0;
  int32_T in3_idx_1;
  int32_T loop_ub;
  int32_T stride_2_0;
  int32_T tmp_size;
  int32_T tmp_size_0;
  int32_T tmp_size_1;
  localB->tmp_size[0] = in3->satellite_position[0];
  localB->tmp_size[1] = in3->satellite_position[1];
  loop_ub = in3->satellite_position[0] * in3->satellite_position[1];
  for (tmp_size_1 = 0; tmp_size_1 < loop_ub; tmp_size_1++) {
    localB->tmp_data[tmp_size_1] = std::isnan(in2->satellite_position[tmp_size_1]);
  }

  DDRTCM_any_j(localB->tmp_data, localB->tmp_size, localB->tmp_data_p, &tmp_size);
  localB->tmp_size[0] = in3->satellite_velocity[0];
  localB->tmp_size[1] = in3->satellite_velocity[1];
  loop_ub = in3->satellite_velocity[0] * in3->satellite_velocity[1];
  for (tmp_size_1 = 0; tmp_size_1 < loop_ub; tmp_size_1++) {
    localB->tmp_data[tmp_size_1] = std::isnan(in2->satellite_velocity[tmp_size_1]);
  }

  DDRTCM_any_j(localB->tmp_data, localB->tmp_size, localB->tmp_data_l,
               &tmp_size_0);
  loop_ub = in3->pseudorange;
  for (tmp_size_1 = 0; tmp_size_1 < loop_ub; tmp_size_1++) {
    localB->tmp_data_j[tmp_size_1] = std::isnan(in2->pseudorange[tmp_size_1]);
  }

  DDRTCM_any_jt(localB->tmp_data_j, &in3->pseudorange, localB->tmp_data_d,
                &tmp_size_1);
  *in1_size = tmp_size_1 == 1 ? tmp_size_0 == 1 ? tmp_size : tmp_size_0 :
    tmp_size_1;
  in3_idx_0 = (tmp_size != 1);
  in3_idx_1 = (tmp_size_0 != 1);
  stride_2_0 = (tmp_size_1 != 1);
  loop_ub = tmp_size_1 == 1 ? tmp_size_0 == 1 ? tmp_size : tmp_size_0 :
    tmp_size_1;
  for (tmp_size_1 = 0; tmp_size_1 < loop_ub; tmp_size_1++) {
    in1_data[tmp_size_1] = ((!localB->tmp_data_p[tmp_size_1 * in3_idx_0]) &&
      (!localB->tmp_data_l[tmp_size_1 * in3_idx_1]) && (!localB->
      tmp_data_d[tmp_size_1 * stride_2_0]));
  }
}

void DDRTCM::DDRTCM_binary_expand_op_of(boolean_T in1_data[], int32_T *in1_size,
  const boolean_T in2[40], const int32_T *in3, const boolean_T in4_data[], const
  int32_T *in4_size, const GNSS_Measurement *in5, const GNSS_Measurement_size
  *in6, B_ApplyElevationandNaNandZero_T *localB)
{
  int32_T in6_idx_0;
  int32_T in6_idx_1;
  int32_T loop_ub;
  int32_T stride_2_0;
  int32_T stride_3_0;
  int32_T stride_4_0;
  int32_T tmp_size;
  int32_T tmp_size_0;
  localB->in5_size[0] = in6->satellite_position[0];
  localB->in5_size[1] = in6->satellite_position[1];
  loop_ub = in6->satellite_position[0] * in6->satellite_position[1];
  for (localB->i = 0; localB->i < loop_ub; localB->i++) {
    localB->in5_data[localB->i] = (in5->satellite_position[localB->i] == 0.0);
  }

  DDRTCM_any_j(localB->in5_data, localB->in5_size, localB->tmp_data_g, &tmp_size);
  localB->in5_size[0] = in6->satellite_velocity[0];
  localB->in5_size[1] = in6->satellite_velocity[1];
  loop_ub = in6->satellite_velocity[0] * in6->satellite_velocity[1];
  for (localB->i = 0; localB->i < loop_ub; localB->i++) {
    localB->in5_data[localB->i] = (in5->satellite_velocity[localB->i] == 0.0);
  }

  DDRTCM_any_j(localB->in5_data, localB->in5_size, localB->tmp_data_g1,
               &tmp_size_0);
  loop_ub = in6->pseudorange;
  for (localB->i = 0; localB->i < loop_ub; localB->i++) {
    localB->in5_data_m[localB->i] = (in5->pseudorange[localB->i] < 1.0E+6);
  }

  DDRTCM_any_jt(localB->in5_data_m, &in6->pseudorange, localB->tmp_data_n,
                &loop_ub);
  *in1_size = (loop_ub == 1 ? tmp_size_0 == 1 ? tmp_size : tmp_size_0 : loop_ub)
    == 1 ? *in4_size == 1 ? *in3 : *in4_size : loop_ub == 1 ? tmp_size_0 == 1 ?
    tmp_size : tmp_size_0 : loop_ub;
  in6_idx_0 = (*in3 != 1);
  in6_idx_1 = (*in4_size != 1);
  stride_2_0 = (tmp_size != 1);
  stride_3_0 = (tmp_size_0 != 1);
  stride_4_0 = (loop_ub != 1);
  loop_ub = (loop_ub == 1 ? tmp_size_0 == 1 ? tmp_size : tmp_size_0 : loop_ub) ==
    1 ? *in4_size == 1 ? *in3 : *in4_size : loop_ub == 1 ? tmp_size_0 == 1 ?
    tmp_size : tmp_size_0 : loop_ub;
  for (localB->i = 0; localB->i < loop_ub; localB->i++) {
    in1_data[localB->i] = (in2[localB->i * in6_idx_0] && in4_data[localB->i *
      in6_idx_1] && ((!localB->tmp_data_g[localB->i * stride_2_0]) &&
                     (!localB->tmp_data_g1[localB->i * stride_3_0]) &&
                     (!localB->tmp_data_n[localB->i * stride_4_0])));
  }
}

// Function for MATLAB Function: '<S60>/Apply Elevation and NaN and Zero Mask'
boolean_T DDRTCM::DDRTCM_any_jte(const boolean_T x_data[], const int32_T *x_size)
{
  int32_T ix;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  ix = 1;
  exitg1 = false;
  while ((!exitg1) && (ix <= *x_size)) {
    if (x_data[ix - 1]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

//
// Output and update for atomic system:
//    '<S60>/Apply Elevation and NaN and Zero Mask'
//    '<S187>/Apply Elevation and NaN and Zero Mask'
//
void DDRTCM::ApplyElevationandNaNandZeroMask(const GNSS_Measurement
  *rtu_measurementFrequencyCorrect, const GNSS_Measurement_size
  *rtu_measurementFrequencyC_DIMS1, const boolean_T rtu_elevationMask[40], const
  int32_T *rtu_elevationMask_DIMS1, uint16_T *rty_nan_errCnt,
  B_ApplyElevationandNaNandZero_T *localB, DW_ApplyElevationandNaNandZer_T
  *localDW)
{
  localB->rtu_measurementFrequencyCorre_g[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[0];
  localB->rtu_measurementFrequencyCorre_g[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  localB->loop_ub_tmp = rtu_measurementFrequencyC_DIMS1->satellite_position[0] *
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->rtu_measurementFrequencyCorrect[localB->b_i] = std::isnan
      (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i]);
  }

  localB->rtu_measurementFrequencyCorre_l[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
  localB->rtu_measurementFrequencyCorre_l[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  localB->loop_ub_tmp_o = rtu_measurementFrequencyC_DIMS1->satellite_velocity[0]
    * rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_c[localB->b_i] = std::isnan
      (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i]);
  }

  localB->rtu_measurementFrequencyCorre_d[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[0];
  localB->rtu_measurementFrequencyCorre_d[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_k[localB->b_i] = std::isnan
      (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i]);
  }

  DDRTCM_any_j(localB->rtu_measurementFrequencyCorre_k,
               localB->rtu_measurementFrequencyCorre_d, localB->nan_mask_data_c,
               &localB->nan_mask_size_h);
  localB->rtu_measurementFrequencyCorre_d[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
  localB->rtu_measurementFrequencyCorre_d[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_k[localB->b_i] = std::isnan
      (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i]);
  }

  localB->tmp_size_b = rtu_measurementFrequencyC_DIMS1->pseudorange;
  localB->rtu_measurementFrequencyC_DIMS1 =
    rtu_measurementFrequencyC_DIMS1->pseudorange;
  for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
       localB->b_i++) {
    localB->tmp_data_b[localB->b_i] = std::isnan
      (rtu_measurementFrequencyCorrect->pseudorange[localB->b_i]);
  }

  DDRTCM_any_j(localB->rtu_measurementFrequencyCorrect,
               localB->rtu_measurementFrequencyCorre_g, localB->tmp_data_f,
               &localB->tmp_size_d);
  DDRTCM_any_j(localB->rtu_measurementFrequencyCorre_c,
               localB->rtu_measurementFrequencyCorre_l, localB->tmp_data_f,
               &localB->tmp_size_e);
  DDRTCM_any_j(localB->rtu_measurementFrequencyCorre_k,
               localB->rtu_measurementFrequencyCorre_d, localB->tmp_data_f,
               &localB->tmp_size_bj);
  DDRTCM_any_jt(localB->tmp_data_b, &localB->tmp_size_b, localB->tmp_data_f,
                &localB->tmp_size_j);
  if ((localB->tmp_size_d == localB->tmp_size_e) && ((localB->nan_mask_size_h ==
        1 ? localB->tmp_size_bj : localB->nan_mask_size_h) == localB->tmp_size_j))
  {
    localB->rtu_measurementFrequencyCorre_g[0] =
      rtu_measurementFrequencyC_DIMS1->satellite_position[0];
    localB->rtu_measurementFrequencyCorre_g[1] =
      rtu_measurementFrequencyC_DIMS1->satellite_position[1];
    for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
      localB->rtu_measurementFrequencyCorrect[localB->b_i] = std::isnan
        (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i]);
    }

    DDRTCM_any_j(localB->rtu_measurementFrequencyCorrect,
                 localB->rtu_measurementFrequencyCorre_g,
                 localB->nan_mask_data_c, &localB->nan_mask_size_h);
    localB->rtu_measurementFrequencyCorre_g[0] =
      rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
    localB->rtu_measurementFrequencyCorre_g[1] =
      rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
    for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
      localB->rtu_measurementFrequencyCorrect[localB->b_i] = std::isnan
        (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i]);
    }

    DDRTCM_any_j(localB->rtu_measurementFrequencyCorrect,
                 localB->rtu_measurementFrequencyCorre_g, localB->tmp_data_b,
                 &localB->tmp_size_b);
    localB->tmp_size_n = rtu_measurementFrequencyC_DIMS1->pseudorange;
    localB->rtu_measurementFrequencyC_DIMS1 =
      rtu_measurementFrequencyC_DIMS1->pseudorange;
    for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
         localB->b_i++) {
      localB->tmp_data_f[localB->b_i] = std::isnan
        (rtu_measurementFrequencyCorrect->pseudorange[localB->b_i]);
    }

    DDRTCM_any_jt(localB->tmp_data_f, &localB->tmp_size_n,
                  localB->rtu_measurementFrequencyCorre_p,
                  &localB->rtu_measurementFrequencyCorre_b);
    localB->nan_mask_size = localB->nan_mask_size_h;
    localB->rtu_measurementFrequencyC_DIMS1 = localB->nan_mask_size_h;
    for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
         localB->b_i++) {
      localB->nan_mask_data[localB->b_i] = ((!localB->nan_mask_data_c
        [localB->b_i]) && (!localB->tmp_data_b[localB->b_i]) &&
        (!localB->rtu_measurementFrequencyCorre_p[localB->b_i]));
    }
  } else {
    DDRTCM_binary_expand_op_ofr(localB->nan_mask_data, &localB->nan_mask_size,
      rtu_measurementFrequencyCorrect, rtu_measurementFrequencyC_DIMS1, localB);
  }

  localB->rtu_measurementFrequencyCorre_g[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[0];
  localB->rtu_measurementFrequencyCorre_g[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->rtu_measurementFrequencyCorrect[localB->b_i] =
      (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i] == 0.0);
  }

  localB->rtu_measurementFrequencyCorre_l[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
  localB->rtu_measurementFrequencyCorre_l[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_c[localB->b_i] =
      (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i] == 0.0);
  }

  localB->rtu_measurementFrequencyCorre_d[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[0];
  localB->rtu_measurementFrequencyCorre_d[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_k[localB->b_i] =
      (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i] == 0.0);
  }

  DDRTCM_any_j(localB->rtu_measurementFrequencyCorre_k,
               localB->rtu_measurementFrequencyCorre_d, localB->nan_mask_data_c,
               &localB->nan_mask_size_h);
  localB->rtu_measurementFrequencyCorre_d[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
  localB->rtu_measurementFrequencyCorre_d[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_k[localB->b_i] =
      (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i] == 0.0);
  }

  localB->rtu_measurementFrequencyCorre_b =
    rtu_measurementFrequencyC_DIMS1->pseudorange;
  localB->rtu_measurementFrequencyC_DIMS1 =
    rtu_measurementFrequencyC_DIMS1->pseudorange;
  for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
       localB->b_i++) {
    localB->rtu_measurementFrequencyCorre_p[localB->b_i] =
      (rtu_measurementFrequencyCorrect->pseudorange[localB->b_i] < 1.0E+6);
  }

  localB->rtu_measurementFrequencyCorr_dy[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[0];
  localB->rtu_measurementFrequencyCorr_dy[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->rtu_measurementFrequencyCorr_cx[localB->b_i] =
      (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i] == 0.0);
  }

  DDRTCM_any_j(localB->rtu_measurementFrequencyCorr_cx,
               localB->rtu_measurementFrequencyCorr_dy, localB->tmp_data_b,
               &localB->tmp_size_b);
  localB->rtu_measurementFrequencyCorr_dy[0] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
  localB->rtu_measurementFrequencyCorr_dy[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
    localB->rtu_measurementFrequencyCorr_cx[localB->b_i] =
      (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i] == 0.0);
  }

  DDRTCM_any_j(localB->rtu_measurementFrequencyCorr_cx,
               localB->rtu_measurementFrequencyCorr_dy, localB->tmp_data_f,
               &localB->tmp_size_n);
  localB->rtu_measurementFrequencyCorr_ln =
    rtu_measurementFrequencyC_DIMS1->pseudorange;
  localB->rtu_measurementFrequencyC_DIMS1 =
    rtu_measurementFrequencyC_DIMS1->pseudorange;
  for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
       localB->b_i++) {
    localB->nan_mask_data_c[localB->b_i] =
      (rtu_measurementFrequencyCorrect->pseudorange[localB->b_i] < 1.0E+6);
  }

  DDRTCM_any_j(localB->rtu_measurementFrequencyCorrect,
               localB->rtu_measurementFrequencyCorre_g, localB->tmp_data_b,
               &localB->tmp_size_d);
  DDRTCM_any_j(localB->rtu_measurementFrequencyCorre_c,
               localB->rtu_measurementFrequencyCorre_l, localB->tmp_data_b,
               &localB->tmp_size_e);
  DDRTCM_any_j(localB->rtu_measurementFrequencyCorre_k,
               localB->rtu_measurementFrequencyCorre_d, localB->tmp_data_b,
               &localB->tmp_size_bj);
  DDRTCM_any_jt(localB->rtu_measurementFrequencyCorre_p,
                &localB->rtu_measurementFrequencyCorre_b, localB->tmp_data_b,
                &localB->tmp_size_j);
  DDRTCM_any_jt(localB->nan_mask_data_c,
                &localB->rtu_measurementFrequencyCorr_ln, localB->tmp_data_b,
                &localB->tmp_size_bn);
  if ((*rtu_elevationMask_DIMS1 == localB->nan_mask_size) && (localB->tmp_size_d
       == localB->tmp_size_e) && ((localB->nan_mask_size_h == 1 ?
        localB->tmp_size_bj : localB->nan_mask_size_h) == localB->tmp_size_j) &&
      (((localB->tmp_size_b == 1 ? localB->tmp_size_n : localB->tmp_size_b) == 1
        ? localB->tmp_size_bn : localB->tmp_size_b == 1 ? localB->tmp_size_n :
        localB->tmp_size_b) == (*rtu_elevationMask_DIMS1 == 1 ?
        localB->nan_mask_size : *rtu_elevationMask_DIMS1))) {
    localB->rtu_measurementFrequencyCorre_g[0] =
      rtu_measurementFrequencyC_DIMS1->satellite_position[0];
    localB->rtu_measurementFrequencyCorre_g[1] =
      rtu_measurementFrequencyC_DIMS1->satellite_position[1];
    for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
      localB->rtu_measurementFrequencyCorrect[localB->b_i] =
        (rtu_measurementFrequencyCorrect->satellite_position[localB->b_i] == 0.0);
    }

    DDRTCM_any_j(localB->rtu_measurementFrequencyCorrect,
                 localB->rtu_measurementFrequencyCorre_g,
                 localB->nan_mask_data_c, &localB->nan_mask_size_h);
    localB->rtu_measurementFrequencyCorre_g[0] =
      rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
    localB->rtu_measurementFrequencyCorre_g[1] =
      rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
    for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp_o; localB->b_i++) {
      localB->rtu_measurementFrequencyCorrect[localB->b_i] =
        (rtu_measurementFrequencyCorrect->satellite_velocity[localB->b_i] == 0.0);
    }

    DDRTCM_any_j(localB->rtu_measurementFrequencyCorrect,
                 localB->rtu_measurementFrequencyCorre_g, localB->tmp_data_b,
                 &localB->tmp_size_b);
    localB->rtu_measurementFrequencyCorre_b =
      rtu_measurementFrequencyC_DIMS1->pseudorange;
    localB->rtu_measurementFrequencyC_DIMS1 =
      rtu_measurementFrequencyC_DIMS1->pseudorange;
    for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
         localB->b_i++) {
      localB->rtu_measurementFrequencyCorre_p[localB->b_i] =
        (rtu_measurementFrequencyCorrect->pseudorange[localB->b_i] < 1.0E+6);
    }

    DDRTCM_any_jt(localB->rtu_measurementFrequencyCorre_p,
                  &localB->rtu_measurementFrequencyCorre_b, localB->tmp_data_f,
                  &localB->tmp_size_n);
    localB->mask_all_size = *rtu_elevationMask_DIMS1;
    for (localB->b_i = 0; localB->b_i < *rtu_elevationMask_DIMS1; localB->b_i++)
    {
      localB->mask_all_data[localB->b_i] = (rtu_elevationMask[localB->b_i] &&
        localB->nan_mask_data[localB->b_i] && ((!localB->nan_mask_data_c
        [localB->b_i]) && (!localB->tmp_data_b[localB->b_i]) &&
        (!localB->tmp_data_f[localB->b_i])));
    }
  } else {
    DDRTCM_binary_expand_op_of(localB->mask_all_data, &localB->mask_all_size,
      rtu_elevationMask, rtu_elevationMask_DIMS1, localB->nan_mask_data,
      &localB->nan_mask_size, rtu_measurementFrequencyCorrect,
      rtu_measurementFrequencyC_DIMS1, localB);
  }

  localB->measurementFrequencyCorrectedMa.time_receive =
    rtu_measurementFrequencyCorrect->time_receive;
  localB->loop_ub_tmp_tmp = localB->mask_all_size - 1;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->b_size_idx_0 = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->b_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.satellite_position[0] = localB->b_size_idx_0;
  localDW->SFunction_DIMS2.satellite_position[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  localB->loop_ub_tmp_o = rtu_measurementFrequencyC_DIMS1->satellite_position[0];
  localB->unnamed_idx_0 = localDW->SFunction_DIMS2.satellite_position[0];
  localB->rtu_measurementFrequencyC_DIMS1 =
    rtu_measurementFrequencyC_DIMS1->satellite_position[1];
  for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
       localB->b_i++) {
    for (localB->loop_ub_tmp = 0; localB->loop_ub_tmp < localB->b_size_idx_0;
         localB->loop_ub_tmp++) {
      localB->measurementFrequencyCorrectedMa.satellite_position
        [localB->loop_ub_tmp + localB->unnamed_idx_0 * localB->b_i] =
        rtu_measurementFrequencyCorrect->satellite_position
        [(localB->loop_ub_tmp_o * localB->b_i + localB->b_data
          [localB->loop_ub_tmp]) - 1];
    }
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->b_size_idx_0 = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->c_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.satellite_velocity[0] = localB->b_size_idx_0;
  localDW->SFunction_DIMS2.satellite_velocity[1] =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  localB->loop_ub_tmp_o = rtu_measurementFrequencyC_DIMS1->satellite_velocity[0];
  localB->unnamed_idx_0 = localDW->SFunction_DIMS2.satellite_velocity[0];
  localB->rtu_measurementFrequencyC_DIMS1 =
    rtu_measurementFrequencyC_DIMS1->satellite_velocity[1];
  for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
       localB->b_i++) {
    for (localB->loop_ub_tmp = 0; localB->loop_ub_tmp < localB->b_size_idx_0;
         localB->loop_ub_tmp++) {
      localB->measurementFrequencyCorrectedMa.satellite_velocity
        [localB->loop_ub_tmp + localB->unnamed_idx_0 * localB->b_i] =
        rtu_measurementFrequencyCorrect->satellite_velocity
        [(localB->loop_ub_tmp_o * localB->b_i + localB->c_data
          [localB->loop_ub_tmp]) - 1];
    }
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->d_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.PRN = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.PRN[localB->b_i] =
      rtu_measurementFrequencyCorrect->PRN[localB->d_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->e_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.pseudorange = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.pseudorange[localB->b_i] =
      rtu_measurementFrequencyCorrect->pseudorange[localB->e_data[localB->b_i] -
      1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->f_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.pseudorange_raw = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.pseudorange_raw[localB->b_i] =
      rtu_measurementFrequencyCorrect->pseudorange_raw[localB->f_data
      [localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->g_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.pseudorange_satclk_corrected = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.pseudorange_satclk_corrected
      [localB->b_i] =
      rtu_measurementFrequencyCorrect->pseudorange_satclk_corrected
      [localB->g_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->h_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.deltarange = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.deltarange[localB->b_i] =
      rtu_measurementFrequencyCorrect->deltarange[localB->h_data[localB->b_i] -
      1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->i_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.deltarange_raw = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.deltarange_raw[localB->b_i] =
      rtu_measurementFrequencyCorrect->deltarange_raw[localB->i_data[localB->b_i]
      - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->j_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.deltarange_satclk_corrected = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.deltarange_satclk_corrected
      [localB->b_i] =
      rtu_measurementFrequencyCorrect->deltarange_satclk_corrected
      [localB->j_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->k_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.variance_pseudorange = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.variance_pseudorange[localB->b_i] =
      rtu_measurementFrequencyCorrect->variance_pseudorange[localB->
      k_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->l_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.variance_pseudorange_measured = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.variance_pseudorange_measured
      [localB->b_i] =
      rtu_measurementFrequencyCorrect->variance_pseudorange_measured
      [localB->l_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->m_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.variance_deltarange = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.variance_deltarange[localB->b_i] =
      rtu_measurementFrequencyCorrect->variance_deltarange[localB->m_data
      [localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->n_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.carrierphase = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.carrierphase[localB->b_i] =
      rtu_measurementFrequencyCorrect->carrierphase[localB->n_data[localB->b_i]
      - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->o_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.carrierphase_raw = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.carrierphase_raw[localB->b_i] =
      rtu_measurementFrequencyCorrect->carrierphase_raw[localB->o_data
      [localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->p_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.carrierphase_satclk_corrected = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.carrierphase_satclk_corrected
      [localB->b_i] =
      rtu_measurementFrequencyCorrect->carrierphase_satclk_corrected
      [localB->p_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->q_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.variance_carrierphase_measured = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->
      measurementFrequencyCorrectedMa.variance_carrierphase_measured[localB->b_i]
      = rtu_measurementFrequencyCorrect->variance_carrierphase_measured
      [localB->q_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->r_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.locktime = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.locktime[localB->b_i] =
      rtu_measurementFrequencyCorrect->locktime[localB->r_data[localB->b_i] - 1];
  }

  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->loop_ub_tmp_o++;
    }
  }

  localB->loop_ub_tmp = localB->loop_ub_tmp_o;
  localB->loop_ub_tmp_o = 0;
  for (localB->b_i = 0; localB->b_i <= localB->loop_ub_tmp_tmp; localB->b_i++) {
    if (localB->mask_all_data[localB->b_i]) {
      localB->s_data[localB->loop_ub_tmp_o] = static_cast<int8_T>(localB->b_i +
        1);
      localB->loop_ub_tmp_o++;
    }
  }

  localDW->SFunction_DIMS2.CN0 = localB->loop_ub_tmp;
  for (localB->b_i = 0; localB->b_i < localB->loop_ub_tmp; localB->b_i++) {
    localB->measurementFrequencyCorrectedMa.CN0[localB->b_i] =
      rtu_measurementFrequencyCorrect->CN0[localB->s_data[localB->b_i] - 1];
  }

  localB->measurementFrequencyCorrectedMa.base_position[0] =
    rtu_measurementFrequencyCorrect->base_position[0];
  localB->measurementFrequencyCorrectedMa.base_position[1] =
    rtu_measurementFrequencyCorrect->base_position[1];
  localB->measurementFrequencyCorrectedMa.base_position[2] =
    rtu_measurementFrequencyCorrect->base_position[2];
  localB->nan_mask_size_h = localB->nan_mask_size;
  localB->rtu_measurementFrequencyC_DIMS1 = localB->nan_mask_size;
  for (localB->b_i = 0; localB->b_i < localB->rtu_measurementFrequencyC_DIMS1;
       localB->b_i++) {
    localB->nan_mask_data_c[localB->b_i] = !localB->nan_mask_data[localB->b_i];
  }

  if (DDRTCM_any_jte(localB->nan_mask_data_c, &localB->nan_mask_size_h)) {
    localB->u = localDW->nanerrs + 1U;
    if (localDW->nanerrs + 1U > 65535U) {
      localB->u = 65535U;
    }

    localDW->nanerrs = static_cast<uint16_T>(localB->u);
  }

  *rty_nan_errCnt = localDW->nanerrs;
}

// Function for MATLAB Function: '<S56>/Calculate Wide Lane Combination'
void DDRTCM::DDRTCM_do_vectors_e(const uint16_T a_data[], const int32_T *a_size,
  const uint16_T b_data[], const int32_T *b_size, uint16_T c_data[], int32_T
  *c_size, int32_T ia_data[], int32_T *ia_size, int32_T ib_data[], int32_T
  *ib_size, B_GPS_DDRTCM_T *localB)
{
  if (*a_size <= *b_size) {
    localB->ncmax = *a_size;
  } else {
    localB->ncmax = *b_size;
  }

  *c_size = localB->ncmax;
  *ia_size = localB->ncmax;
  *ib_size = localB->ncmax;
  localB->nc = 0;
  localB->iafirst = 0;
  localB->ialast = 1;
  localB->ibfirst = 0;
  localB->iblast = 1;
  while ((localB->ialast <= *a_size) && (localB->iblast <= *b_size)) {
    localB->b_ialast = localB->ialast;
    localB->ak = a_data[localB->ialast - 1];
    while ((localB->b_ialast < *a_size) && (a_data[localB->b_ialast] ==
            localB->ak)) {
      localB->b_ialast++;
    }

    localB->ialast = localB->b_ialast;
    localB->b_iblast = localB->iblast;
    localB->bk = b_data[localB->iblast - 1];
    while ((localB->b_iblast < *b_size) && (b_data[localB->b_iblast] ==
            localB->bk)) {
      localB->b_iblast++;
    }

    localB->iblast = localB->b_iblast;
    if (localB->ak == localB->bk) {
      localB->nc++;
      c_data[localB->nc - 1] = localB->ak;
      ia_data[localB->nc - 1] = localB->iafirst + 1;
      ib_data[localB->nc - 1] = localB->ibfirst + 1;
      localB->ialast = localB->b_ialast + 1;
      localB->iafirst = localB->b_ialast;
      localB->iblast = localB->b_iblast + 1;
      localB->ibfirst = localB->b_iblast;
    } else if (localB->ak < localB->bk) {
      localB->ialast = localB->b_ialast + 1;
      localB->iafirst = localB->b_ialast;
    } else {
      localB->iblast = localB->b_iblast + 1;
      localB->ibfirst = localB->b_iblast;
    }
  }

  if (localB->ncmax > 0) {
    if (localB->nc < 1) {
      *ia_size = 0;
      *ib_size = 0;
      *c_size = 0;
    } else {
      *ia_size = localB->nc;
      *ib_size = localB->nc;
      *c_size = localB->nc;
    }
  }
}

void DDRTCM::DDRTCM_binary_expand_op_hp(GNSS_Measurement *in1, const int32_T
  in3_data[], const int32_T *in3_size, const real_T in4[40], const real_T in6[40],
  const int32_T in8_data[], const int32_T *in8_size, B_GPS_DDRTCM_T *localB)
{
  // Outputs for Enabled SubSystem: '<S4>/GPS' incorporates:
  //   EnablePort: '<S16>/Enable'

  // MATLAB Function: '<S56>/Calculate Wide Lane Combination' incorporates:
  //   BusCreator generated from: '<S56>/Calculate Wide Lane Combination'

  localB->stride_0_0 = (*in3_size != 1);
  localB->stride_1_0 = (*in8_size != 1);
  localB->loop_ub_c = *in8_size == 1 ? *in3_size : *in8_size;
  for (localB->i_k = 0; localB->i_k < localB->loop_ub_c; localB->i_k++) {
    in1->carrierphase[in3_data[localB->i_k] - 1] = in4[in3_data[localB->i_k *
      localB->stride_0_0] - 1] - in6[in8_data[localB->i_k * localB->stride_1_0]
      - 1];
  }

  // End of MATLAB Function: '<S56>/Calculate Wide Lane Combination'
  // End of Outputs for SubSystem: '<S4>/GPS'
}

//
// System initialize for enable system:
//    '<S4>/GPS'
//    '<S5>/GPS'
//
void DDRTCM::DDRTCM_GPS_Init(B_GPS_DDRTCM_T *localB, DW_GPS_DDRTCM_T *localDW,
  P_GPS_DDRTCM_T *localP)
{
  // SystemInitialize for MATLAB Function: '<S28>/Calculate Differential Corrections' 
  CalculateDifferentialCorre_Init(&localDW->sf_CalculateDifferentialCorrect);

  // SystemInitialize for Enabled SubSystem: '<S16>/GPS L2C Stream'
  D_GPSsinglefrequencystream_Init(&localB->GPSL2CStream, &localP->GPSL2CStream);

  // End of SystemInitialize for SubSystem: '<S16>/GPS L2C Stream'

  // SystemInitialize for Enabled SubSystem: '<S16>/GPS L5 Stream'
  D_GPSsinglefrequencystream_Init(&localB->GPSL5Stream, &localP->GPSL5Stream);

  // End of SystemInitialize for SubSystem: '<S16>/GPS L5 Stream'

  // SystemInitialize for Enabled SubSystem: '<S16>/GPS L1 Stream'
  D_GPSsinglefrequencystream_Init(&localB->GPSL1Stream, &localP->GPSL1Stream);

  // End of SystemInitialize for SubSystem: '<S16>/GPS L1 Stream'

  // SystemInitialize for BusSelector: '<S16>/Bus Selector' incorporates:
  //   Outport: '<S16>/timeOfWeek'

  localB->time_receive = localP->timeOfWeek_Y0;

  // SystemInitialize for BusSelector: '<S16>/Bus Selector' incorporates:
  //   Outport: '<S16>/basePosition'

  localB->base_position[0] = localP->basePosition_Y0;
  localB->base_position[1] = localP->basePosition_Y0;
  localB->base_position[2] = localP->basePosition_Y0;
}

//
// Output and update for enable system:
//    '<S4>/GPS'
//    '<S5>/GPS'
//
void DDRTCM::DDRTCM_GPS(const gnssraw_measurement_t *rtu_MeasurementEpochBus,
  const real_T rtu_GpsNavBus[37], const uint16_T rtu_GpsNavBus_a[37], const
  uint8_T rtu_GpsNavBus_d[37], const uint8_T rtu_GpsNavBus_g[37], const uint16_T
  rtu_GpsNavBus_e[37], const uint8_T rtu_GpsNavBus_k[37], const real_T
  rtu_GpsNavBus_o[37], const uint32_T rtu_GpsNavBus_oi[37], const real_T
  rtu_GpsNavBus_j[37], const real_T rtu_GpsNavBus_ak[37], const real_T
  rtu_GpsNavBus_f[37], const real_T rtu_GpsNavBus_n[37], const real_T
  rtu_GpsNavBus_c[37], const real_T rtu_GpsNavBus_gs[37], const real_T
  rtu_GpsNavBus_l[37], const real_T rtu_GpsNavBus_jq[37], const real_T
  rtu_GpsNavBus_dr[37], const real_T rtu_GpsNavBus_jp[37], const uint32_T
  rtu_GpsNavBus_a0[37], const real_T rtu_GpsNavBus_lm[37], const real_T
  rtu_GpsNavBus_lmt[37], const real_T rtu_GpsNavBus_nn[37], const real_T
  rtu_GpsNavBus_h[37], const real_T rtu_GpsNavBus_nf[37], const real_T
  rtu_GpsNavBus_m[37], const real_T rtu_GpsNavBus_jw[37], const real_T
  rtu_GpsNavBus_gx[37], const uint16_T rtu_GpsNavBus_j4[37], const uint16_T
  rtu_GpsNavBus_fn[37], real_T rtu_GpsIonBus, uint16_T rtu_GpsIonBus_f, uint8_T
  rtu_GpsIonBus_c, real_T rtu_GpsIonBus_n, real_T rtu_GpsIonBus_ce, real_T
  rtu_GpsIonBus_i, real_T rtu_GpsIonBus_b, real_T rtu_GpsIonBus_h, real_T
  rtu_GpsIonBus_k, real_T rtu_GpsIonBus_iu, real_T rtu_GpsIonBus_o, const real_T
  rtu_userPosLlh[3], real_T rtu_dayOfYear, boolean_T rtu_parameters_gnss_Bus,
  boolean_T rtu_parameters_gnss_Bus_a, boolean_T rtu_parameters_gnss_Bus_o,
  real_T rtu_parameters_gnss_Bus_m, boolean_T rtu_parameters_gnss_Bus_gs,
  boolean_T rtu_parameters_gnss_Bus_nt, boolean_T rtu_parameters_gnss_Bus_gx,
  boolean_T rtu_parameters_gnss_Bus_c5, boolean_T rtu_parameters_gnss_Bus_l,
  boolean_T rtu_parameters_gnss_Bus_nh, const GNSS_Measurement
  *rtu_GpsMeasurementB, const GNSS_Measurement_size *rtu_GpsMeasurementB_DIMS1,
  B_GPS_DDRTCM_T *localB, DW_GPS_DDRTCM_T *localDW, P_GPS_DDRTCM_T *localP)
{
  // Outputs for Enabled SubSystem: '<S4>/GPS' incorporates:
  //   EnablePort: '<S16>/Enable'

  if (rtu_parameters_gnss_Bus) {
    __m128d tmp;
    __m128d tmp_1;

    // BusCreator generated from: '<S16>/Navigation Data Conversion GPS'
    std::memcpy(&localB->BusConversion_InsertedFor_N.TOW[0], &rtu_GpsNavBus[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.WNc[0], &rtu_GpsNavBus_a[0],
                37U * sizeof(uint16_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.IODC[0], &rtu_GpsNavBus_e[0],
                37U * sizeof(uint16_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.T_gd[0], &rtu_GpsNavBus_o[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.T_oc[0], &rtu_GpsNavBus_oi
                [0], 37U * sizeof(uint32_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.A_f2[0], &rtu_GpsNavBus_j[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.A_f1[0], &rtu_GpsNavBus_ak
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.A_f0[0], &rtu_GpsNavBus_f[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.C_rs[0], &rtu_GpsNavBus_n[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.DELTA_N[0],
                &rtu_GpsNavBus_c[0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.M_0[0], &rtu_GpsNavBus_gs[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.C_uc[0], &rtu_GpsNavBus_l[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.E[0], &rtu_GpsNavBus_jq[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.C_us[0], &rtu_GpsNavBus_dr
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.SQRT_A[0],
                &rtu_GpsNavBus_jp[0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.T_oe[0], &rtu_GpsNavBus_a0
                [0], 37U * sizeof(uint32_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.C_ic[0], &rtu_GpsNavBus_lm
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.OMEGA_0[0],
                &rtu_GpsNavBus_lmt[0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.C_is[0], &rtu_GpsNavBus_nn
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.I_0[0], &rtu_GpsNavBus_h[0],
                37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.C_rc[0], &rtu_GpsNavBus_nf
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.omega[0], &rtu_GpsNavBus_m
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.OMEGADOT[0],
                &rtu_GpsNavBus_jw[0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.IDOT[0], &rtu_GpsNavBus_gx
                [0], 37U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.WNt_oc[0],
                &rtu_GpsNavBus_j4[0], 37U * sizeof(uint16_T));
    std::memcpy(&localB->BusConversion_InsertedFor_N.WNt_oe[0],
                &rtu_GpsNavBus_fn[0], 37U * sizeof(uint16_T));
    for (localB->i = 0; localB->i < 37; localB->i++) {
      localB->BusConversion_InsertedFor_N.SVID[localB->i] =
        rtu_GpsNavBus_d[localB->i];
      localB->BusConversion_InsertedFor_N.Health[localB->i] =
        rtu_GpsNavBus_g[localB->i];
      localB->BusConversion_InsertedFor_N.IODE[localB->i] =
        rtu_GpsNavBus_k[localB->i];
    }

    // MATLAB Function: '<S16>/Navigation Data Conversion GPS'
    DDR_NavigationDataConversionGPS(&localB->BusConversion_InsertedFor_N,
      &localB->sf_NavigationDataConversionGPS,
      &localDW->sf_NavigationDataConversionGPS);

    // MATLAB Function: '<S26>/MATLAB Function1' incorporates:
    //   BusCreator generated from: '<S26>/MATLAB Function1'
    //   Constant: '<S16>/L5_basedProcessing'

    if (!localP->L5_basedProcessing_Value) {
      localB->parameters_gps_Bus.enable_gps = true;
      localB->parameters_gps_Bus.enable_gps_l1 = true;
      localB->parameters_gps_Bus.enable_gps_l2 = rtu_parameters_gnss_Bus_o;
    } else {
      localB->parameters_gps_Bus.enable_gps = true;
      localB->parameters_gps_Bus.enable_gps_l1 = false;
      localB->parameters_gps_Bus.enable_gps_l2 = rtu_parameters_gnss_Bus_o;
    }

    // End of MATLAB Function: '<S26>/MATLAB Function1'

    // MATLAB Function: '<S16>/Simplify and Mask GPS Measurement Bus'
    SimplifyandMaskGPSMeasurementBu(rtu_MeasurementEpochBus,
      &localB->sf_NavigationDataConversionGPS.GpsNavBusReshaped,
      &localDW->sf_NavigationDataConversionGPS.SFunction_DIMS2,
      &localB->parameters_gps_Bus, &localB->sf_SimplifyandMaskGPSMeasuremen,
      &localDW->sf_SimplifyandMaskGPSMeasuremen);

    // MATLAB Function: '<S28>/Calculate Differential Corrections'
    CalculateDifferentialCorrection(rtu_GpsMeasurementB, (GNSS_Measurement_size *)
      rtu_GpsMeasurementB_DIMS1,
      &localB->sf_SimplifyandMaskGPSMeasuremen.navdata_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS4, rtu_userPosLlh,
      &localB->sf_CalculateDifferentialCorrect,
      &localDW->sf_CalculateDifferentialCorrect);

    // Outputs for Enabled SubSystem: '<S16>/GPS L2C Stream'
    // Outputs for Enabled SubSystem: '<S16>/GPS L2C Stream'
    // SignalConversion generated from: '<S24>/Enable' incorporates:
    //   Constant: '<S16>/Base Position Dummy'

    DDRTCM_GPSsinglefrequencystream(localB->parameters_gps_Bus.enable_gps_l2,
      localB->sf_SimplifyandMaskGPSMeasuremen.TOW,
      localB->sf_SimplifyandMaskGPSMeasuremen.svid_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS12,
      &localB->sf_SimplifyandMaskGPSMeasuremen.navdata_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS13,
      localB->sf_SimplifyandMaskGPSMeasuremen.pr_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS14,
      localB->sf_SimplifyandMaskGPSMeasuremen.dr_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS16,
      localB->sf_SimplifyandMaskGPSMeasuremen.cn0_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS17, rtu_userPosLlh,
      localB->sf_SimplifyandMaskGPSMeasuremen.cp_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS18,
      localB->sf_SimplifyandMaskGPSMeasuremen.Locktime_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS20,
      localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_c5,
      rtu_parameters_gnss_Bus_nh,
      localB->sf_SimplifyandMaskGPSMeasuremen.pr_sigma_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS15,
      localB->sf_SimplifyandMaskGPSMeasuremen.cp_sigma_L2C,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS19,
      localP->GPSL2CStream_enable_SatClockCor, &localB->GPSL2CStream,
      &localDW->GPSL2CStream, &localP->GPSL2CStream);

    // End of Outputs for SubSystem: '<S16>/GPS L2C Stream'
    // End of Outputs for SubSystem: '<S16>/GPS L2C Stream'

    // BusCreator generated from: '<S56>/Calculate Dualfrequency Correction with L1 and L2C' incorporates:
    //   SignalConversion generated from: '<S24>/SVID'

    localDW->BusConversion_InsertedFor_Calcu.satellite_position[0] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0];
    localDW->BusConversion_InsertedFor_Calcu.satellite_position[1] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    localDW->BusConversion_InsertedFor_Calcu.satellite_velocity[0] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0];
    localDW->BusConversion_InsertedFor_Calcu.satellite_velocity[1] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    localDW->BusConversion_InsertedFor_Calcu.PRN =
      localDW->GPSL2CStream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.pseudorange =
      localDW->GPSL2CStream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.pseudorange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS14;
    localDW->BusConversion_InsertedFor_Calcu.pseudorange_satclk_corrected =
      localDW->GPSL2CStream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.deltarange =
      localDW->GPSL2CStream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.deltarange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS16;
    localDW->BusConversion_InsertedFor_Calcu.deltarange_satclk_corrected =
      localDW->GPSL2CStream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.variance_pseudorange =
      localDW->GPSL2CStream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.variance_pseudorange_measured =
      localDW->GPSL2CStream.pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.variance_deltarange =
      localDW->GPSL2CStream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Calcu.carrierphase =
      localDW->GPSL2CStream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.carrierphase_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS18;
    localDW->BusConversion_InsertedFor_Calcu.carrierphase_satclk_corrected =
      localDW->GPSL2CStream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.variance_carrierphase_measured =
      localDW->GPSL2CStream.cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.locktime =
      localDW->GPSL2CStream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.CN0 =
      localDW->GPSL2CStream.carrierToNoiseRatio_DIMS1;
    localB->BusConversion_InsertedFor_h.time_receive =
      localB->GPSL2CStream.timeOfWeekIn;
    localB->loop_ub =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0] *
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->BusConversion_InsertedFor_h.satellite_position[0],
                  &localB->GPSL2CStream.sf_CalculateSatellitePositionan.satPosEcef
                  [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localB->loop_ub =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0] *
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->BusConversion_InsertedFor_h.satellite_velocity[0],
                  &localB->GPSL2CStream.sf_CalculateSatellitePositionan.satVelEcef
                  [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    for (localB->i = 0; localB->i < localDW->GPSL2CStream.SVID_DIMS1; localB->i
         ++) {
      localB->BusConversion_InsertedFor_h.PRN[localB->i] =
        localB->GPSL2CStream.PRN[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.pseudorange[localB->i] =
        localB->
        GPSL2CStream.sf_TimeCorrectionPseudorange.pseudorangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS14; localB->i++)
    {
      localB->BusConversion_InsertedFor_h.pseudorange_raw[localB->i] =
        localB->sf_SimplifyandMaskGPSMeasuremen.pr_L2C[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.pseudorange_satclk_corrected[localB->i]
        = localB->
        GPSL2CStream.sf_TimeCorrectionPseudorange.pseudorangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.deltarange[localB->i] =
        localB->
        GPSL2CStream.sf_TimeCorrectionDeltarange.deltarangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS16; localB->i++)
    {
      localB->BusConversion_InsertedFor_h.deltarange_raw[localB->i] =
        localB->sf_SimplifyandMaskGPSMeasuremen.dr_L2C[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.deltarange_satclk_corrected[localB->i]
        = localB->
        GPSL2CStream.sf_TimeCorrectionDeltarange.deltarangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_SignalNoiseVariance.SFunction_DIMS2; localB->i
         ++) {
      localB->BusConversion_InsertedFor_h.variance_pseudorange[localB->i] =
        localB->GPSL2CStream.sf_SignalNoiseVariance.variancePseudorange
        [localB->i];
    }

    for (localB->i = 0; localB->i < localDW->GPSL2CStream.pr_sigma_DIMS1;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.variance_pseudorange_measured
        [localB->i] = localB->GPSL2CStream.pr_sigma[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_SignalNoiseVariance.SFunction_DIMS3; localB->i
         ++) {
      localB->BusConversion_InsertedFor_h.variance_deltarange[localB->i] =
        localB->GPSL2CStream.sf_SignalNoiseVariance.varianceDeltarange[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.carrierphase[localB->i] =
        localB->
        GPSL2CStream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS18; localB->i++)
    {
      localB->BusConversion_InsertedFor_h.carrierphase_raw[localB->i] =
        localB->sf_SimplifyandMaskGPSMeasuremen.cp_L2C[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.carrierphase_satclk_corrected
        [localB->i] =
        localB->
        GPSL2CStream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->i];
    }

    for (localB->i = 0; localB->i < localDW->GPSL2CStream.cp_sigma_DIMS1;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.variance_carrierphase_measured
        [localB->i] = localB->GPSL2CStream.cp_sigma[localB->i];
    }

    for (localB->i = 0; localB->i < localDW->GPSL2CStream.locktime_DIMS1;
         localB->i++) {
      localB->BusConversion_InsertedFor_h.locktime[localB->i] =
        localB->GPSL2CStream.Locktime[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL2CStream.carrierToNoiseRatio_DIMS1; localB->i++) {
      localB->BusConversion_InsertedFor_h.CN0[localB->i] =
        localB->GPSL2CStream.carrierToNoiseRatio[localB->i];
    }

    localB->BusConversion_InsertedFor_h.base_position[0] =
      localB->GPSL2CStream.base_position[0];
    localB->BusConversion_InsertedFor_h.base_position[1] =
      localB->GPSL2CStream.base_position[1];
    localB->BusConversion_InsertedFor_h.base_position[2] =
      localB->GPSL2CStream.base_position[2];

    // Outputs for Enabled SubSystem: '<S16>/GPS L5 Stream'
    // Outputs for Enabled SubSystem: '<S16>/GPS L5 Stream'
    // Constant: '<S16>/Add Trigger Here' incorporates:
    //   Constant: '<S16>/Base Position Dummy'

    DDRTCM_GPSsinglefrequencystream(localP->AddTriggerHere_Value,
      localB->sf_SimplifyandMaskGPSMeasuremen.TOW,
      localB->sf_SimplifyandMaskGPSMeasuremen.svid_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS21,
      &localB->sf_SimplifyandMaskGPSMeasuremen.navdata_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS22,
      localB->sf_SimplifyandMaskGPSMeasuremen.pr_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS23,
      localB->sf_SimplifyandMaskGPSMeasuremen.dr_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS25,
      localB->sf_SimplifyandMaskGPSMeasuremen.cn0_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS26, rtu_userPosLlh,
      localB->sf_SimplifyandMaskGPSMeasuremen.cp_sigma_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS28,
      localB->sf_SimplifyandMaskGPSMeasuremen.Locktime_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS29,
      localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_c5,
      rtu_parameters_gnss_Bus_nh,
      localB->sf_SimplifyandMaskGPSMeasuremen.pr_sigma_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS24,
      localB->sf_SimplifyandMaskGPSMeasuremen.cp_L5,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS27,
      localP->GPSL5Stream_enable_SatClockCorr, &localB->GPSL5Stream,
      &localDW->GPSL5Stream, &localP->GPSL5Stream);

    // End of Outputs for SubSystem: '<S16>/GPS L5 Stream'
    // End of Outputs for SubSystem: '<S16>/GPS L5 Stream'

    // BusCreator generated from: '<S56>/Calculate Dualfrequency Correction with L1 and L2C' 
    localDW->BusConversion_InsertedFor_Cal_k.satellite_position[0] =
      localDW->GPSL5Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0];
    localDW->BusConversion_InsertedFor_Cal_k.satellite_position[1] =
      localDW->GPSL5Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    localDW->BusConversion_InsertedFor_Cal_k.satellite_velocity[0] =
      localDW->GPSL5Stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0];
    localDW->BusConversion_InsertedFor_Cal_k.satellite_velocity[1] =
      localDW->GPSL5Stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    localDW->BusConversion_InsertedFor_Cal_k.PRN =
      localDW->GPSL5Stream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_k.pseudorange =
      localDW->GPSL5Stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.pseudorange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS23;
    localDW->BusConversion_InsertedFor_Cal_k.pseudorange_satclk_corrected =
      localDW->GPSL5Stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.deltarange =
      localDW->GPSL5Stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.deltarange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS25;
    localDW->BusConversion_InsertedFor_Cal_k.deltarange_satclk_corrected =
      localDW->GPSL5Stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.variance_pseudorange =
      localDW->GPSL5Stream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.variance_pseudorange_measured =
      localDW->GPSL5Stream.pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_k.variance_deltarange =
      localDW->GPSL5Stream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Cal_k.carrierphase =
      localDW->GPSL5Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.carrierphase_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS28;
    localDW->BusConversion_InsertedFor_Cal_k.carrierphase_satclk_corrected =
      localDW->GPSL5Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_k.variance_carrierphase_measured =
      localDW->GPSL5Stream.cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_k.locktime =
      localDW->GPSL5Stream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_k.CN0 =
      localDW->GPSL5Stream.carrierToNoiseRatio_DIMS1;

    // MATLAB Function: '<S56>/MATLAB Function' incorporates:
    //   BusCreator generated from: '<S56>/MATLAB Function'

    localB->enableDualFrequencyCorrecti = false;
    localB->enableKlobucharCorrection = false;
    if (!rtu_parameters_gnss_Bus_gs) {
      localB->b = !rtu_parameters_gnss_Bus_o;
      if (rtu_parameters_gnss_Bus_a && localB->b && rtu_parameters_gnss_Bus_gx)
      {
        localB->enableKlobucharCorrection = true;
      } else if (rtu_parameters_gnss_Bus_a && (!localB->b) &&
                 rtu_parameters_gnss_Bus_gx) {
        localB->enableDualFrequencyCorrecti = true;
      }
    }

    // End of MATLAB Function: '<S56>/MATLAB Function'

    // Outputs for Enabled SubSystem: '<S16>/GPS L1 Stream'
    // Outputs for Enabled SubSystem: '<S16>/GPS L1 Stream'
    // SignalConversion generated from: '<S23>/Enable' incorporates:
    //   Constant: '<S16>/Base Position Dummy'

    DDRTCM_GPSsinglefrequencystream(localB->parameters_gps_Bus.enable_gps_l1,
      localB->sf_SimplifyandMaskGPSMeasuremen.TOW,
      localB->sf_SimplifyandMaskGPSMeasuremen.svid_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS3,
      &localB->sf_SimplifyandMaskGPSMeasuremen.navdata_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS4,
      localB->sf_SimplifyandMaskGPSMeasuremen.pr_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS5,
      localB->sf_SimplifyandMaskGPSMeasuremen.dr_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS7,
      localB->sf_SimplifyandMaskGPSMeasuremen.cn0_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS8, rtu_userPosLlh,
      localB->sf_SimplifyandMaskGPSMeasuremen.cp_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS9,
      localB->sf_SimplifyandMaskGPSMeasuremen.Locktime_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS11,
      localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_c5,
      rtu_parameters_gnss_Bus_nh,
      localB->sf_SimplifyandMaskGPSMeasuremen.pr_sigma_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS6,
      localB->sf_SimplifyandMaskGPSMeasuremen.cp_sigma_L1,
      &localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS10,
      localP->GPSL1Stream_enable_SatClockCorr, &localB->GPSL1Stream,
      &localDW->GPSL1Stream, &localP->GPSL1Stream);

    // End of Outputs for SubSystem: '<S16>/GPS L1 Stream'
    // End of Outputs for SubSystem: '<S16>/GPS L1 Stream'

    // BusCreator generated from: '<S56>/Calculate Wide Lane Combination' incorporates:
    //   MATLAB Function: '<S56>/Calculate Wide Lane Combination'
    //   SignalConversion generated from: '<S23>/SVID'

    localDW->BusConversion_InsertedFor_Cal_n.satellite_position[0] =
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0];
    localDW->BusConversion_InsertedFor_Cal_n.satellite_position[1] =
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    localDW->BusConversion_InsertedFor_Cal_n.satellite_velocity[0] =
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0];
    localDW->BusConversion_InsertedFor_Cal_n.satellite_velocity[1] =
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    localDW->BusConversion_InsertedFor_Cal_n.PRN =
      localDW->GPSL1Stream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.pseudorange =
      localDW->GPSL1Stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.pseudorange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS5;
    localDW->BusConversion_InsertedFor_Cal_n.pseudorange_satclk_corrected =
      localDW->GPSL1Stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.deltarange =
      localDW->GPSL1Stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.deltarange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS7;
    localDW->BusConversion_InsertedFor_Cal_n.deltarange_satclk_corrected =
      localDW->GPSL1Stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.variance_pseudorange =
      localDW->GPSL1Stream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.variance_pseudorange_measured =
      localDW->GPSL1Stream.pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.variance_deltarange =
      localDW->GPSL1Stream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Cal_n.carrierphase =
      localDW->GPSL1Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.carrierphase_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS9;
    localDW->BusConversion_InsertedFor_Cal_n.carrierphase_satclk_corrected =
      localDW->GPSL1Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.variance_carrierphase_measured =
      localDW->GPSL1Stream.cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.locktime =
      localDW->GPSL1Stream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.CN0 =
      localDW->GPSL1Stream.carrierToNoiseRatio_DIMS1;
    localB->loop_ub =
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0] *
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->measurementBusL1_WL.satellite_position[0],
                  &localB->GPSL1Stream.sf_CalculateSatellitePositionan.satPosEcef
                  [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localB->loop_ub =
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0] *
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->measurementBusL1_WL.satellite_velocity[0],
                  &localB->GPSL1Stream.sf_CalculateSatellitePositionan.satVelEcef
                  [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    for (localB->i = 0; localB->i < localDW->GPSL1Stream.SVID_DIMS1; localB->i++)
    {
      localB->measurementBusL1_WL.PRN[localB->i] = localB->
        GPSL1Stream.PRN[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
         localB->i++) {
      localB->measurementBusL1_WL.pseudorange[localB->i] =
        localB->
        GPSL1Stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS5; localB->i++)
    {
      localB->measurementBusL1_WL.pseudorange_raw[localB->i] =
        localB->sf_SimplifyandMaskGPSMeasuremen.pr_L1[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
         localB->i++) {
      localB->measurementBusL1_WL.pseudorange_satclk_corrected[localB->i] =
        localB->
        GPSL1Stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->i++) {
      localB->measurementBusL1_WL.deltarange[localB->i] =
        localB->
        GPSL1Stream.sf_TimeCorrectionDeltarange.deltarangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS7; localB->i++)
    {
      localB->measurementBusL1_WL.deltarange_raw[localB->i] =
        localB->sf_SimplifyandMaskGPSMeasuremen.dr_L1[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->i++) {
      localB->measurementBusL1_WL.deltarange_satclk_corrected[localB->i] =
        localB->
        GPSL1Stream.sf_TimeCorrectionDeltarange.deltarangeCorrected[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_SignalNoiseVariance.SFunction_DIMS2; localB->i
         ++) {
      localB->measurementBusL1_WL.variance_pseudorange[localB->i] =
        localB->GPSL1Stream.sf_SignalNoiseVariance.variancePseudorange[localB->i];
    }

    for (localB->i = 0; localB->i < localDW->GPSL1Stream.pr_sigma_DIMS1;
         localB->i++) {
      localB->measurementBusL1_WL.variance_pseudorange_measured[localB->i] =
        localB->GPSL1Stream.pr_sigma[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_SignalNoiseVariance.SFunction_DIMS3; localB->i
         ++) {
      localB->measurementBusL1_WL.variance_deltarange[localB->i] =
        localB->GPSL1Stream.sf_SignalNoiseVariance.varianceDeltarange[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->i++) {
      localB->measurementBusL1_WL.carrierphase[localB->i] =
        localB->
        GPSL1Stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS9; localB->i++)
    {
      localB->measurementBusL1_WL.carrierphase_raw[localB->i] =
        localB->sf_SimplifyandMaskGPSMeasuremen.cp_L1[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->i++) {
      localB->measurementBusL1_WL.carrierphase_satclk_corrected[localB->i] =
        localB->
        GPSL1Stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->i];
    }

    for (localB->i = 0; localB->i < localDW->GPSL1Stream.cp_sigma_DIMS1;
         localB->i++) {
      localB->measurementBusL1_WL.variance_carrierphase_measured[localB->i] =
        localB->GPSL1Stream.cp_sigma[localB->i];
    }

    for (localB->i = 0; localB->i < localDW->GPSL1Stream.locktime_DIMS1;
         localB->i++) {
      localB->measurementBusL1_WL.locktime[localB->i] =
        localB->GPSL1Stream.Locktime[localB->i];
    }

    for (localB->i = 0; localB->i <
         localDW->GPSL1Stream.carrierToNoiseRatio_DIMS1; localB->i++) {
      localB->measurementBusL1_WL.CN0[localB->i] =
        localB->GPSL1Stream.carrierToNoiseRatio[localB->i];
    }

    // BusCreator generated from: '<S56>/Calculate Wide Lane Combination'
    localDW->BusConversion_InsertedFor_Cal_m.satellite_position[0] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0];
    localDW->BusConversion_InsertedFor_Cal_m.satellite_position[1] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    localDW->BusConversion_InsertedFor_Cal_m.satellite_velocity[0] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0];
    localDW->BusConversion_InsertedFor_Cal_m.satellite_velocity[1] =
      localDW->GPSL2CStream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    localDW->BusConversion_InsertedFor_Cal_m.PRN =
      localDW->GPSL2CStream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_m.pseudorange =
      localDW->GPSL2CStream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.pseudorange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS14;
    localDW->BusConversion_InsertedFor_Cal_m.pseudorange_satclk_corrected =
      localDW->GPSL2CStream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.deltarange =
      localDW->GPSL2CStream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.deltarange_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS16;
    localDW->BusConversion_InsertedFor_Cal_m.deltarange_satclk_corrected =
      localDW->GPSL2CStream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.variance_pseudorange =
      localDW->GPSL2CStream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.variance_pseudorange_measured =
      localDW->GPSL2CStream.pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_m.variance_deltarange =
      localDW->GPSL2CStream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Cal_m.carrierphase =
      localDW->GPSL2CStream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.carrierphase_raw =
      localDW->sf_SimplifyandMaskGPSMeasuremen.SFunction_DIMS18;
    localDW->BusConversion_InsertedFor_Cal_m.carrierphase_satclk_corrected =
      localDW->GPSL2CStream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_m.variance_carrierphase_measured =
      localDW->GPSL2CStream.cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_m.locktime =
      localDW->GPSL2CStream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_m.CN0 =
      localDW->GPSL2CStream.carrierToNoiseRatio_DIMS1;

    // MATLAB Function: '<S56>/Calculate Wide Lane Combination' incorporates:
    //   BusCreator generated from: '<S56>/Calculate Wide Lane Combination'
    //   SignalConversion generated from: '<S23>/SVID'
    //   SignalConversion generated from: '<S24>/SVID'

    localDW->SFunction_DIMS3 = localDW->BusConversion_InsertedFor_Cal_n;
    localB->measurementBusL1_WL.time_receive = localB->GPSL1Stream.timeOfWeekIn;
    localB->measurementBusL1_WL.base_position[0] =
      localB->GPSL1Stream.base_position[0];
    localB->measurementBusL1_WL.base_position[1] =
      localB->GPSL1Stream.base_position[1];
    localB->measurementBusL1_WL.base_position[2] =
      localB->GPSL1Stream.base_position[2];
    localDW->SFunction_DIMS2_h = localDW->BusConversion_InsertedFor_Cal_n.PRN;
    for (localB->i = 0; localB->i < localDW->GPSL1Stream.SVID_DIMS1; localB->i++)
    {
      localB->SvidCarrierInUse[localB->i] = localB->GPSL1Stream.PRN[localB->i];
    }

    if (rtu_parameters_gnss_Bus_l) {
      localB->SVID_DIMS1 = localDW->GPSL1Stream.SVID_DIMS1;
      localB->SVID_DIMS1_m = localDW->GPSL2CStream.SVID_DIMS1;
      DDRTCM_do_vectors_e(localB->GPSL1Stream.PRN, &localB->SVID_DIMS1,
                          localB->GPSL2CStream.PRN, &localB->SVID_DIMS1_m,
                          localB->a__1_data, &localB->a__1_size,
                          localB->iia_data, &localB->iia_size, localB->iib_data,
                          &localB->iib_size, localB);
      localDW->SFunction_DIMS2_h = localB->a__1_size;
      localB->loop_ub = localB->a__1_size;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->SvidCarrierInUse[0], &localB->a__1_data[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(uint16_T));
      }

      localDW->SFunction_DIMS3.carrierphase =
        localDW->BusConversion_InsertedFor_Cal_n.carrierphase;
      localB->scalarLB =
        (localDW->GPSL1Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2 / 2)
        << 1;
      localB->vectorUB = localB->scalarLB - 2;
      for (localB->i = 0; localB->i <= localB->vectorUB; localB->i += 2) {
        tmp_1 = _mm_loadu_pd
          (&localB->GPSL1Stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
           [localB->i]);
        _mm_storeu_pd(&localB->measurementBusL1_WL.carrierphase[localB->i],
                      _mm_div_pd(_mm_mul_pd(tmp_1, _mm_set1_pd
          (0.19029367279836487)), _mm_set1_pd(0.86191840032200562)));
      }

      for (localB->i = localB->scalarLB; localB->i <
           localDW->GPSL1Stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
           localB->i++) {
        localB->measurementBusL1_WL.carrierphase[localB->i] =
          localB->GPSL1Stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
          [localB->i] * 0.19029367279836487 / 0.86191840032200562;
      }

      if (localB->iia_size == localB->iib_size) {
        localB->loop_ub = localB->iia_size;
        for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
          localB->scalarLB = localB->iia_data[localB->i];
          localB->measurementBusL1_WL.carrierphase[localB->scalarLB - 1] =
            localB->GPSL1Stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
            [localB->scalarLB - 1] -
            localB->GPSL2CStream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
            [localB->iib_data[localB->i] - 1];
        }
      } else {
        DDRTCM_binary_expand_op_hp(&localB->measurementBusL1_WL,
          localB->iia_data, &localB->iia_size,
          localB->GPSL1Stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected,
          localB->GPSL2CStream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected,
          localB->iib_data, &localB->iib_size, localB);
      }
    }

    // MATLAB Function: '<S56>/Calculate Dualfrequency Correction with L1 and L2C' 
    CalculateDualfrequencyCorrectio(&localB->measurementBusL1_WL,
      &localDW->SFunction_DIMS3, &localB->BusConversion_InsertedFor_h,
      &localDW->BusConversion_InsertedFor_Calcu,
      localB->enableDualFrequencyCorrecti,
      &localB->sf_CalculateDualfrequencyCorrec,
      &localDW->sf_CalculateDualfrequencyCorrec);

    // MATLAB Function: '<S59>/Create Satellite Elevation Mask' incorporates:
    //   Constant: '<S58>/Constant'
    //   Logic: '<S28>/Logical Operator2'
    //   RelationalOperator: '<S58>/Compare'

    DD_CreateSatelliteElevationMask(rtu_userPosLlh, (rtu_userPosLlh[0] !=
      localP->CompareToConstant1_const) && (rtu_userPosLlh[1] !=
      localP->CompareToConstant1_const) && (rtu_userPosLlh[2] !=
      localP->CompareToConstant1_const),
      localB->GPSL1Stream.sf_CalculateSatellitePositionan.satPosEcef,
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2,
      rtu_parameters_gnss_Bus_m, &localB->removedSats,
      &localB->sf_CreateSatelliteElevationMask,
      &localDW->sf_CreateSatelliteElevationMask);

    // BusSelector: '<S56>/Bus Selector1'
    localB->loop_ub =
      localDW->sf_CalculateDualfrequencyCorrec.SFunction_DIMS2.pseudorange;
    localDW->BusSelector1_DIMS1 =
      localDW->sf_CalculateDualfrequencyCorrec.SFunction_DIMS2.pseudorange;

    // BusCreator generated from: '<S56>/Calculate Klobuchar Model Correction'
    localB->BusConversion_InsertedFo_cw.TOW = rtu_GpsIonBus;
    localB->BusConversion_InsertedFo_cw.WNc = rtu_GpsIonBus_f;
    localB->BusConversion_InsertedFo_cw.SVID = rtu_GpsIonBus_c;
    localB->BusConversion_InsertedFo_cw.alpha_0 = rtu_GpsIonBus_n;
    localB->BusConversion_InsertedFo_cw.alpha_1 = rtu_GpsIonBus_ce;
    localB->BusConversion_InsertedFo_cw.alpha_2 = rtu_GpsIonBus_i;
    localB->BusConversion_InsertedFo_cw.alpha_3 = rtu_GpsIonBus_b;
    localB->BusConversion_InsertedFo_cw.beta_0 = rtu_GpsIonBus_h;
    localB->BusConversion_InsertedFo_cw.beta_1 = rtu_GpsIonBus_k;
    localB->BusConversion_InsertedFo_cw.beta_2 = rtu_GpsIonBus_iu;
    localB->BusConversion_InsertedFo_cw.beta_3 = rtu_GpsIonBus_o;

    // MATLAB Function: '<S56>/Calculate Klobuchar Model Correction'
    CalculateKlobucharModelCorrecti(rtu_userPosLlh,
      localB->sf_CreateSatelliteElevationMask.elevationAngle,
      &localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS3,
      localB->sf_CreateSatelliteElevationMask.azimuthAngle,
      localDW->GPSL1Stream.sf_CalculateSatellitePositionan.SFunction_DIMS2,
      localB->GPSL1Stream.timeOfWeekIn, &localB->BusConversion_InsertedFo_cw,
      localB->enableKlobucharCorrection,
      &localB->sf_CalculateKlobucharModelCorre,
      &localDW->sf_CalculateKlobucharModelCorre);

    // BusAssignment: '<S56>/Bus Assignment2'
    localDW->BusAssignment2_DIMS1 =
      localDW->sf_CalculateDualfrequencyCorrec.SFunction_DIMS2;
    localDW->BusAssignment2_DIMS1.pseudorange = localDW->BusSelector1_DIMS1;
    localB->BusConversion_InsertedFor_h =
      localB->sf_CalculateDualfrequencyCorrec.measurementFrequencyBus;

    // BusSelector: '<S56>/Bus Selector1'
    localB->scalarLB =
      (localDW->sf_CalculateDualfrequencyCorrec.SFunction_DIMS2.pseudorange / 2)
      << 1;
    localB->vectorUB = localB->scalarLB - 2;

    // BusAssignment: '<S56>/Bus Assignment2' incorporates:
    //   BusSelector: '<S56>/Bus Selector1'
    //   Sum: '<S56>/Add1'

    for (localB->i = 0; localB->i <= localB->vectorUB; localB->i += 2) {
      __m128d tmp_0;
      tmp_1 = _mm_loadu_pd
        (&localB->sf_CalculateDualfrequencyCorrec.measurementFrequencyBus.pseudorange
         [localB->i]);
      tmp = _mm_loadu_pd
        (&localB->sf_CalculateDualfrequencyCorrec.dualFrequencyCorrection
         [localB->i]);
      tmp_0 = _mm_loadu_pd
        (&localB->sf_CalculateKlobucharModelCorre.klobucharCorrection[localB->i]);
      _mm_storeu_pd(&localB->BusConversion_InsertedFor_h.pseudorange[localB->i],
                    _mm_sub_pd(_mm_sub_pd(tmp_1, tmp), tmp_0));
    }

    for (localB->i = localB->scalarLB; localB->i < localB->loop_ub; localB->i++)
    {
      localB->BusConversion_InsertedFor_h.pseudorange[localB->i] =
        (localB->sf_CalculateDualfrequencyCorrec.measurementFrequencyBus.pseudorange
         [localB->i] -
         localB->sf_CalculateDualfrequencyCorrec.dualFrequencyCorrection
         [localB->i]) -
        localB->sf_CalculateKlobucharModelCorre.klobucharCorrection[localB->i];
    }

    // MATLAB Function: '<S28>/Calculate Tropospheric Corrections' incorporates:
    //   Logic: '<S26>/Logical Operator'
    //   Logic: '<S26>/Logical Operator2'

    CalculateTroposphericCorrection(rtu_dayOfYear, rtu_parameters_gnss_Bus_nt &&
      (!rtu_parameters_gnss_Bus_gs), rtu_userPosLlh,
      localB->sf_CreateSatelliteElevationMask.elevationAngle,
      &localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS3,
      &localB->sf_CalculateTroposphericCorrect,
      &localDW->sf_CalculateTroposphericCorrect);

    // BusSelector: '<S28>/Bus Selector2'
    localDW->BusSelector2_DIMS1 = localDW->BusAssignment2_DIMS1.pseudorange;

    // BusAssignment: '<S28>/Bus Assignment2'
    localDW->BusAssignment2_DIMS1_o = localDW->BusAssignment2_DIMS1;
    localDW->BusAssignment2_DIMS1_o.pseudorange = localDW->BusSelector2_DIMS1;

    // BusSelector: '<S28>/Bus Selector2' incorporates:
    //   BusAssignment: '<S28>/Bus Assignment2'

    localB->loop_ub = localDW->BusAssignment2_DIMS1.pseudorange - 1;
    localB->scalarLB = (localDW->BusAssignment2_DIMS1.pseudorange / 2) << 1;
    localB->vectorUB = localB->scalarLB - 2;

    // BusAssignment: '<S28>/Bus Assignment2' incorporates:
    //   BusAssignment: '<S56>/Bus Assignment2'
    //   BusSelector: '<S28>/Bus Selector2'
    //   Sum: '<S28>/Add1'

    for (localB->i = 0; localB->i <= localB->vectorUB; localB->i += 2) {
      tmp_1 = _mm_loadu_pd(&localB->
                           BusConversion_InsertedFor_h.pseudorange[localB->i]);
      tmp = _mm_loadu_pd
        (&localB->sf_CalculateTroposphericCorrect.troposphericDelay[localB->i]);
      _mm_storeu_pd(&localB->BusConversion_InsertedFor_h.pseudorange[localB->i],
                    _mm_sub_pd(tmp_1, tmp));
    }

    for (localB->i = localB->scalarLB; localB->i <= localB->loop_ub; localB->i++)
    {
      localB->BusConversion_InsertedFor_h.pseudorange[localB->i] -=
        localB->sf_CalculateTroposphericCorrect.troposphericDelay[localB->i];
    }

    // MATLAB Function: '<S60>/Apply Elevation and NaN and Zero Mask'
    ApplyElevationandNaNandZeroMask(&localB->BusConversion_InsertedFor_h,
      &localDW->BusAssignment2_DIMS1_o,
      localB->sf_CreateSatelliteElevationMask.elevationMask,
      &localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2,
      &localB->nan_errCnt, &localB->sf_ApplyElevationandNaNandZeroM,
      &localDW->sf_ApplyElevationandNaNandZeroM);

    // MATLAB Function: '<S60>/Apply Non Dual Frequency GPS Satellite Mask'
    if (localB->enableDualFrequencyCorrecti) {
      localB->SFunction_DIMS2 =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.PRN;
      localB->SFunction_DIMS4 =
        localDW->sf_CalculateDualfrequencyCorrec.SFunction_DIMS4;
      DDRTCM_do_vectors_e
        (localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.PRN,
         &localB->SFunction_DIMS2,
         localB->sf_CalculateDualfrequencyCorrec.SvidDualFrequencyCorrected,
         &localB->SFunction_DIMS4, localB->a__1_data, &localB->a__1_size,
         localB->iia_data, &localB->iia_size, localB->iib_data,
         &localB->iib_size, localB);
      localB->measurementFrequencyCorrect.time_receive =
        localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.time_receive;
      localDW->SFunction_DIMS2.satellite_position[0] = localB->iia_size;
      localDW->SFunction_DIMS2.satellite_position[1] =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.satellite_position
        [1];
      localB->unnamed_idx_0_c =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.satellite_position
        [0];
      localB->unnamed_idx_0 = localDW->SFunction_DIMS2.satellite_position[0];
      localB->loop_ub =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.satellite_position
        [1];
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->vectorUB = localB->iia_size;
        for (localB->scalarLB = 0; localB->scalarLB < localB->vectorUB;
             localB->scalarLB++) {
          localB->measurementFrequencyCorrect.satellite_position
            [localB->scalarLB + localB->unnamed_idx_0 * localB->i] =
            localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.satellite_position
            [(localB->unnamed_idx_0_c * localB->i + localB->iia_data
              [localB->scalarLB]) - 1];
        }
      }

      localDW->SFunction_DIMS2.satellite_velocity[0] = localB->iia_size;
      localDW->SFunction_DIMS2.satellite_velocity[1] =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.satellite_velocity
        [1];
      localB->unnamed_idx_0_c =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.satellite_velocity
        [0];
      localB->unnamed_idx_0 = localDW->SFunction_DIMS2.satellite_velocity[0];
      localB->loop_ub =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2.satellite_velocity
        [1];
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->vectorUB = localB->iia_size;
        for (localB->scalarLB = 0; localB->scalarLB < localB->vectorUB;
             localB->scalarLB++) {
          localB->measurementFrequencyCorrect.satellite_velocity
            [localB->scalarLB + localB->unnamed_idx_0 * localB->i] =
            localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.satellite_velocity
            [(localB->unnamed_idx_0_c * localB->i + localB->iia_data
              [localB->scalarLB]) - 1];
        }
      }

      localDW->SFunction_DIMS2.PRN = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.PRN[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.PRN
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.pseudorange = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.pseudorange[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.pseudorange
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.pseudorange_raw = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.pseudorange_raw[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.pseudorange_raw
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.pseudorange_satclk_corrected = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.pseudorange_satclk_corrected
          [localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.pseudorange
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.deltarange = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.deltarange[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.deltarange
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.deltarange_raw = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.deltarange_raw[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.deltarange_raw
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.deltarange_satclk_corrected = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.deltarange_satclk_corrected
          [localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.deltarange_satclk_corrected
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.variance_pseudorange = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.variance_pseudorange[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.variance_pseudorange
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.variance_pseudorange_measured = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.variance_pseudorange_measured
          [localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.variance_pseudorange_measured
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.variance_deltarange = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.variance_deltarange[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.variance_deltarange
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.carrierphase = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.carrierphase[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.carrierphase
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.carrierphase_raw = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.carrierphase_raw[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.carrierphase_raw
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.carrierphase_satclk_corrected = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.carrierphase_satclk_corrected
          [localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.carrierphase_satclk_corrected
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.variance_carrierphase_measured = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->
          measurementFrequencyCorrect.variance_carrierphase_measured[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.variance_carrierphase_measured
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.locktime = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.locktime[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.locktime
          [localB->iia_data[localB->i] - 1];
      }

      localDW->SFunction_DIMS2.CN0 = localB->iia_size;
      localB->loop_ub = localB->iia_size;
      for (localB->i = 0; localB->i < localB->loop_ub; localB->i++) {
        localB->measurementFrequencyCorrect.CN0[localB->i] =
          localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.CN0
          [localB->iia_data[localB->i] - 1];
      }

      localB->measurementFrequencyCorrect.base_position[0] =
        localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.base_position
        [0];
      localB->measurementFrequencyCorrect.base_position[1] =
        localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.base_position
        [1];
      localB->measurementFrequencyCorrect.base_position[2] =
        localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa.base_position
        [2];
    } else {
      localDW->SFunction_DIMS2 =
        localDW->sf_ApplyElevationandNaNandZeroM.SFunction_DIMS2;
      localB->measurementFrequencyCorrect =
        localB->sf_ApplyElevationandNaNandZeroM.measurementFrequencyCorrectedMa;
    }

    // End of MATLAB Function: '<S60>/Apply Non Dual Frequency GPS Satellite Mask' 

    // MATLAB Function: '<S60>/Apply Differential Correction Mask1' incorporates:
    //   BusSelector: '<S28>/Bus Selector3'

    ApplyDifferentialCorrectionMask(&localB->measurementFrequencyCorrect,
      &localDW->SFunction_DIMS2,
      localB->sf_CalculateDifferentialCorrect.diffPseudorangeCorrection,
      localB->sf_CalculateDifferentialCorrect.maskDiffCorr,
      &localDW->sf_CalculateDifferentialCorrect.SFunction_DIMS3,
      rtu_parameters_gnss_Bus_gs, rtu_GpsMeasurementB->base_position,
      &localB->enableDualFrequencyCorrecti,
      &localB->sf_ApplyDifferentialCorrectionM,
      &localDW->sf_ApplyDifferentialCorrectionM);

    // BusSelector: '<S16>/Bus Selector'
    localDW->BusSelector_DIMS2[0] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [0];
    localDW->BusSelector_DIMS2[1] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [1];
    localDW->BusSelector_DIMS3[0] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [0];
    localDW->BusSelector_DIMS3[1] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [1];
    localB->i = localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.PRN;
    localDW->BusSelector_DIMS4 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.PRN;
    localB->scalarLB =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange;
    localDW->BusSelector_DIMS5 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange;
    localB->vectorUB =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_raw;
    localDW->BusSelector_DIMS6 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_raw;
    localB->unnamed_idx_0_c =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_satclk_corrected;
    localDW->BusSelector_DIMS7 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_satclk_corrected;
    localB->unnamed_idx_0 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange;
    localDW->BusSelector_DIMS8 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange;
    localB->BusSelector_DIMS9_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_raw;
    localDW->BusSelector_DIMS9 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_raw;
    localB->BusSelector_DIMS10_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_satclk_corrected;
    localDW->BusSelector_DIMS10 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_satclk_corrected;
    localB->BusSelector_DIMS11_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange;
    localDW->BusSelector_DIMS11 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange;
    localB->BusSelector_DIMS12_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange_measured;
    localDW->BusSelector_DIMS12 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange_measured;
    localB->BusSelector_DIMS13_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_deltarange;
    localDW->BusSelector_DIMS13 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_deltarange;
    localB->BusSelector_DIMS14_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase;
    localDW->BusSelector_DIMS14 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase;
    localB->BusSelector_DIMS15_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_raw;
    localDW->BusSelector_DIMS15 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_raw;
    localB->BusSelector_DIMS16_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_satclk_corrected;
    localDW->BusSelector_DIMS16 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_satclk_corrected;
    localB->BusSelector_DIMS17_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_carrierphase_measured;
    localDW->BusSelector_DIMS17 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_carrierphase_measured;
    localB->BusSelector_DIMS18_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.locktime;
    localDW->BusSelector_DIMS18 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.locktime;
    localB->BusSelector_DIMS19_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.CN0;
    localDW->BusSelector_DIMS19 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.CN0;

    // BusSelector: '<S16>/Bus Selector'
    localB->time_receive =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.time_receive;

    // BusSelector: '<S16>/Bus Selector'
    localB->loop_ub =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [0] *
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->satellite_position[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.satellite_position
                  [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localB->loop_ub =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [0] *
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->satellite_velocity[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.satellite_velocity
                  [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    if (localB->i - 1 >= 0) {
      std::memcpy(&localB->PRN[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.PRN
                  [0], static_cast<uint32_T>(localB->i) * sizeof(uint16_T));
    }

    if (localB->scalarLB - 1 >= 0) {
      std::memcpy(&localB->pseudorange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.pseudorange
                  [0], static_cast<uint32_T>(localB->scalarLB) * sizeof(real_T));
    }

    if (localB->vectorUB - 1 >= 0) {
      std::memcpy(&localB->pseudorange_raw[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.pseudorange_raw
                  [0], static_cast<uint32_T>(localB->vectorUB) * sizeof(real_T));
    }

    if (localB->unnamed_idx_0_c - 1 >= 0) {
      std::memcpy(&localB->pseudorange_satclk_corrected[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.pseudorange_satclk_corrected
                  [0], static_cast<uint32_T>(localB->unnamed_idx_0_c) * sizeof
                  (real_T));
    }

    if (localB->unnamed_idx_0 - 1 >= 0) {
      std::memcpy(&localB->deltarange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.deltarange
                  [0], static_cast<uint32_T>(localB->unnamed_idx_0) * sizeof
                  (real_T));
    }

    if (localB->BusSelector_DIMS9_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->deltarange_raw[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.deltarange_raw
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS9_tmp_tmp) *
                  sizeof(real_T));
    }

    if (localB->BusSelector_DIMS10_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->deltarange_satclk_corrected[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.deltarange_satclk_corrected
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS10_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS11_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->variance_pseudorange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_pseudorange
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS11_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS12_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->variance_pseudorange_measured[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_pseudorange_measured
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS12_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS13_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->variance_deltarange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_deltarange
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS13_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS14_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->carrierphase[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.carrierphase
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS14_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS15_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->carrierphase_raw[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.carrierphase_raw
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS15_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS16_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->carrierphase_satclk_corrected[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.carrierphase_satclk_corrected
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS16_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS17_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->variance_carrierphase_measured[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_carrierphase_measured
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS17_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS18_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->locktime[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.locktime
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS18_tmp_tmp)
                  * sizeof(real32_T));
    }

    if (localB->BusSelector_DIMS19_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->CN0[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.CN0
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS19_tmp_tmp)
                  * sizeof(real_T));
    }

    // BusSelector: '<S16>/Bus Selector'
    localB->base_position[0] =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.base_position
      [0];
    localB->base_position[1] =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.base_position
      [1];
    localB->base_position[2] =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.base_position
      [2];
  }

  // End of Outputs for SubSystem: '<S4>/GPS'
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
void DDRTCM::DDRTCM_do_vectors_k(const uint16_T a_data[], const int32_T *a_size,
  const uint16_T b_data[], const int32_T *b_size, uint16_T c_data[], int32_T
  *c_size, int32_T ia_data[], int32_T *ia_size, int32_T ib_data[], int32_T
  *ib_size, B_Galileo_DDRTCM_T *localB)
{
  if (*a_size <= *b_size) {
    localB->ncmax = *a_size;
  } else {
    localB->ncmax = *b_size;
  }

  *c_size = localB->ncmax;
  *ia_size = localB->ncmax;
  *ib_size = localB->ncmax;
  localB->nc = 0;
  localB->iafirst = 0;
  localB->ialast = 1;
  localB->ibfirst = 0;
  localB->iblast = 1;
  while ((localB->ialast <= *a_size) && (localB->iblast <= *b_size)) {
    localB->b_ialast = localB->ialast;
    localB->ak = a_data[localB->ialast - 1];
    while ((localB->b_ialast < *a_size) && (a_data[localB->b_ialast] ==
            localB->ak)) {
      localB->b_ialast++;
    }

    localB->ialast = localB->b_ialast;
    localB->b_iblast = localB->iblast;
    localB->bk = b_data[localB->iblast - 1];
    while ((localB->b_iblast < *b_size) && (b_data[localB->b_iblast] ==
            localB->bk)) {
      localB->b_iblast++;
    }

    localB->iblast = localB->b_iblast;
    if (localB->ak == localB->bk) {
      localB->nc++;
      c_data[localB->nc - 1] = localB->ak;
      ia_data[localB->nc - 1] = localB->iafirst + 1;
      ib_data[localB->nc - 1] = localB->ibfirst + 1;
      localB->ialast = localB->b_ialast + 1;
      localB->iafirst = localB->b_ialast;
      localB->iblast = localB->b_iblast + 1;
      localB->ibfirst = localB->b_iblast;
    } else if (localB->ak < localB->bk) {
      localB->ialast = localB->b_ialast + 1;
      localB->iafirst = localB->b_ialast;
    } else {
      localB->iblast = localB->b_iblast + 1;
      localB->ibfirst = localB->b_iblast;
    }
  }

  if (localB->ncmax > 0) {
    if (localB->nc < 1) {
      *ia_size = 0;
      *ib_size = 0;
      *c_size = 0;
    } else {
      *ia_size = localB->nc;
      *ib_size = localB->nc;
      *c_size = localB->nc;
    }
  }
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
boolean_T DDRTCM::DDRTCM_any_d(const real_T x_data[], const int32_T *x_size,
  B_Galileo_DDRTCM_T *localB)
{
  boolean_T exitg1;
  boolean_T y;
  y = false;
  localB->ix = 1;
  exitg1 = false;
  while ((!exitg1) && (localB->ix <= *x_size)) {
    if (!(x_data[localB->ix - 1] == 0.0)) {
      y = true;
      exitg1 = true;
    } else {
      localB->ix++;
    }
  }

  return y;
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
void DDRTCM::DDRTCM_calcCorrection_czr(const real_T prf1_data[], const uint16_T
  PRN1_data[], const int32_T *PRN1_size, const real_T prf2_data[], const
  uint16_T PRN2_data[], const int32_T *PRN2_size, real_T Corr_f1_data[], int32_T
  *Corr_f1_size, B_Galileo_DDRTCM_T *localB)
{
  std::memset(&localB->fixed_f1_b[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_f2_p[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_PRN_o[0], 0, 150U * sizeof(uint16_T));
  *Corr_f1_size = static_cast<int8_T>(*PRN1_size);
  localB->loop_ub_e = static_cast<int8_T>(*PRN1_size);
  if (localB->loop_ub_e - 1 >= 0) {
    std::memset(&Corr_f1_data[0], 0, static_cast<uint32_T>(localB->loop_ub_e) *
                sizeof(real_T));
  }

  localB->loop_ub_e = *PRN1_size;
  if (localB->loop_ub_e - 1 >= 0) {
    std::memset(&localB->idx2_data_h2[0], 0, static_cast<uint32_T>
                (localB->loop_ub_e) * sizeof(int8_T));
  }

  localB->loop_ub_e = *PRN1_size;
  if (localB->loop_ub_e - 1 >= 0) {
    std::memset(&localB->idx1_data_m[0], 0, static_cast<uint32_T>
                (localB->loop_ub_e) * sizeof(int8_T));
  }

  localB->c_i = *PRN1_size;
  for (localB->i_j = 0; localB->i_j < localB->c_i; localB->i_j++) {
    localB->loop_ub_e = *PRN2_size;
    for (localB->j_m = 0; localB->j_m < localB->loop_ub_e; localB->j_m++) {
      if (PRN1_data[localB->i_j] == PRN2_data[localB->j_m]) {
        localB->idx1_data_m[localB->i_j] = static_cast<int8_T>(localB->i_j + 1);
        localB->idx2_data_h2[localB->i_j] = static_cast<int8_T>(localB->j_m + 1);
      }
    }
  }

  localB->i_j = *PRN1_size;
  for (localB->c_i = 0; localB->c_i < localB->i_j; localB->c_i++) {
    localB->PRN1_g = PRN1_data[localB->c_i];
    localB->idx2_m = localB->idx2_data_h2[localB->c_i];
    localB->idx1_k = localB->idx1_data_m[localB->c_i];
    if ((localB->idx1_k != 0) && (localB->idx2_m != 0)) {
      localB->d6 = prf1_data[localB->idx1_k - 1];
      if (localB->d6 != 0.0) {
        localB->d7 = prf2_data[localB->idx2_m - 1];
        if (localB->d7 != 0.0) {
          localB->fixed_PRN_o[localB->PRN1_g - 1] = localB->PRN1_g;
          localB->fixed_f1_b[localB->PRN1_g - 1] = localB->d6;
          localB->fixed_f2_p[localB->PRN1_g - 1] = localB->d7;
        }
      }
    }
  }

  for (localB->j_m = 0; localB->j_m <= 148; localB->j_m += 2) {
    __m128d tmp;
    __m128d tmp_0;
    tmp = _mm_loadu_pd(&localB->fixed_f2_p[localB->j_m]);
    tmp_0 = _mm_loadu_pd(&localB->fixed_f1_b[localB->j_m]);
    _mm_storeu_pd(&localB->fixed_f2_p[localB->j_m], _mm_div_pd(_mm_mul_pd
      (_mm_mul_pd(_mm_sub_pd(tmp, tmp_0), _mm_set1_pd(-1.7686752926678988)),
       _mm_set1_pd(1.57542E+9)), _mm_set1_pd(1.191795E+9)));
  }

  localB->i_j = *PRN1_size;
  for (localB->c_i = 0; localB->c_i < localB->i_j; localB->c_i++) {
    localB->PRN1_g = PRN1_data[localB->c_i];
    localB->loop_ub_e = 0;
    for (localB->j_m = 0; localB->j_m < 150; localB->j_m++) {
      if (localB->fixed_PRN_o[localB->j_m] != 0) {
        localB->loop_ub_e++;
      }
    }

    localB->h_size_idx_0_m = localB->loop_ub_e;
    localB->loop_ub_e = 0;
    for (localB->j_m = 0; localB->j_m < 150; localB->j_m++) {
      if (localB->fixed_PRN_o[localB->j_m] != 0) {
        localB->h_data_p[localB->loop_ub_e] = static_cast<uint8_T>(localB->j_m +
          1);
        localB->loop_ub_e++;
      }
    }

    for (localB->j_m = 0; localB->j_m < localB->h_size_idx_0_m; localB->j_m++) {
      localB->g_data_ct[localB->j_m] = (localB->fixed_PRN_o[localB->
        h_data_p[localB->j_m] - 1] == localB->PRN1_g);
    }

    localB->loop_ub_e = 0;
    for (localB->j_m = 0; localB->j_m < 150; localB->j_m++) {
      if (localB->fixed_PRN_o[localB->j_m] != 0) {
        localB->k_data_p[localB->loop_ub_e] = static_cast<uint8_T>(localB->j_m +
          1);
        localB->loop_ub_e++;
      }
    }

    localB->loop_ub_e = localB->h_size_idx_0_m - 1;
    localB->j_m = 0;
    for (localB->h_size_idx_0_m = 0; localB->h_size_idx_0_m <= localB->loop_ub_e;
         localB->h_size_idx_0_m++) {
      if (localB->g_data_ct[localB->h_size_idx_0_m]) {
        localB->j_m++;
      }
    }

    localB->l_size_idx_0_j = localB->j_m;
    localB->j_m = 0;
    for (localB->h_size_idx_0_m = 0; localB->h_size_idx_0_m <= localB->loop_ub_e;
         localB->h_size_idx_0_m++) {
      if (localB->g_data_ct[localB->h_size_idx_0_m]) {
        localB->l_data_p[localB->j_m] = localB->h_size_idx_0_m + 1;
        localB->j_m++;
      }
    }

    localB->fixed_PRN_size_m = localB->l_size_idx_0_j;
    for (localB->j_m = 0; localB->j_m < localB->l_size_idx_0_j; localB->j_m++) {
      localB->fixed_f1_b[localB->j_m] = localB->fixed_PRN_o[localB->
        k_data_p[localB->l_data_p[localB->j_m] - 1] - 1];
    }

    if (DDRTCM_any_d(localB->fixed_f1_b, &localB->fixed_PRN_size_m, localB)) {
      Corr_f1_data[localB->c_i] = localB->fixed_f2_p[localB->PRN1_g - 1];
    }
  }
}

// Function for MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask'
void DDRTCM::DDRTCM_any_jr(const boolean_T x_data[], const int32_T x_size[2],
  boolean_T y_data[], int32_T *y_size)
{
  int32_T c;
  int32_T i1;
  int32_T i2;
  int32_T vstride;
  *y_size = static_cast<int8_T>(x_size[0]);
  vstride = static_cast<int8_T>(x_size[0]);
  if (vstride - 1 >= 0) {
    std::memset(&y_data[0], 0, static_cast<uint32_T>(vstride) * sizeof(boolean_T));
  }

  vstride = x_size[0];
  i2 = (x_size[1] - 1) * x_size[0];
  i1 = 0;
  c = x_size[0];
  for (int32_T j{0}; j < c; j++) {
    int32_T ix;
    boolean_T exitg1;
    i1++;
    i2++;
    ix = i1;
    exitg1 = false;
    while ((!exitg1) && ((vstride > 0) && (ix <= i2))) {
      if (x_data[ix - 1]) {
        y_data[j] = true;
        exitg1 = true;
      } else {
        ix += vstride;
      }
    }
  }
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
void DDRTCM::DDRTCM_calcCorrection(const real_T prf1_data[], const uint16_T
  PRN1_data[], const int32_T *PRN1_size, const real_T prf2_data[], const
  uint16_T PRN2_data[], const int32_T *PRN2_size, real_T Corr_f1_data[], int32_T
  *Corr_f1_size, B_Galileo_DDRTCM_T *localB)
{
  std::memset(&localB->fixed_f1_k[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_f2_cx[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_PRN_i[0], 0, 150U * sizeof(uint16_T));
  *Corr_f1_size = static_cast<int8_T>(*PRN1_size);
  localB->loop_ub_p = static_cast<int8_T>(*PRN1_size);
  if (localB->loop_ub_p - 1 >= 0) {
    std::memset(&Corr_f1_data[0], 0, static_cast<uint32_T>(localB->loop_ub_p) *
                sizeof(real_T));
  }

  localB->loop_ub_p = *PRN1_size;
  if (localB->loop_ub_p - 1 >= 0) {
    std::memset(&localB->idx2_data_h[0], 0, static_cast<uint32_T>
                (localB->loop_ub_p) * sizeof(int8_T));
  }

  localB->loop_ub_p = *PRN1_size;
  if (localB->loop_ub_p - 1 >= 0) {
    std::memset(&localB->idx1_data_l[0], 0, static_cast<uint32_T>
                (localB->loop_ub_p) * sizeof(int8_T));
  }

  localB->c_m = *PRN1_size;
  for (localB->i_k = 0; localB->i_k < localB->c_m; localB->i_k++) {
    localB->loop_ub_p = *PRN2_size;
    for (localB->j_a = 0; localB->j_a < localB->loop_ub_p; localB->j_a++) {
      if (PRN1_data[localB->i_k] == PRN2_data[localB->j_a]) {
        localB->idx1_data_l[localB->i_k] = static_cast<int8_T>(localB->i_k + 1);
        localB->idx2_data_h[localB->i_k] = static_cast<int8_T>(localB->j_a + 1);
      }
    }
  }

  localB->i_k = *PRN1_size;
  for (localB->c_m = 0; localB->c_m < localB->i_k; localB->c_m++) {
    localB->PRN1_o = PRN1_data[localB->c_m];
    localB->idx2_j = localB->idx2_data_h[localB->c_m];
    localB->idx1_m = localB->idx1_data_l[localB->c_m];
    if ((localB->idx1_m != 0) && (localB->idx2_j != 0)) {
      localB->d4 = prf1_data[localB->idx1_m - 1];
      if (localB->d4 != 0.0) {
        localB->d5 = prf2_data[localB->idx2_j - 1];
        if (localB->d5 != 0.0) {
          localB->fixed_PRN_i[localB->PRN1_o - 1] = localB->PRN1_o;
          localB->fixed_f1_k[localB->PRN1_o - 1] = localB->d4;
          localB->fixed_f2_cx[localB->PRN1_o - 1] = localB->d5;
        }
      }
    }
  }

  for (localB->j_a = 0; localB->j_a <= 148; localB->j_a += 2) {
    __m128d tmp;
    __m128d tmp_0;
    tmp = _mm_loadu_pd(&localB->fixed_f2_cx[localB->j_a]);
    tmp_0 = _mm_loadu_pd(&localB->fixed_f1_k[localB->j_a]);
    _mm_storeu_pd(&localB->fixed_f2_cx[localB->j_a], _mm_div_pd(_mm_mul_pd
      (_mm_mul_pd(_mm_sub_pd(tmp, tmp_0), _mm_set1_pd(1.688113621199123)),
       _mm_set1_pd(1.17645E+9)), _mm_set1_pd(1.57542E+9)));
  }

  localB->i_k = *PRN1_size;
  for (localB->c_m = 0; localB->c_m < localB->i_k; localB->c_m++) {
    localB->PRN1_o = PRN1_data[localB->c_m];
    localB->loop_ub_p = 0;
    for (localB->j_a = 0; localB->j_a < 150; localB->j_a++) {
      if (localB->fixed_PRN_i[localB->j_a] != 0) {
        localB->loop_ub_p++;
      }
    }

    localB->h_size_idx_0_c = localB->loop_ub_p;
    localB->loop_ub_p = 0;
    for (localB->j_a = 0; localB->j_a < 150; localB->j_a++) {
      if (localB->fixed_PRN_i[localB->j_a] != 0) {
        localB->h_data_h[localB->loop_ub_p] = static_cast<uint8_T>(localB->j_a +
          1);
        localB->loop_ub_p++;
      }
    }

    for (localB->j_a = 0; localB->j_a < localB->h_size_idx_0_c; localB->j_a++) {
      localB->g_data_j[localB->j_a] = (localB->fixed_PRN_i[localB->
        h_data_h[localB->j_a] - 1] == localB->PRN1_o);
    }

    localB->loop_ub_p = 0;
    for (localB->j_a = 0; localB->j_a < 150; localB->j_a++) {
      if (localB->fixed_PRN_i[localB->j_a] != 0) {
        localB->k_data_c[localB->loop_ub_p] = static_cast<uint8_T>(localB->j_a +
          1);
        localB->loop_ub_p++;
      }
    }

    localB->loop_ub_p = localB->h_size_idx_0_c - 1;
    localB->j_a = 0;
    for (localB->h_size_idx_0_c = 0; localB->h_size_idx_0_c <= localB->loop_ub_p;
         localB->h_size_idx_0_c++) {
      if (localB->g_data_j[localB->h_size_idx_0_c]) {
        localB->j_a++;
      }
    }

    localB->l_size_idx_0_n = localB->j_a;
    localB->j_a = 0;
    for (localB->h_size_idx_0_c = 0; localB->h_size_idx_0_c <= localB->loop_ub_p;
         localB->h_size_idx_0_c++) {
      if (localB->g_data_j[localB->h_size_idx_0_c]) {
        localB->l_data_n[localB->j_a] = localB->h_size_idx_0_c + 1;
        localB->j_a++;
      }
    }

    localB->fixed_PRN_size_b = localB->l_size_idx_0_n;
    for (localB->j_a = 0; localB->j_a < localB->l_size_idx_0_n; localB->j_a++) {
      localB->fixed_f1_k[localB->j_a] = localB->fixed_PRN_i[localB->
        k_data_c[localB->l_data_n[localB->j_a] - 1] - 1];
    }

    if (DDRTCM_any_d(localB->fixed_f1_k, &localB->fixed_PRN_size_b, localB)) {
      Corr_f1_data[localB->c_m] = localB->fixed_f2_cx[localB->PRN1_o - 1];
    }
  }
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
boolean_T DDRTCM::DDRTCM_any_dd(const boolean_T x_data[], const int32_T *x_size)
{
  int32_T ix;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  ix = 1;
  exitg1 = false;
  while ((!exitg1) && (ix <= *x_size)) {
    if (x_data[ix - 1]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
void DDRTCM::DDRTCM_calcCorrection_c(const real_T prf1_data[], const uint16_T
  PRN1_data[], const int32_T *PRN1_size, const real_T prf2_data[], const
  uint16_T PRN2_data[], const int32_T *PRN2_size, real_T Corr_f1_data[], int32_T
  *Corr_f1_size, B_Galileo_DDRTCM_T *localB)
{
  std::memset(&localB->fixed_f1_m[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_f2_c[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_PRN_n[0], 0, 150U * sizeof(uint16_T));
  *Corr_f1_size = static_cast<int8_T>(*PRN1_size);
  localB->loop_ub_m = static_cast<int8_T>(*PRN1_size);
  if (localB->loop_ub_m - 1 >= 0) {
    std::memset(&Corr_f1_data[0], 0, static_cast<uint32_T>(localB->loop_ub_m) *
                sizeof(real_T));
  }

  localB->loop_ub_m = *PRN1_size;
  if (localB->loop_ub_m - 1 >= 0) {
    std::memset(&localB->idx2_data_e[0], 0, static_cast<uint32_T>
                (localB->loop_ub_m) * sizeof(int8_T));
  }

  localB->loop_ub_m = *PRN1_size;
  if (localB->loop_ub_m - 1 >= 0) {
    std::memset(&localB->idx1_data_o[0], 0, static_cast<uint32_T>
                (localB->loop_ub_m) * sizeof(int8_T));
  }

  localB->c_k = *PRN1_size;
  for (localB->i_o = 0; localB->i_o < localB->c_k; localB->i_o++) {
    localB->loop_ub_m = *PRN2_size;
    for (localB->j_i = 0; localB->j_i < localB->loop_ub_m; localB->j_i++) {
      if (PRN1_data[localB->i_o] == PRN2_data[localB->j_i]) {
        localB->idx1_data_o[localB->i_o] = static_cast<int8_T>(localB->i_o + 1);
        localB->idx2_data_e[localB->i_o] = static_cast<int8_T>(localB->j_i + 1);
      }
    }
  }

  localB->i_o = *PRN1_size;
  for (localB->c_k = 0; localB->c_k < localB->i_o; localB->c_k++) {
    localB->PRN1_n = PRN1_data[localB->c_k];
    localB->idx2_c = localB->idx2_data_e[localB->c_k];
    localB->idx1_c = localB->idx1_data_o[localB->c_k];
    if ((localB->idx1_c != 0) && (localB->idx2_c != 0)) {
      localB->d2 = prf1_data[localB->idx1_c - 1];
      if (localB->d2 != 0.0) {
        localB->d3 = prf2_data[localB->idx2_c - 1];
        if (localB->d3 != 0.0) {
          localB->fixed_PRN_n[localB->PRN1_n - 1] = localB->PRN1_n;
          localB->fixed_f1_m[localB->PRN1_n - 1] = localB->d2;
          localB->fixed_f2_c[localB->PRN1_n - 1] = localB->d3;
        }
      }
    }
  }

  for (localB->j_i = 0; localB->j_i <= 148; localB->j_i += 2) {
    __m128d tmp;
    __m128d tmp_0;
    tmp = _mm_loadu_pd(&localB->fixed_f2_c[localB->j_i]);
    tmp_0 = _mm_loadu_pd(&localB->fixed_f1_m[localB->j_i]);
    _mm_storeu_pd(&localB->fixed_f2_c[localB->j_i], _mm_div_pd(_mm_mul_pd
      (_mm_mul_pd(_mm_sub_pd(tmp, tmp_0), _mm_set1_pd(1.8558006535947713)),
       _mm_set1_pd(1.20714E+9)), _mm_set1_pd(1.57542E+9)));
  }

  localB->i_o = *PRN1_size;
  for (localB->c_k = 0; localB->c_k < localB->i_o; localB->c_k++) {
    localB->PRN1_n = PRN1_data[localB->c_k];
    localB->loop_ub_m = 0;
    for (localB->j_i = 0; localB->j_i < 150; localB->j_i++) {
      if (localB->fixed_PRN_n[localB->j_i] != 0) {
        localB->loop_ub_m++;
      }
    }

    localB->h_size_idx_0_f = localB->loop_ub_m;
    localB->loop_ub_m = 0;
    for (localB->j_i = 0; localB->j_i < 150; localB->j_i++) {
      if (localB->fixed_PRN_n[localB->j_i] != 0) {
        localB->h_data_m[localB->loop_ub_m] = static_cast<uint8_T>(localB->j_i +
          1);
        localB->loop_ub_m++;
      }
    }

    for (localB->j_i = 0; localB->j_i < localB->h_size_idx_0_f; localB->j_i++) {
      localB->g_data_c[localB->j_i] = (localB->fixed_PRN_n[localB->
        h_data_m[localB->j_i] - 1] == localB->PRN1_n);
    }

    localB->loop_ub_m = 0;
    for (localB->j_i = 0; localB->j_i < 150; localB->j_i++) {
      if (localB->fixed_PRN_n[localB->j_i] != 0) {
        localB->k_data_m[localB->loop_ub_m] = static_cast<uint8_T>(localB->j_i +
          1);
        localB->loop_ub_m++;
      }
    }

    localB->loop_ub_m = localB->h_size_idx_0_f - 1;
    localB->j_i = 0;
    for (localB->h_size_idx_0_f = 0; localB->h_size_idx_0_f <= localB->loop_ub_m;
         localB->h_size_idx_0_f++) {
      if (localB->g_data_c[localB->h_size_idx_0_f]) {
        localB->j_i++;
      }
    }

    localB->l_size_idx_0_h = localB->j_i;
    localB->j_i = 0;
    for (localB->h_size_idx_0_f = 0; localB->h_size_idx_0_f <= localB->loop_ub_m;
         localB->h_size_idx_0_f++) {
      if (localB->g_data_c[localB->h_size_idx_0_f]) {
        localB->l_data_m[localB->j_i] = localB->h_size_idx_0_f + 1;
        localB->j_i++;
      }
    }

    localB->fixed_PRN_size_c = localB->l_size_idx_0_h;
    for (localB->j_i = 0; localB->j_i < localB->l_size_idx_0_h; localB->j_i++) {
      localB->fixed_f1_m[localB->j_i] = localB->fixed_PRN_n[localB->
        k_data_m[localB->l_data_m[localB->j_i] - 1] - 1];
    }

    if (DDRTCM_any_d(localB->fixed_f1_m, &localB->fixed_PRN_size_c, localB)) {
      Corr_f1_data[localB->c_k] = localB->fixed_f2_c[localB->PRN1_n - 1];
    }
  }
}

// Function for MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
void DDRTCM::DDRTCM_calcCorrection_cz(const real_T prf1_data[], const uint16_T
  PRN1_data[], const int32_T *PRN1_size, const real_T prf2_data[], const
  uint16_T PRN2_data[], const int32_T *PRN2_size, real_T Corr_f1_data[], int32_T
  *Corr_f1_size, B_Galileo_DDRTCM_T *localB)
{
  std::memset(&localB->fixed_f1[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_f2[0], 0, 150U * sizeof(real_T));
  std::memset(&localB->fixed_PRN[0], 0, 150U * sizeof(uint16_T));
  *Corr_f1_size = static_cast<int8_T>(*PRN1_size);
  localB->loop_ub = static_cast<int8_T>(*PRN1_size);
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&Corr_f1_data[0], 0, static_cast<uint32_T>(localB->loop_ub) *
                sizeof(real_T));
  }

  localB->loop_ub = *PRN1_size;
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&localB->idx2_data[0], 0, static_cast<uint32_T>(localB->loop_ub)
                * sizeof(int8_T));
  }

  localB->loop_ub = *PRN1_size;
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&localB->idx1_data[0], 0, static_cast<uint32_T>(localB->loop_ub)
                * sizeof(int8_T));
  }

  localB->c = *PRN1_size;
  for (localB->i_i = 0; localB->i_i < localB->c; localB->i_i++) {
    localB->loop_ub = *PRN2_size;
    for (localB->j = 0; localB->j < localB->loop_ub; localB->j++) {
      if (PRN1_data[localB->i_i] == PRN2_data[localB->j]) {
        localB->idx1_data[localB->i_i] = static_cast<int8_T>(localB->i_i + 1);
        localB->idx2_data[localB->i_i] = static_cast<int8_T>(localB->j + 1);
      }
    }
  }

  localB->i_i = *PRN1_size;
  for (localB->c = 0; localB->c < localB->i_i; localB->c++) {
    localB->PRN1 = PRN1_data[localB->c];
    localB->idx2 = localB->idx2_data[localB->c];
    localB->idx1 = localB->idx1_data[localB->c];
    if ((localB->idx1 != 0) && (localB->idx2 != 0)) {
      localB->d = prf1_data[localB->idx1 - 1];
      if (localB->d != 0.0) {
        localB->d1 = prf2_data[localB->idx2 - 1];
        if (localB->d1 != 0.0) {
          localB->fixed_PRN[localB->PRN1 - 1] = localB->PRN1;
          localB->fixed_f1[localB->PRN1 - 1] = localB->d;
          localB->fixed_f2[localB->PRN1 - 1] = localB->d1;
        }
      }
    }
  }

  for (localB->j = 0; localB->j <= 148; localB->j += 2) {
    __m128d tmp;
    __m128d tmp_0;
    tmp = _mm_loadu_pd(&localB->fixed_f2[localB->j]);
    tmp_0 = _mm_loadu_pd(&localB->fixed_f1[localB->j]);
    _mm_storeu_pd(&localB->fixed_f2[localB->j], _mm_div_pd(_mm_mul_pd(_mm_mul_pd
      (_mm_sub_pd(tmp, tmp_0), _mm_set1_pd(1.7686752926678988)), _mm_set1_pd
      (1.191795E+9)), _mm_set1_pd(1.57542E+9)));
  }

  localB->i_i = *PRN1_size;
  for (localB->c = 0; localB->c < localB->i_i; localB->c++) {
    localB->PRN1 = PRN1_data[localB->c];
    localB->loop_ub = 0;
    for (localB->j = 0; localB->j < 150; localB->j++) {
      if (localB->fixed_PRN[localB->j] != 0) {
        localB->loop_ub++;
      }
    }

    localB->h_size_idx_0 = localB->loop_ub;
    localB->loop_ub = 0;
    for (localB->j = 0; localB->j < 150; localB->j++) {
      if (localB->fixed_PRN[localB->j] != 0) {
        localB->h_data[localB->loop_ub] = static_cast<uint8_T>(localB->j + 1);
        localB->loop_ub++;
      }
    }

    for (localB->j = 0; localB->j < localB->h_size_idx_0; localB->j++) {
      localB->g_data[localB->j] = (localB->fixed_PRN[localB->h_data[localB->j] -
        1] == localB->PRN1);
    }

    localB->loop_ub = 0;
    for (localB->j = 0; localB->j < 150; localB->j++) {
      if (localB->fixed_PRN[localB->j] != 0) {
        localB->k_data[localB->loop_ub] = static_cast<uint8_T>(localB->j + 1);
        localB->loop_ub++;
      }
    }

    localB->loop_ub = localB->h_size_idx_0 - 1;
    localB->j = 0;
    for (localB->h_size_idx_0 = 0; localB->h_size_idx_0 <= localB->loop_ub;
         localB->h_size_idx_0++) {
      if (localB->g_data[localB->h_size_idx_0]) {
        localB->j++;
      }
    }

    localB->l_size_idx_0_o = localB->j;
    localB->j = 0;
    for (localB->h_size_idx_0 = 0; localB->h_size_idx_0 <= localB->loop_ub;
         localB->h_size_idx_0++) {
      if (localB->g_data[localB->h_size_idx_0]) {
        localB->l_data[localB->j] = localB->h_size_idx_0 + 1;
        localB->j++;
      }
    }

    localB->fixed_PRN_size = localB->l_size_idx_0_o;
    for (localB->j = 0; localB->j < localB->l_size_idx_0_o; localB->j++) {
      localB->fixed_f1[localB->j] = localB->fixed_PRN[localB->k_data
        [localB->l_data[localB->j] - 1] - 1];
    }

    if (DDRTCM_any_d(localB->fixed_f1, &localB->fixed_PRN_size, localB)) {
      Corr_f1_data[localB->c] = localB->fixed_f2[localB->PRN1 - 1];
    }
  }
}

// Function for MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask'
void DDRTCM::DDRTCM_any_jr1(const boolean_T x_data[], const int32_T *x_size,
  boolean_T y_data[], int32_T *y_size, B_Galileo_DDRTCM_T *localB)
{
  *y_size = static_cast<int8_T>(*x_size);
  localB->vstride = static_cast<int8_T>(*x_size);
  if (localB->vstride - 1 >= 0) {
    std::memset(&y_data[0], 0, static_cast<uint32_T>(localB->vstride) * sizeof
                (boolean_T));
  }

  localB->vstride = *x_size;
  localB->i1 = 0;
  localB->i2 = 0;
  localB->c_p = *x_size;
  for (localB->j_n = 0; localB->j_n < localB->c_p; localB->j_n++) {
    boolean_T exitg1;
    localB->i1++;
    localB->i2++;
    localB->ix_k = localB->i1;
    exitg1 = false;
    while ((!exitg1) && ((localB->vstride > 0) && (localB->ix_k <= localB->i2)))
    {
      if (x_data[localB->ix_k - 1]) {
        y_data[localB->j_n] = true;
        exitg1 = true;
      } else {
        localB->ix_k += localB->vstride;
      }
    }
  }
}

void DDRTCM::DDRTCM_binary_expand_op_nb(boolean_T in1_data[], int32_T *in1_size,
  const boolean_T in2[40], int32_T in3, const real_T in4[120], const
  GNSS_Measurement_size *in5, const real_T in6[120], const real_T in7[40],
  int32_T in8, B_Galileo_DDRTCM_T *localB)
{
  // Outputs for Enabled SubSystem: '<S4>/Galileo' incorporates:
  //   EnablePort: '<S17>/Enable'

  // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
  //   BusAssignment: '<S112>/Bus Assignment2'
  //   BusAssignment: '<S75>/Bus Assignment1'
  //   Sum: '<S75>/Add1'

  localB->in4_size[0] = in5->satellite_position[0];
  localB->in4_size[1] = in5->satellite_position[1];
  localB->loop_ub_tmp = in5->satellite_position[0] * in5->satellite_position[1];
  for (localB->i_f = 0; localB->i_f < localB->loop_ub_tmp; localB->i_f++) {
    localB->in4_data[localB->i_f] = std::isnan(in4[localB->i_f]);
  }

  DDRTCM_any_jr(localB->in4_data, localB->in4_size, localB->tmp_data_p4,
                &localB->tmp_size_n);
  localB->in4_size[0] = in5->satellite_velocity[0];
  localB->in4_size[1] = in5->satellite_velocity[1];
  localB->loop_ub_tmp_g = in5->satellite_velocity[0] * in5->satellite_velocity[1];
  for (localB->i_f = 0; localB->i_f < localB->loop_ub_tmp_g; localB->i_f++) {
    localB->in4_data[localB->i_f] = std::isnan(in6[localB->i_f]);
  }

  DDRTCM_any_jr(localB->in4_data, localB->in4_size, localB->tmp_data_ap,
                &localB->tmp_size_d);
  localB->tmp_size_na = in8;
  for (localB->i_f = 0; localB->i_f < in8; localB->i_f++) {
    localB->tmp_data_j[localB->i_f] = std::isnan(in7[localB->i_f]);
  }

  DDRTCM_any_jr1(localB->tmp_data_j, &localB->tmp_size_na, localB->tmp_data_ek,
                 &localB->tmp_size_cg, localB);
  localB->in4_size[0] = in5->satellite_position[0];
  localB->in4_size[1] = in5->satellite_position[1];
  for (localB->i_f = 0; localB->i_f < localB->loop_ub_tmp; localB->i_f++) {
    localB->in4_data[localB->i_f] = (in4[localB->i_f] == 0.0);
  }

  DDRTCM_any_jr(localB->in4_data, localB->in4_size, localB->tmp_data_j,
                &localB->tmp_size_na);
  localB->in4_size[0] = in5->satellite_velocity[0];
  localB->in4_size[1] = in5->satellite_velocity[1];
  for (localB->i_f = 0; localB->i_f < localB->loop_ub_tmp_g; localB->i_f++) {
    localB->in4_data[localB->i_f] = (in6[localB->i_f] == 0.0);
  }

  DDRTCM_any_jr(localB->in4_data, localB->in4_size, localB->tmp_data_ol,
                &localB->tmp_size_f);
  localB->in7_size = in8;
  for (localB->i_f = 0; localB->i_f < in8; localB->i_f++) {
    localB->in7_data[localB->i_f] = (in7[localB->i_f] < 1.0E+6);
  }

  DDRTCM_any_jr1(localB->in7_data, &localB->in7_size, localB->tmp_data_b,
                 &localB->tmp_size_pm, localB);
  *in1_size = (localB->tmp_size_pm == 1 ? localB->tmp_size_f == 1 ?
               localB->tmp_size_na : localB->tmp_size_f : localB->tmp_size_pm) ==
    1 ? (localB->tmp_size_cg == 1 ? localB->tmp_size_d == 1 ? localB->tmp_size_n
         : localB->tmp_size_d : localB->tmp_size_cg) == 1 ? in3 :
    localB->tmp_size_cg == 1 ? localB->tmp_size_d == 1 ? localB->tmp_size_n :
    localB->tmp_size_d : localB->tmp_size_cg : localB->tmp_size_pm == 1 ?
    localB->tmp_size_f == 1 ? localB->tmp_size_na : localB->tmp_size_f :
    localB->tmp_size_pm;
  localB->in5_idx_0 = (in3 != 1);
  localB->in5_idx_1 = (localB->tmp_size_n != 1);
  localB->loop_ub_tmp = (localB->tmp_size_d != 1);
  localB->loop_ub_tmp_g = (localB->tmp_size_cg != 1);
  localB->stride_4_0 = (localB->tmp_size_na != 1);
  localB->stride_5_0 = (localB->tmp_size_f != 1);
  localB->stride_6_0 = (localB->tmp_size_pm != 1);
  localB->loop_ub_a = (localB->tmp_size_pm == 1 ? localB->tmp_size_f == 1 ?
                       localB->tmp_size_na : localB->tmp_size_f :
                       localB->tmp_size_pm) == 1 ? (localB->tmp_size_cg == 1 ?
    localB->tmp_size_d == 1 ? localB->tmp_size_n : localB->tmp_size_d :
    localB->tmp_size_cg) == 1 ? in3 : localB->tmp_size_cg == 1 ?
    localB->tmp_size_d == 1 ? localB->tmp_size_n : localB->tmp_size_d :
    localB->tmp_size_cg : localB->tmp_size_pm == 1 ? localB->tmp_size_f == 1 ?
    localB->tmp_size_na : localB->tmp_size_f : localB->tmp_size_pm;
  for (localB->i_f = 0; localB->i_f < localB->loop_ub_a; localB->i_f++) {
    in1_data[localB->i_f] = (in2[localB->i_f * localB->in5_idx_0] &&
      ((!localB->tmp_data_p4[localB->i_f * localB->in5_idx_1]) &&
       (!localB->tmp_data_ap[localB->i_f * localB->loop_ub_tmp]) &&
       (!localB->tmp_data_ek[localB->i_f * localB->loop_ub_tmp_g])) &&
      ((!localB->tmp_data_j[localB->i_f * localB->stride_4_0]) &&
       (!localB->tmp_data_ol[localB->i_f * localB->stride_5_0]) &&
       (!localB->tmp_data_b[localB->i_f * localB->stride_6_0])));
  }

  // End of MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask'
  // End of Outputs for SubSystem: '<S4>/Galileo'
}

//
// System initialize for enable system:
//    '<S4>/Galileo'
//    '<S5>/Galileo'
//
void DDRTCM::DDRTCM_Galileo_Init(B_Galileo_DDRTCM_T *localB, DW_Galileo_DDRTCM_T
  *localDW, P_Galileo_DDRTCM_T *localP)
{
  // SystemInitialize for MATLAB Function: '<S75>/Calculate Differential Corrections' 
  CalculateDifferentialCor_l_Init(&localDW->sf_CalculateDifferentialCorrect);

  // SystemInitialize for Enabled SubSystem: '<S17>/Galileo E1 stream'
  Galileosinglefrequencystre_Init(&localB->GalileoE1stream,
    &localP->GalileoE1stream);

  // End of SystemInitialize for SubSystem: '<S17>/Galileo E1 stream'

  // SystemInitialize for Enabled SubSystem: '<S17>/Galileo E5a stream'
  Galileosinglefrequencystre_Init(&localB->GalileoE5astream,
    &localP->GalileoE5astream);

  // End of SystemInitialize for SubSystem: '<S17>/Galileo E5a stream'

  // SystemInitialize for Enabled SubSystem: '<S17>/Galileo E5b stream'
  Galileosinglefrequencystre_Init(&localB->GalileoE5bstream,
    &localP->GalileoE5bstream);

  // End of SystemInitialize for SubSystem: '<S17>/Galileo E5b stream'

  // SystemInitialize for Enabled SubSystem: '<S17>/Galileo E5 stream'
  Galileosinglefrequencystre_Init(&localB->GalileoE5stream,
    &localP->GalileoE5stream);

  // End of SystemInitialize for SubSystem: '<S17>/Galileo E5 stream'

  // SystemInitialize for BusSelector: '<S17>/Bus Selector' incorporates:
  //   Outport: '<S17>/time receive'

  localB->time_receive = localP->timereceive_Y0;

  // SystemInitialize for BusSelector: '<S17>/Bus Selector' incorporates:
  //   Outport: '<S17>/basePosition'

  localB->base_position[0] = localP->basePosition_Y0;
  localB->base_position[1] = localP->basePosition_Y0;
  localB->base_position[2] = localP->basePosition_Y0;
}

//
// Output and update for enable system:
//    '<S4>/Galileo'
//    '<S5>/Galileo'
//
void DDRTCM::DDRTCM_Galileo(const gnssraw_measurement_t *rtu_GAL_Measurement_Bus,
  const real_T rtu_GAL_NAV_Bus[36], const uint16_T rtu_GAL_NAV_Bus_p[36], const
  uint8_T rtu_GAL_NAV_Bus_o[36], const real_T rtu_GAL_NAV_Bus_c[36], const
  real_T rtu_GAL_NAV_Bus_d[36], const real_T rtu_GAL_NAV_Bus_k[36], const real_T
  rtu_GAL_NAV_Bus_h[36], const real_T rtu_GAL_NAV_Bus_j[36], const real_T
  rtu_GAL_NAV_Bus_b[36], const real_T rtu_GAL_NAV_Bus_hs[36], const real_T
  rtu_GAL_NAV_Bus_pu[36], const real_T rtu_GAL_NAV_Bus_on[36], const real_T
  rtu_GAL_NAV_Bus_f[36], const real_T rtu_GAL_NAV_Bus_ok[36], const real_T
  rtu_GAL_NAV_Bus_e[36], const real_T rtu_GAL_NAV_Bus_m[36], const real_T
  rtu_GAL_NAV_Bus_jt[36], const real_T rtu_GAL_NAV_Bus_mj[36], const uint32_T
  rtu_GAL_NAV_Bus_o0[36], const uint32_T rtu_GAL_NAV_Bus_f0[36], const real_T
  rtu_GAL_NAV_Bus_fe[36], const real_T rtu_GAL_NAV_Bus_j0[36], const real_T
  rtu_GAL_NAV_Bus_oo[36], const uint16_T rtu_GAL_NAV_Bus_hs0[36], const uint16_T
  rtu_GAL_NAV_Bus_l[36], const uint16_T rtu_GAL_NAV_Bus_da[36], const real_T
  rtu_userPos_LLH[3], real_T rtu_dayOfYear, boolean_T rtu_parameters_gnss_Bus,
  boolean_T rtu_parameters_gnss_Bus_d, boolean_T rtu_parameters_gnss_Bus_b,
  boolean_T rtu_parameters_gnss_Bus_c, boolean_T rtu_parameters_gnss_Bus_o,
  boolean_T rtu_parameters_gnss_Bus_a, boolean_T rtu_parameters_gnss_Bus_dr,
  boolean_T rtu_parameters_gnss_Bus_o4, boolean_T rtu_parameters_gnss_Bus_j,
  boolean_T rtu_parameters_gnss_Bus_bl, real_T rtu_parameters_gnss_Bus_je, const
  GNSS_Measurement *rtu_GalMeasurementB, const GNSS_Measurement_size
  *rtu_GalMeasurementB_DIMS1, B_Galileo_DDRTCM_T *localB, DW_Galileo_DDRTCM_T
  *localDW, P_Galileo_DDRTCM_T *localP)
{
  // Outputs for Enabled SubSystem: '<S4>/Galileo' incorporates:
  //   EnablePort: '<S17>/Enable'

  if (rtu_parameters_gnss_Bus) {
    __m128d tmp_1;
    boolean_T exitg1;

    // BusCreator generated from: '<S17>/Navigation Data Conversion GAL'
    std::memcpy(&localB->BusConversion_InsertedF_m3b.TOW[0], &rtu_GAL_NAV_Bus[0],
                36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.WNc[0], &rtu_GAL_NAV_Bus_p
                [0], 36U * sizeof(uint16_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.SQRT_A[0],
                &rtu_GAL_NAV_Bus_c[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.M_0[0], &rtu_GAL_NAV_Bus_d
                [0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.E[0], &rtu_GAL_NAV_Bus_k[0],
                36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.I_0[0], &rtu_GAL_NAV_Bus_h
                [0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.omega[0],
                &rtu_GAL_NAV_Bus_j[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.OMEGA_0[0],
                &rtu_GAL_NAV_Bus_b[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.OMEGADOT[0],
                &rtu_GAL_NAV_Bus_hs[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.IDOT[0],
                &rtu_GAL_NAV_Bus_pu[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.DELTA_N[0],
                &rtu_GAL_NAV_Bus_on[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.C_uc[0],
                &rtu_GAL_NAV_Bus_f[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.C_us[0],
                &rtu_GAL_NAV_Bus_ok[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.C_rc[0],
                &rtu_GAL_NAV_Bus_e[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.C_rs[0],
                &rtu_GAL_NAV_Bus_m[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.C_ic[0],
                &rtu_GAL_NAV_Bus_jt[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.C_is[0],
                &rtu_GAL_NAV_Bus_mj[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.T_oc[0],
                &rtu_GAL_NAV_Bus_o0[0], 36U * sizeof(uint32_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.T_oe[0],
                &rtu_GAL_NAV_Bus_f0[0], 36U * sizeof(uint32_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.A_f2[0],
                &rtu_GAL_NAV_Bus_fe[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.A_f1[0],
                &rtu_GAL_NAV_Bus_j0[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.A_f0[0],
                &rtu_GAL_NAV_Bus_oo[0], 36U * sizeof(real_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.WNt_oc[0],
                &rtu_GAL_NAV_Bus_hs0[0], 36U * sizeof(uint16_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.WNt_oe[0],
                &rtu_GAL_NAV_Bus_l[0], 36U * sizeof(uint16_T));
    std::memcpy(&localB->BusConversion_InsertedF_m3b.IODnav[0],
                &rtu_GAL_NAV_Bus_da[0], 36U * sizeof(uint16_T));
    for (localB->i = 0; localB->i < 36; localB->i++) {
      localB->BusConversion_InsertedF_m3b.SVID[localB->i] =
        rtu_GAL_NAV_Bus_o[localB->i];
    }

    // MATLAB Function: '<S17>/Navigation Data Conversion GAL'
    DDR_NavigationDataConversionGAL(&localB->BusConversion_InsertedF_m3b,
      &localB->sf_NavigationDataConversionGAL,
      &localDW->sf_NavigationDataConversionGAL);

    // MATLAB Function: '<S69>/MATLAB Function1' incorporates:
    //   BusCreator generated from: '<S69>/MATLAB Function1'
    //   Constant: '<S17>/E5_basedProcessing'

    if (!localP->E5_basedProcessing_Value) {
      localB->parameters_galileo_Bus.enable_galileo = true;
      localB->parameters_galileo_Bus.enable_galileo_e1 = true;
      localB->parameters_galileo_Bus.enable_galileo_e5a =
        rtu_parameters_gnss_Bus_b;
      localB->parameters_galileo_Bus.enable_galileo_e5b =
        rtu_parameters_gnss_Bus_c;
      localB->parameters_galileo_Bus.enable_galileo_e5 =
        rtu_parameters_gnss_Bus_o;
    } else {
      localB->parameters_galileo_Bus.enable_galileo = true;
      localB->parameters_galileo_Bus.enable_galileo_e1 =
        rtu_parameters_gnss_Bus_d;
      localB->parameters_galileo_Bus.enable_galileo_e5a =
        rtu_parameters_gnss_Bus_b;
      localB->parameters_galileo_Bus.enable_galileo_e5b =
        rtu_parameters_gnss_Bus_c;
      localB->parameters_galileo_Bus.enable_galileo_e5 = true;
    }

    // End of MATLAB Function: '<S69>/MATLAB Function1'

    // MATLAB Function: '<S17>/Simplify and Mask GAL Measurement Bus'
    SimplifyandMaskGALMeasurementBu(rtu_GAL_Measurement_Bus,
      &localB->sf_NavigationDataConversionGAL.GAL_NavigationData_Bus,
      &localDW->sf_NavigationDataConversionGAL.SFunction_DIMS2,
      &localB->parameters_galileo_Bus, &localB->sf_SimplifyandMaskGALMeasuremen,
      &localDW->sf_SimplifyandMaskGALMeasuremen);

    // MATLAB Function: '<S75>/Calculate Differential Corrections'
    CalculateDifferentialCorrecti_f(rtu_GalMeasurementB, (GNSS_Measurement_size *)
      rtu_GalMeasurementB_DIMS1,
      &localB->sf_SimplifyandMaskGALMeasuremen.navdata_e1,
      &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS4, rtu_userPos_LLH,
      &localB->sf_CalculateDifferentialCorrect,
      &localDW->sf_CalculateDifferentialCorrect);

    // Outputs for Enabled SubSystem: '<S17>/Galileo E1 stream'
    // Outputs for Enabled SubSystem: '<S17>/Galileo E1 stream'
    // SignalConversion generated from: '<S70>/Enable' incorporates:
    //   Constant: '<S17>/Base Position Dummy'
    //   Constant: '<S17>/E5_basedProcessing'

    DD_Galileosinglefrequencystream
      (localB->parameters_galileo_Bus.enable_galileo_e1,
       localP->E5_basedProcessing_Value,
       localB->sf_SimplifyandMaskGALMeasuremen.TOW,
       localB->sf_SimplifyandMaskGALMeasuremen.svid_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS3,
       &localB->sf_SimplifyandMaskGALMeasuremen.navdata_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS4,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS5,
       localB->sf_SimplifyandMaskGALMeasuremen.dr_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS7,
       localB->sf_SimplifyandMaskGALMeasuremen.cn0_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS8,
       rtu_userPos_LLH, localB->sf_SimplifyandMaskGALMeasuremen.cp_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS9,
       localB->sf_SimplifyandMaskGALMeasuremen.locktime_e1,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS11,
       localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_j,
       rtu_parameters_gnss_Bus_bl,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e1_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS6,
       localB->sf_SimplifyandMaskGALMeasuremen.cp_e1_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS10,
       localP->GalileoE1stream_enable_SatClock, &localB->GalileoE1stream,
       &localDW->GalileoE1stream, &localP->GalileoE1stream);

    // End of Outputs for SubSystem: '<S17>/Galileo E1 stream'
    // End of Outputs for SubSystem: '<S17>/Galileo E1 stream'

    // MATLAB Function: '<S115>/Create Satellite Elevation Mask' incorporates:
    //   Constant: '<S114>/Constant'
    //   Logic: '<S75>/Logical Operator1'
    //   RelationalOperator: '<S114>/Compare'

    DD_CreateSatelliteElevationMask(rtu_userPos_LLH, (rtu_userPos_LLH[0] !=
      localP->CompareToConstant_const) && (rtu_userPos_LLH[1] !=
      localP->CompareToConstant_const) && (rtu_userPos_LLH[2] !=
      localP->CompareToConstant_const),
      localB->GalileoE1stream.sf_CalculateSatellitePositionan.satPosEcef,
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS2,
      rtu_parameters_gnss_Bus_je, &localB->removedSats_a,
      &localB->sf_CreateSatelliteElevationMask,
      &localDW->sf_CreateSatelliteElevationMask);

    // BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5' incorporates:
    //   SignalConversion generated from: '<S70>/SVID'

    localDW->BusConversion_InsertedFor_Calcu.satellite_position[0] =
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0];
    localDW->BusConversion_InsertedFor_Calcu.satellite_position[1] =
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    localDW->BusConversion_InsertedFor_Calcu.satellite_velocity[0] =
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0];
    localDW->BusConversion_InsertedFor_Calcu.satellite_velocity[1] =
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    localDW->BusConversion_InsertedFor_Calcu.PRN =
      localDW->GalileoE1stream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.pseudorange =
      localDW->GalileoE1stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.pseudorange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS5;
    localDW->BusConversion_InsertedFor_Calcu.pseudorange_satclk_corrected =
      localDW->GalileoE1stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.deltarange =
      localDW->GalileoE1stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.deltarange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS7;
    localDW->BusConversion_InsertedFor_Calcu.deltarange_satclk_corrected =
      localDW->GalileoE1stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.variance_pseudorange =
      localDW->GalileoE1stream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.variance_pseudorange_measured =
      localDW->GalileoE1stream.measured_pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.variance_deltarange =
      localDW->GalileoE1stream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Calcu.carrierphase =
      localDW->GalileoE1stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.carrierphase_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS9;
    localDW->BusConversion_InsertedFor_Calcu.carrierphase_satclk_corrected =
      localDW->GalileoE1stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Calcu.variance_carrierphase_measured =
      localDW->GalileoE1stream.measured_cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.locktime =
      localDW->GalileoE1stream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Calcu.CN0 =
      localDW->GalileoE1stream.CN0_DIMS1;
    localB->idx =
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0]
      * localDW->
      GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    if (localB->idx - 1 >= 0) {
      std::memcpy(&localB->rtb_BusConversion_InsertedFo__c[0],
                  &localB->GalileoE1stream.sf_CalculateSatellitePositionan.satPosEcef
                  [0], static_cast<uint32_T>(localB->idx) * sizeof(real_T));
    }

    localB->idx =
      localDW->GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0]
      * localDW->
      GalileoE1stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    if (localB->idx - 1 >= 0) {
      std::memcpy(&localB->rtb_BusConversion_InsertedFo__f[0],
                  &localB->GalileoE1stream.sf_CalculateSatellitePositionan.satVelEcef
                  [0], static_cast<uint32_T>(localB->idx) * sizeof(real_T));
    }

    for (localB->ii = 0; localB->ii < localDW->GalileoE1stream.SVID_DIMS1;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_oj[localB->ii] =
        localB->GalileoE1stream.PRN[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo__l[localB->ii] =
        localB->GalileoE1stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS5; localB->ii++)
    {
      localB->dualFrequencyCorrection[localB->ii] =
        localB->sf_SimplifyandMaskGALMeasuremen.pr_e1[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo__j[localB->ii] =
        localB->
        GalileoE1stream.sf_TimeCorrectionDeltarange.deltarangeCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS7; localB->ii++)
    {
      localB->rtb_BusConversion_InsertedFo__d[localB->ii] =
        localB->sf_SimplifyandMaskGALMeasuremen.dr_e1[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo__g[localB->ii] =
        localB->
        GalileoE1stream.sf_TimeCorrectionDeltarange.deltarangeCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_SignalNoiseVariance.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_ld[localB->ii] =
        localB->
        GalileoE1stream.sf_SignalNoiseVariance.variancePseudorange[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.measured_pr_sigma_DIMS1; localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_dh[localB->ii] =
        localB->GalileoE1stream.measured_pr_sigma[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_SignalNoiseVariance.SFunction_DIMS3;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_dy[localB->ii] =
        localB->GalileoE1stream.sf_SignalNoiseVariance.varianceDeltarange
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_lx[localB->ii] =
        localB->GalileoE1stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS9; localB->ii++)
    {
      localB->rtb_BusConversion_InsertedFo__o[localB->ii] =
        localB->sf_SimplifyandMaskGALMeasuremen.cp_e1[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo__b[localB->ii] =
        localB->GalileoE1stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE1stream.measured_cp_sigma_DIMS1; localB->ii++) {
      localB->rtb_BusConversion_InsertedFo__n[localB->ii] =
        localB->GalileoE1stream.measured_cp_sigma[localB->ii];
    }

    for (localB->ii = 0; localB->ii < localDW->GalileoE1stream.locktime_DIMS1;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_nv[localB->ii] =
        localB->GalileoE1stream.Locktime[localB->ii];
    }

    for (localB->ii = 0; localB->ii < localDW->GalileoE1stream.CN0_DIMS1;
         localB->ii++) {
      localB->rtb_BusConversion_InsertedFo_bs[localB->ii] =
        localB->GalileoE1stream.CN0[localB->ii];
    }

    // Outputs for Enabled SubSystem: '<S17>/Galileo E5a stream'
    // Outputs for Enabled SubSystem: '<S17>/Galileo E5a stream'
    // SignalConversion generated from: '<S72>/Enable' incorporates:
    //   Constant: '<S17>/Base Position Dummy'
    //   Constant: '<S17>/E5_basedProcessing'

    DD_Galileosinglefrequencystream
      (localB->parameters_galileo_Bus.enable_galileo_e5a,
       localP->E5_basedProcessing_Value,
       localB->sf_SimplifyandMaskGALMeasuremen.TOW,
       localB->sf_SimplifyandMaskGALMeasuremen.svid_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS12,
       &localB->sf_SimplifyandMaskGALMeasuremen.navdata_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS13,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS14,
       localB->sf_SimplifyandMaskGALMeasuremen.dr_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS16,
       localB->sf_SimplifyandMaskGALMeasuremen.cn0_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS17,
       rtu_userPos_LLH, localB->sf_SimplifyandMaskGALMeasuremen.cp_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS18,
       localB->sf_SimplifyandMaskGALMeasuremen.locktime_e5a,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS20,
       localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_j,
       rtu_parameters_gnss_Bus_bl,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e5a_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS15,
       localB->sf_SimplifyandMaskGALMeasuremen.cp_e5a_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS19,
       localP->GalileoE5astream_enable_SatCloc, &localB->GalileoE5astream,
       &localDW->GalileoE5astream, &localP->GalileoE5astream);

    // End of Outputs for SubSystem: '<S17>/Galileo E5a stream'
    // End of Outputs for SubSystem: '<S17>/Galileo E5a stream'

    // BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5' 
    localDW->BusConversion_InsertedFor_Cal_c.satellite_position[0] =
      localDW->GalileoE5astream.sf_CalculateSatellitePositionan.SFunction_DIMS2
      [0];
    localDW->BusConversion_InsertedFor_Cal_c.satellite_position[1] =
      localDW->GalileoE5astream.sf_CalculateSatellitePositionan.SFunction_DIMS2
      [1];
    localDW->BusConversion_InsertedFor_Cal_c.satellite_velocity[0] =
      localDW->GalileoE5astream.sf_CalculateSatellitePositionan.SFunction_DIMS3
      [0];
    localDW->BusConversion_InsertedFor_Cal_c.satellite_velocity[1] =
      localDW->GalileoE5astream.sf_CalculateSatellitePositionan.SFunction_DIMS3
      [1];
    localDW->BusConversion_InsertedFor_Cal_c.PRN =
      localDW->GalileoE5astream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_c.pseudorange =
      localDW->GalileoE5astream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.pseudorange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS14;
    localDW->BusConversion_InsertedFor_Cal_c.pseudorange_satclk_corrected =
      localDW->GalileoE5astream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.deltarange =
      localDW->GalileoE5astream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.deltarange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS16;
    localDW->BusConversion_InsertedFor_Cal_c.deltarange_satclk_corrected =
      localDW->GalileoE5astream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.variance_pseudorange =
      localDW->GalileoE5astream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.variance_pseudorange_measured =
      localDW->GalileoE5astream.measured_pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_c.variance_deltarange =
      localDW->GalileoE5astream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Cal_c.carrierphase =
      localDW->GalileoE5astream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.carrierphase_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS18;
    localDW->BusConversion_InsertedFor_Cal_c.carrierphase_satclk_corrected =
      localDW->GalileoE5astream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_c.variance_carrierphase_measured =
      localDW->GalileoE5astream.measured_cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_c.locktime =
      localDW->GalileoE5astream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_c.CN0 =
      localDW->GalileoE5astream.CN0_DIMS1;

    // Outputs for Enabled SubSystem: '<S17>/Galileo E5b stream'
    // Outputs for Enabled SubSystem: '<S17>/Galileo E5b stream'
    // SignalConversion generated from: '<S73>/Enable' incorporates:
    //   Constant: '<S17>/Base Position Dummy'
    //   Constant: '<S17>/E5_basedProcessing'

    DD_Galileosinglefrequencystream
      (localB->parameters_galileo_Bus.enable_galileo_e5b,
       localP->E5_basedProcessing_Value,
       localB->sf_SimplifyandMaskGALMeasuremen.TOW,
       localB->sf_SimplifyandMaskGALMeasuremen.svid_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS21,
       &localB->sf_SimplifyandMaskGALMeasuremen.navdata_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS22,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS23,
       localB->sf_SimplifyandMaskGALMeasuremen.dr_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS25,
       localB->sf_SimplifyandMaskGALMeasuremen.cn0_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS26,
       rtu_userPos_LLH, localB->sf_SimplifyandMaskGALMeasuremen.cp_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS27,
       localB->sf_SimplifyandMaskGALMeasuremen.locktime_e5b,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS29,
       localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_j,
       rtu_parameters_gnss_Bus_bl,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e5b_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS24,
       localB->sf_SimplifyandMaskGALMeasuremen.cp_e5b_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS28,
       localP->GalileoE5bstream_enable_SatCloc, &localB->GalileoE5bstream,
       &localDW->GalileoE5bstream, &localP->GalileoE5bstream);

    // End of Outputs for SubSystem: '<S17>/Galileo E5b stream'
    // End of Outputs for SubSystem: '<S17>/Galileo E5b stream'

    // BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5' 
    localDW->BusConversion_InsertedFor_Cal_n.satellite_position[0] =
      localDW->GalileoE5bstream.sf_CalculateSatellitePositionan.SFunction_DIMS2
      [0];
    localDW->BusConversion_InsertedFor_Cal_n.satellite_position[1] =
      localDW->GalileoE5bstream.sf_CalculateSatellitePositionan.SFunction_DIMS2
      [1];
    localDW->BusConversion_InsertedFor_Cal_n.satellite_velocity[0] =
      localDW->GalileoE5bstream.sf_CalculateSatellitePositionan.SFunction_DIMS3
      [0];
    localDW->BusConversion_InsertedFor_Cal_n.satellite_velocity[1] =
      localDW->GalileoE5bstream.sf_CalculateSatellitePositionan.SFunction_DIMS3
      [1];
    localDW->BusConversion_InsertedFor_Cal_n.PRN =
      localDW->GalileoE5bstream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.pseudorange =
      localDW->GalileoE5bstream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.pseudorange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS23;
    localDW->BusConversion_InsertedFor_Cal_n.pseudorange_satclk_corrected =
      localDW->GalileoE5bstream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.deltarange =
      localDW->GalileoE5bstream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.deltarange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS25;
    localDW->BusConversion_InsertedFor_Cal_n.deltarange_satclk_corrected =
      localDW->GalileoE5bstream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.variance_pseudorange =
      localDW->GalileoE5bstream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.variance_pseudorange_measured =
      localDW->GalileoE5bstream.measured_pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.variance_deltarange =
      localDW->GalileoE5bstream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Cal_n.carrierphase =
      localDW->GalileoE5bstream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.carrierphase_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS27;
    localDW->BusConversion_InsertedFor_Cal_n.carrierphase_satclk_corrected =
      localDW->GalileoE5bstream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_n.variance_carrierphase_measured =
      localDW->GalileoE5bstream.measured_cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.locktime =
      localDW->GalileoE5bstream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_n.CN0 =
      localDW->GalileoE5bstream.CN0_DIMS1;

    // Outputs for Enabled SubSystem: '<S17>/Galileo E5 stream'
    // Outputs for Enabled SubSystem: '<S17>/Galileo E5 stream'
    // SignalConversion generated from: '<S71>/Enable' incorporates:
    //   Constant: '<S17>/Base Position Dummy'
    //   Constant: '<S17>/E5_basedProcessing'

    DD_Galileosinglefrequencystream
      (localB->parameters_galileo_Bus.enable_galileo_e5,
       localP->E5_basedProcessing_Value,
       localB->sf_SimplifyandMaskGALMeasuremen.TOW,
       localB->sf_SimplifyandMaskGALMeasuremen.svid_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS30,
       &localB->sf_SimplifyandMaskGALMeasuremen.navdata_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS31,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS32,
       localB->sf_SimplifyandMaskGALMeasuremen.dr_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS34,
       localB->sf_SimplifyandMaskGALMeasuremen.cn0_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS35,
       rtu_userPos_LLH, localB->sf_SimplifyandMaskGALMeasuremen.cp_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS36,
       localB->sf_SimplifyandMaskGALMeasuremen.locktime_e5,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS38,
       localP->BasePositionDummy_Value, rtu_parameters_gnss_Bus_j,
       rtu_parameters_gnss_Bus_bl,
       localB->sf_SimplifyandMaskGALMeasuremen.pr_e5_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS33,
       localB->sf_SimplifyandMaskGALMeasuremen.cp_e5_sigma,
       &localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS37,
       localP->GalileoE5stream_enable_SatClock, &localB->GalileoE5stream,
       &localDW->GalileoE5stream, &localP->GalileoE5stream);

    // End of Outputs for SubSystem: '<S17>/Galileo E5 stream'
    // End of Outputs for SubSystem: '<S17>/Galileo E5 stream'

    // BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5' incorporates:
    //   SignalConversion generated from: '<S71>/SVID'

    localDW->BusConversion_InsertedFor_Cal_d.satellite_position[0] =
      localDW->GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0];
    localDW->BusConversion_InsertedFor_Cal_d.satellite_position[1] =
      localDW->GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    localDW->BusConversion_InsertedFor_Cal_d.satellite_velocity[0] =
      localDW->GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0];
    localDW->BusConversion_InsertedFor_Cal_d.satellite_velocity[1] =
      localDW->GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    localDW->BusConversion_InsertedFor_Cal_d.PRN =
      localDW->GalileoE5stream.SVID_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_d.pseudorange =
      localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.pseudorange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS32;
    localDW->BusConversion_InsertedFor_Cal_d.pseudorange_satclk_corrected =
      localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.deltarange =
      localDW->GalileoE5stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.deltarange_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS34;
    localDW->BusConversion_InsertedFor_Cal_d.deltarange_satclk_corrected =
      localDW->GalileoE5stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.variance_pseudorange =
      localDW->GalileoE5stream.sf_SignalNoiseVariance.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.variance_pseudorange_measured =
      localDW->GalileoE5stream.measured_pr_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_d.variance_deltarange =
      localDW->GalileoE5stream.sf_SignalNoiseVariance.SFunction_DIMS3;
    localDW->BusConversion_InsertedFor_Cal_d.carrierphase =
      localDW->GalileoE5stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.carrierphase_raw =
      localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS36;
    localDW->BusConversion_InsertedFor_Cal_d.carrierphase_satclk_corrected =
      localDW->GalileoE5stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
    localDW->BusConversion_InsertedFor_Cal_d.variance_carrierphase_measured =
      localDW->GalileoE5stream.measured_cp_sigma_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_d.locktime =
      localDW->GalileoE5stream.locktime_DIMS1;
    localDW->BusConversion_InsertedFor_Cal_d.CN0 =
      localDW->GalileoE5stream.CN0_DIMS1;
    localB->idx =
      localDW->GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[0]
      * localDW->
      GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS2[1];
    if (localB->idx - 1 >= 0) {
      std::memcpy(&localB->rtb_measurementFrequency_Bus_sa[0],
                  &localB->GalileoE5stream.sf_CalculateSatellitePositionan.satPosEcef
                  [0], static_cast<uint32_T>(localB->idx) * sizeof(real_T));
    }

    localB->idx =
      localDW->GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[0]
      * localDW->
      GalileoE5stream.sf_CalculateSatellitePositionan.SFunction_DIMS3[1];
    if (localB->idx - 1 >= 0) {
      std::memcpy(&localB->rtb_measurementFrequency_Bus__g[0],
                  &localB->GalileoE5stream.sf_CalculateSatellitePositionan.satVelEcef
                  [0], static_cast<uint32_T>(localB->idx) * sizeof(real_T));
    }

    for (localB->ii = 0; localB->ii < localDW->GalileoE5stream.SVID_DIMS1;
         localB->ii++) {
      localB->PRN_n[localB->ii] = localB->GalileoE5stream.PRN[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
         localB->ii++) {
      localB->Add1_a[localB->ii] =
        localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS32; localB->ii++)
    {
      localB->rtb_measurementFrequency_Bus_ps[localB->ii] =
        localB->sf_SimplifyandMaskGALMeasuremen.pr_e5[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus_de[localB->ii] =
        localB->
        GalileoE5stream.sf_TimeCorrectionDeltarange.deltarangeCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS34; localB->ii++)
    {
      localB->rtb_measurementFrequency_Bus__b[localB->ii] =
        localB->sf_SimplifyandMaskGALMeasuremen.dr_e5[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_TimeCorrectionDeltarange.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus__d[localB->ii] =
        localB->
        GalileoE5stream.sf_TimeCorrectionDeltarange.deltarangeCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_SignalNoiseVariance.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus_va[localB->ii] =
        localB->
        GalileoE5stream.sf_SignalNoiseVariance.variancePseudorange[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.measured_pr_sigma_DIMS1; localB->ii++) {
      localB->rtb_measurementFrequency_Bus_bj[localB->ii] =
        localB->GalileoE5stream.measured_pr_sigma[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_SignalNoiseVariance.SFunction_DIMS3;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus__j[localB->ii] =
        localB->GalileoE5stream.sf_SignalNoiseVariance.varianceDeltarange
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus_ca[localB->ii] =
        localB->GalileoE5stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->sf_SimplifyandMaskGALMeasuremen.SFunction_DIMS36; localB->ii++)
    {
      localB->rtb_measurementFrequency_Bus__a[localB->ii] =
        localB->sf_SimplifyandMaskGALMeasuremen.cp_e5[localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.sf_TimeCorrectionCarrierphase.SFunction_DIMS2;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus_ju[localB->ii] =
        localB->GalileoE5stream.sf_TimeCorrectionCarrierphase.carrierphaseCorrected
        [localB->ii];
    }

    for (localB->ii = 0; localB->ii <
         localDW->GalileoE5stream.measured_cp_sigma_DIMS1; localB->ii++) {
      localB->rtb_measurementFrequency_Bus_jz[localB->ii] =
        localB->GalileoE5stream.measured_cp_sigma[localB->ii];
    }

    for (localB->ii = 0; localB->ii < localDW->GalileoE5stream.locktime_DIMS1;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus_lo[localB->ii] =
        localB->GalileoE5stream.Locktime[localB->ii];
    }

    for (localB->ii = 0; localB->ii < localDW->GalileoE5stream.CN0_DIMS1;
         localB->ii++) {
      localB->rtb_measurementFrequency_Bus_CN[localB->ii] =
        localB->GalileoE5stream.CN0[localB->ii];
    }

    // MATLAB Function: '<S69>/MATLAB Function'
    localB->x[0] = localB->parameters_galileo_Bus.enable_galileo_e1;
    localB->x[1] = localB->parameters_galileo_Bus.enable_galileo_e5a;
    localB->x[2] = localB->parameters_galileo_Bus.enable_galileo_e5b;
    localB->x[3] = localB->parameters_galileo_Bus.enable_galileo_e5;
    localB->idx = 0;
    localB->ii = 0;
    exitg1 = false;
    while ((!exitg1) && (localB->ii < 4)) {
      if (localB->x[localB->ii]) {
        localB->idx++;
        if (localB->idx >= 4) {
          exitg1 = true;
        } else {
          localB->ii++;
        }
      } else {
        localB->ii++;
      }
    }

    // Logic: '<S69>/Logical Operator'
    localB->LogicalOperator_k = !rtu_parameters_gnss_Bus_a;

    // MATLAB Function: '<S69>/MATLAB Function'
    if (localB->idx < 1) {
      localB->idx = 0;
    }

    // MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5' incorporates:
    //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'
    //   Constant: '<S17>/E5_basedProcessing'
    //   Logic: '<S112>/Logical Operator'
    //   Logic: '<S69>/Logical Operator3'
    //   Logic: '<S69>/Logical Operator4'
    //   Logic: '<S69>/Logical Operator5'
    //   MATLAB Function: '<S69>/MATLAB Function'
    //   SignalConversion generated from: '<S70>/SVID'
    //   SignalConversion generated from: '<S71>/SVID'
    //   SignalConversion generated from: '<S72>/SVID'
    //   SignalConversion generated from: '<S73>/SVID'

    if ((localB->idx > 1) || ((!localB->LogicalOperator_k) ||
         (!rtu_parameters_gnss_Bus_dr))) {
      if (!localP->E5_basedProcessing_Value) {
        localDW->SFunction_DIMS2_h = localDW->BusConversion_InsertedFor_Calcu;

        // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
        //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'

        localB->measurementFrequencyCorre_o.time_receive =
          localB->GalileoE1stream.TOW;
        std::memcpy(&localB->rtb_measurementFrequency_Bus_sa[0],
                    &localB->rtb_BusConversion_InsertedFo__c[0], 120U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus__g[0],
                    &localB->rtb_BusConversion_InsertedFo__f[0], 120U * sizeof
                    (real_T));
        std::memcpy(&localB->PRN_n[0], &localB->rtb_BusConversion_InsertedFo_oj
                    [0], 40U * sizeof(uint16_T));
        std::memcpy(&localB->Add1_a[0], &localB->
                    rtb_BusConversion_InsertedFo__l[0], 40U * sizeof(real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_ps[0],
                    &localB->dualFrequencyCorrection[0], 40U * sizeof(real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_de[0],
                    &localB->rtb_BusConversion_InsertedFo__j[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus__b[0],
                    &localB->rtb_BusConversion_InsertedFo__d[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus__d[0],
                    &localB->rtb_BusConversion_InsertedFo__g[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_va[0],
                    &localB->rtb_BusConversion_InsertedFo_ld[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_bj[0],
                    &localB->rtb_BusConversion_InsertedFo_dh[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus__j[0],
                    &localB->rtb_BusConversion_InsertedFo_dy[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_ca[0],
                    &localB->rtb_BusConversion_InsertedFo_lx[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus__a[0],
                    &localB->rtb_BusConversion_InsertedFo__o[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_ju[0],
                    &localB->rtb_BusConversion_InsertedFo__b[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_jz[0],
                    &localB->rtb_BusConversion_InsertedFo__n[0], 40U * sizeof
                    (real_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_lo[0],
                    &localB->rtb_BusConversion_InsertedFo_nv[0], 40U * sizeof
                    (real32_T));
        std::memcpy(&localB->rtb_measurementFrequency_Bus_CN[0],
                    &localB->rtb_BusConversion_InsertedFo_bs[0], 40U * sizeof
                    (real_T));

        // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
        //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'

        localB->measurementFrequencyCorre_o.base_position[0] =
          localB->GalileoE1stream.basePosition[0];
        localB->measurementFrequencyCorre_o.base_position[1] =
          localB->GalileoE1stream.basePosition[1];
        localB->measurementFrequencyCorre_o.base_position[2] =
          localB->GalileoE1stream.basePosition[2];
        localB->SVID_DIMS1 = localDW->GalileoE1stream.SVID_DIMS1;
        localB->SVID_DIMS1_m = localDW->GalileoE5astream.SVID_DIMS1;
        DDRTCM_do_vectors_k(localB->GalileoE1stream.PRN, &localB->SVID_DIMS1,
                            localB->GalileoE5astream.PRN, &localB->SVID_DIMS1_m,
                            localB->PRNsE1E5a_data, &localB->PRNsE1E5a_size,
                            localB->iia_data, &localB->iia_size,
                            localB->iib_data, &localB->iib_size, localB);
        localB->SVID_DIMS1_o = localDW->GalileoE1stream.SVID_DIMS1;
        localB->SVID_DIMS1_n = localDW->GalileoE5bstream.SVID_DIMS1;
        DDRTCM_do_vectors_k(localB->GalileoE1stream.PRN, &localB->SVID_DIMS1_o,
                            localB->GalileoE5bstream.PRN, &localB->SVID_DIMS1_n,
                            localB->rtb_BusConversion_InsertedFo_oj,
                            &localB->PRNsE5E1_size, localB->iia_data,
                            &localB->iia_size, localB->iib_data,
                            &localB->iib_size, localB);
        localB->SVID_DIMS1_l = localDW->GalileoE1stream.SVID_DIMS1;
        localB->SVID_DIMS1_p = localDW->GalileoE5stream.SVID_DIMS1;
        DDRTCM_do_vectors_k(localB->GalileoE1stream.PRN, &localB->SVID_DIMS1_l,
                            localB->GalileoE5stream.PRN, &localB->SVID_DIMS1_p,
                            localB->PRNsE1E5_data, &localB->SVID_DIMS1_o,
                            localB->iia_data, &localB->iia_size,
                            localB->iib_data, &localB->iib_size, localB);
        if (localB->PRNsE1E5a_size != 0) {
          localB->SVID_DIMS1_pt = localDW->GalileoE1stream.SVID_DIMS1;
          localB->SVID_DIMS1_f = localDW->GalileoE5astream.SVID_DIMS1;
          DDRTCM_calcCorrection(localB->rtb_BusConversion_InsertedFo__l,
                                localB->GalileoE1stream.PRN,
                                &localB->SVID_DIMS1_pt,
                                localB->GalileoE5astream.sf_TimeCorrectionPseudorange.pseudorangeCorrected,
                                localB->GalileoE5astream.PRN,
                                &localB->SVID_DIMS1_f,
                                localB->rtb_BusConversion_InsertedFo__j,
                                &localB->iia_size, localB);
          localDW->SFunction_DIMS3 = localB->iia_size;
          localB->idx = localB->iia_size;
          if (localB->idx - 1 >= 0) {
            std::memcpy(&localB->dualFrequencyCorrection[0],
                        &localB->rtb_BusConversion_InsertedFo__j[0],
                        static_cast<uint32_T>(localB->idx) * sizeof(real_T));
          }
        } else {
          localDW->SFunction_DIMS3 =
            localDW->BusConversion_InsertedFor_Calcu.pseudorange;
          localB->idx = localDW->BusConversion_InsertedFor_Calcu.pseudorange;
          localB->i = (localDW->BusConversion_InsertedFor_Calcu.pseudorange / 2)
            << 1;
          localB->vectorUB = localB->i - 2;
          for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii += 2)
          {
            tmp_1 = _mm_loadu_pd(&localB->rtb_BusConversion_InsertedFo__l
                                 [localB->ii]);
            _mm_storeu_pd(&localB->dualFrequencyCorrection[localB->ii],
                          _mm_mul_pd(_mm_set1_pd(0.0), tmp_1));
          }

          for (localB->ii = localB->i; localB->ii < localB->idx; localB->ii++) {
            localB->dualFrequencyCorrection[localB->ii] = 0.0 *
              localB->rtb_BusConversion_InsertedFo__l[localB->ii];
          }
        }

        if (localB->PRNsE5E1_size != 0) {
          DDRTCM_do_vectors_k(localB->PRNsE1E5a_data, &localB->PRNsE1E5a_size,
                              localB->rtb_BusConversion_InsertedFo_oj,
                              &localB->PRNsE5E1_size,
                              localB->PRNsE1E5aE1E5b_intersect_data,
                              &localB->SVID_DIMS1, localB->iia_data,
                              &localB->iia_size, localB->iib_data,
                              &localB->iib_size, localB);
          localB->vectorUB = localB->PRNsE5E1_size;
          localB->idx = localB->SVID_DIMS1;
          for (localB->i = 0; localB->i < localB->vectorUB; localB->i++) {
            localB->PRNsE5E1 = localB->rtb_BusConversion_InsertedFo_oj[localB->i];
            localB->PRNsE1E5aE1E5b_intersect_size = localB->SVID_DIMS1;
            for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
              localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii] =
                (localB->PRNsE1E5aE1E5b_intersect_data[localB->ii] ==
                 localB->PRNsE5E1);
            }

            if (!DDRTCM_any_dd(localB->PRNsE1E5aE1E5b_intersect_data_p,
                               &localB->PRNsE1E5aE1E5b_intersect_size)) {
              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                localB->mask_all_data[localB->ii] = (localB->
                  GalileoE1stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii] =
                  (localB->GalileoE1stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE5bstream.SVID_DIMS1; localB->ii++) {
                localB->g_data_m[localB->ii] = (localB->
                  GalileoE5bstream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE5bstream.SVID_DIMS1; localB->ii++) {
                localB->h_data_h3[localB->ii] = (localB->
                  GalileoE5bstream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              localB->end = localDW->GalileoE1stream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->mask_all_data[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->j_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->mask_all_data[localB->ii]) {
                  localB->j_data[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              localB->end = localDW->GalileoE1stream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->k_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii]) {
                  localB->k_data_f[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              localB->end = localDW->GalileoE5bstream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->g_data_m[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->l_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->g_data_m[localB->ii]) {
                  localB->l_data_i[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              localB->end = localDW->GalileoE5bstream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->h_data_h3[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->m_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->h_data_h3[localB->ii]) {
                  localB->m_data[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              for (localB->ii = 0; localB->ii < localB->j_size_idx_0; localB->ii
                   ++) {
                localB->rtb_BusConversion_InsertedFo__d[localB->ii] =
                  localB->rtb_BusConversion_InsertedFo__l[localB->j_data
                  [localB->ii] - 1];
              }

              localB->tmp_size_af = localB->k_size_idx_0;
              for (localB->ii = 0; localB->ii < localB->k_size_idx_0; localB->ii
                   ++) {
                localB->tmp_data_o[localB->ii] = localB->
                  GalileoE1stream.PRN[localB->k_data_f[localB->ii] - 1];
              }

              for (localB->ii = 0; localB->ii < localB->l_size_idx_0; localB->ii
                   ++) {
                localB->rtb_BusConversion_InsertedFo__g[localB->ii] =
                  localB->GalileoE5bstream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
                  [localB->l_data_i[localB->ii] - 1];
              }

              localB->tmp_size_p = localB->m_size_idx_0;
              for (localB->ii = 0; localB->ii < localB->m_size_idx_0; localB->ii
                   ++) {
                localB->tmp_data_i[localB->ii] = localB->
                  GalileoE5bstream.PRN[localB->m_data[localB->ii] - 1];
              }

              DDRTCM_calcCorrection_c(localB->rtb_BusConversion_InsertedFo__d,
                localB->tmp_data_o, &localB->tmp_size_af,
                localB->rtb_BusConversion_InsertedFo__g, localB->tmp_data_i,
                &localB->tmp_size_p, localB->rtb_BusConversion_InsertedFo__j,
                &localB->iia_size, localB);
              localB->mask_all_size = localDW->GalileoE1stream.SVID_DIMS1;
              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                localB->mask_all_data[localB->ii] = (localB->
                  GalileoE1stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                if (localB->mask_all_data[localB->ii]) {
                  localB->dualFrequencyCorrection[localB->ii] =
                    localB->rtb_BusConversion_InsertedFo__j[localB->trueCount];
                  localB->trueCount++;
                }
              }
            }
          }
        }

        if (localB->SVID_DIMS1_o != 0) {
          DDRTCM_do_vectors_k(localB->PRNsE1E5a_data, &localB->PRNsE1E5a_size,
                              localB->PRNsE1E5_data, &localB->SVID_DIMS1_o,
                              localB->rtb_BusConversion_InsertedFo_oj,
                              &localB->PRNsE5E1_size, localB->iia_data,
                              &localB->iia_size, localB->iib_data,
                              &localB->iib_size, localB);
          localB->vectorUB = localB->SVID_DIMS1_o;
          localB->idx = localB->PRNsE5E1_size;
          for (localB->i = 0; localB->i < localB->vectorUB; localB->i++) {
            localB->PRNsE5E1 = localB->PRNsE1E5_data[localB->i];
            localB->PRNsE1E5aE1E5b_intersect_size = localB->PRNsE5E1_size;
            for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
              localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii] =
                (localB->rtb_BusConversion_InsertedFo_oj[localB->ii] ==
                 localB->PRNsE5E1);
            }

            if (!DDRTCM_any_dd(localB->PRNsE1E5aE1E5b_intersect_data_p,
                               &localB->PRNsE1E5aE1E5b_intersect_size)) {
              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                localB->mask_all_data[localB->ii] = (localB->
                  GalileoE1stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii] =
                  (localB->GalileoE1stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE5stream.SVID_DIMS1; localB->ii++) {
                localB->g_data_m[localB->ii] = (localB->
                  GalileoE5stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE5stream.SVID_DIMS1; localB->ii++) {
                localB->h_data_h3[localB->ii] = (localB->
                  GalileoE5stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              localB->end = localDW->GalileoE1stream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->mask_all_data[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->l_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->mask_all_data[localB->ii]) {
                  localB->n_data[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              localB->end = localDW->GalileoE1stream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->m_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii]) {
                  localB->o_data[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              localB->end = localDW->GalileoE5stream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->g_data_m[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->j_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->g_data_m[localB->ii]) {
                  localB->p_data[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              localB->end = localDW->GalileoE5stream.SVID_DIMS1 - 1;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->h_data_h3[localB->ii]) {
                  localB->trueCount++;
                }
              }

              localB->k_size_idx_0 = localB->trueCount;
              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <= localB->end; localB->ii++) {
                if (localB->h_data_h3[localB->ii]) {
                  localB->q_data[localB->trueCount] = static_cast<int8_T>
                    (localB->ii + 1);
                  localB->trueCount++;
                }
              }

              for (localB->ii = 0; localB->ii < localB->l_size_idx_0; localB->ii
                   ++) {
                localB->rtb_BusConversion_InsertedFo__d[localB->ii] =
                  localB->rtb_BusConversion_InsertedFo__l[localB->n_data
                  [localB->ii] - 1];
              }

              localB->tmp_size_af = localB->m_size_idx_0;
              for (localB->ii = 0; localB->ii < localB->m_size_idx_0; localB->ii
                   ++) {
                localB->tmp_data_o[localB->ii] = localB->
                  GalileoE1stream.PRN[localB->o_data[localB->ii] - 1];
              }

              for (localB->ii = 0; localB->ii < localB->j_size_idx_0; localB->ii
                   ++) {
                localB->rtb_BusConversion_InsertedFo__g[localB->ii] =
                  localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
                  [localB->p_data[localB->ii] - 1];
              }

              localB->tmp_size_p = localB->k_size_idx_0;
              for (localB->ii = 0; localB->ii < localB->k_size_idx_0; localB->ii
                   ++) {
                localB->tmp_data_i[localB->ii] = localB->
                  GalileoE5stream.PRN[localB->q_data[localB->ii] - 1];
              }

              DDRTCM_calcCorrection_cz(localB->rtb_BusConversion_InsertedFo__d,
                localB->tmp_data_o, &localB->tmp_size_af,
                localB->rtb_BusConversion_InsertedFo__g, localB->tmp_data_i,
                &localB->tmp_size_p, localB->rtb_BusConversion_InsertedFo__j,
                &localB->iia_size, localB);
              localB->mask_all_size = localDW->GalileoE1stream.SVID_DIMS1;
              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                localB->mask_all_data[localB->ii] = (localB->
                  GalileoE1stream.PRN[localB->ii] == localB->PRNsE5E1);
              }

              localB->trueCount = 0;
              for (localB->ii = 0; localB->ii <
                   localDW->GalileoE1stream.SVID_DIMS1; localB->ii++) {
                if (localB->mask_all_data[localB->ii]) {
                  localB->dualFrequencyCorrection[localB->ii] =
                    localB->rtb_BusConversion_InsertedFo__j[localB->trueCount];
                  localB->trueCount++;
                }
              }
            }
          }
        }
      } else {
        localDW->SFunction_DIMS2_h = localDW->BusConversion_InsertedFor_Cal_d;

        // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
        //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'

        localB->measurementFrequencyCorre_o.time_receive =
          localB->GalileoE5stream.TOW;
        localB->measurementFrequencyCorre_o.base_position[0] =
          localB->GalileoE5stream.basePosition[0];
        localB->measurementFrequencyCorre_o.base_position[1] =
          localB->GalileoE5stream.basePosition[1];
        localB->measurementFrequencyCorre_o.base_position[2] =
          localB->GalileoE5stream.basePosition[2];
        localB->SVID_DIMS1 = localDW->GalileoE5stream.SVID_DIMS1;
        localB->SVID_DIMS1_m = localDW->GalileoE1stream.SVID_DIMS1;
        DDRTCM_do_vectors_k(localB->GalileoE5stream.PRN, &localB->SVID_DIMS1,
                            localB->GalileoE1stream.PRN, &localB->SVID_DIMS1_m,
                            localB->rtb_BusConversion_InsertedFo_oj,
                            &localB->PRNsE5E1_size, localB->iia_data,
                            &localB->iia_size, localB->iib_data,
                            &localB->iib_size, localB);
        if (localB->PRNsE5E1_size != 0) {
          localB->SVID_DIMS1_o = localDW->GalileoE5stream.SVID_DIMS1;
          localB->SVID_DIMS1_n = localDW->GalileoE1stream.SVID_DIMS1;
          DDRTCM_calcCorrection_czr
            (localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected,
             localB->GalileoE5stream.PRN, &localB->SVID_DIMS1_o,
             localB->rtb_BusConversion_InsertedFo__l,
             localB->GalileoE1stream.PRN, &localB->SVID_DIMS1_n,
             localB->rtb_BusConversion_InsertedFo__j, &localB->iia_size, localB);
          localDW->SFunction_DIMS3 = localB->iia_size;
          localB->idx = localB->iia_size;
          if (localB->idx - 1 >= 0) {
            std::memcpy(&localB->dualFrequencyCorrection[0],
                        &localB->rtb_BusConversion_InsertedFo__j[0],
                        static_cast<uint32_T>(localB->idx) * sizeof(real_T));
          }
        } else {
          localDW->SFunction_DIMS3 =
            localDW->BusConversion_InsertedFor_Cal_d.pseudorange;
          localB->i =
            (localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2
             / 2) << 1;
          localB->vectorUB = localB->i - 2;
          for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii += 2)
          {
            tmp_1 = _mm_loadu_pd
              (&localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
               [localB->ii]);
            _mm_storeu_pd(&localB->dualFrequencyCorrection[localB->ii],
                          _mm_mul_pd(_mm_set1_pd(0.0), tmp_1));
          }

          for (localB->ii = localB->i; localB->ii <
               localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
               localB->ii++) {
            localB->dualFrequencyCorrection[localB->ii] = 0.0 *
              localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
              [localB->ii];
          }
        }
      }
    } else if (!localP->E5_basedProcessing_Value) {
      localDW->SFunction_DIMS2_h = localDW->BusConversion_InsertedFor_Calcu;

      // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
      //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'

      localB->measurementFrequencyCorre_o.time_receive =
        localB->GalileoE1stream.TOW;
      std::memcpy(&localB->rtb_measurementFrequency_Bus_sa[0],
                  &localB->rtb_BusConversion_InsertedFo__c[0], 120U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus__g[0],
                  &localB->rtb_BusConversion_InsertedFo__f[0], 120U * sizeof
                  (real_T));
      std::memcpy(&localB->PRN_n[0], &localB->rtb_BusConversion_InsertedFo_oj[0],
                  40U * sizeof(uint16_T));
      std::memcpy(&localB->Add1_a[0], &localB->rtb_BusConversion_InsertedFo__l[0],
                  40U * sizeof(real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_ps[0],
                  &localB->dualFrequencyCorrection[0], 40U * sizeof(real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_de[0],
                  &localB->rtb_BusConversion_InsertedFo__j[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus__b[0],
                  &localB->rtb_BusConversion_InsertedFo__d[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus__d[0],
                  &localB->rtb_BusConversion_InsertedFo__g[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_va[0],
                  &localB->rtb_BusConversion_InsertedFo_ld[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_bj[0],
                  &localB->rtb_BusConversion_InsertedFo_dh[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus__j[0],
                  &localB->rtb_BusConversion_InsertedFo_dy[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_ca[0],
                  &localB->rtb_BusConversion_InsertedFo_lx[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus__a[0],
                  &localB->rtb_BusConversion_InsertedFo__o[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_ju[0],
                  &localB->rtb_BusConversion_InsertedFo__b[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_jz[0],
                  &localB->rtb_BusConversion_InsertedFo__n[0], 40U * sizeof
                  (real_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_lo[0],
                  &localB->rtb_BusConversion_InsertedFo_nv[0], 40U * sizeof
                  (real32_T));
      std::memcpy(&localB->rtb_measurementFrequency_Bus_CN[0],
                  &localB->rtb_BusConversion_InsertedFo_bs[0], 40U * sizeof
                  (real_T));

      // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
      //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'

      localB->measurementFrequencyCorre_o.base_position[0] =
        localB->GalileoE1stream.basePosition[0];
      localB->measurementFrequencyCorre_o.base_position[1] =
        localB->GalileoE1stream.basePosition[1];
      localB->measurementFrequencyCorre_o.base_position[2] =
        localB->GalileoE1stream.basePosition[2];
      localDW->SFunction_DIMS3 =
        localDW->BusConversion_InsertedFor_Calcu.pseudorange;
      localB->idx = localDW->BusConversion_InsertedFor_Calcu.pseudorange;
      localB->i = (localDW->BusConversion_InsertedFor_Calcu.pseudorange / 2) <<
        1;
      localB->vectorUB = localB->i - 2;
      for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii += 2) {
        tmp_1 = _mm_loadu_pd(&localB->rtb_BusConversion_InsertedFo__l[localB->ii]);
        _mm_storeu_pd(&localB->dualFrequencyCorrection[localB->ii], _mm_mul_pd
                      (_mm_set1_pd(0.0), tmp_1));
      }

      for (localB->ii = localB->i; localB->ii < localB->idx; localB->ii++) {
        localB->dualFrequencyCorrection[localB->ii] = 0.0 *
          localB->rtb_BusConversion_InsertedFo__l[localB->ii];
      }
    } else {
      localDW->SFunction_DIMS2_h = localDW->BusConversion_InsertedFor_Cal_d;

      // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
      //   BusCreator generated from: '<S112>/Calculate Dualfrequency Correction with E1 and E5'

      localB->measurementFrequencyCorre_o.time_receive =
        localB->GalileoE5stream.TOW;
      localB->measurementFrequencyCorre_o.base_position[0] =
        localB->GalileoE5stream.basePosition[0];
      localB->measurementFrequencyCorre_o.base_position[1] =
        localB->GalileoE5stream.basePosition[1];
      localB->measurementFrequencyCorre_o.base_position[2] =
        localB->GalileoE5stream.basePosition[2];
      localDW->SFunction_DIMS3 =
        localDW->BusConversion_InsertedFor_Cal_d.pseudorange;
      localB->i =
        (localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2 /
         2) << 1;
      localB->vectorUB = localB->i - 2;
      for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii += 2) {
        tmp_1 = _mm_loadu_pd
          (&localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
           [localB->ii]);
        _mm_storeu_pd(&localB->dualFrequencyCorrection[localB->ii], _mm_mul_pd
                      (_mm_set1_pd(0.0), tmp_1));
      }

      for (localB->ii = localB->i; localB->ii <
           localDW->GalileoE5stream.sf_TimeCorrectionPseudorange.SFunction_DIMS2;
           localB->ii++) {
        localB->dualFrequencyCorrection[localB->ii] = 0.0 *
          localB->GalileoE5stream.sf_TimeCorrectionPseudorange.pseudorangeCorrected
          [localB->ii];
      }
    }

    // End of MATLAB Function: '<S112>/Calculate Dualfrequency Correction with E1 and E5' 

    // BusSelector: '<S112>/Bus Selector1'
    localDW->BusSelector1_DIMS1 = localDW->SFunction_DIMS2_h.pseudorange;

    // BusAssignment: '<S112>/Bus Assignment2'
    localDW->BusAssignment2_DIMS1 = localDW->SFunction_DIMS2_h;
    localDW->BusAssignment2_DIMS1.pseudorange = localDW->BusSelector1_DIMS1;

    // SignalConversion generated from: '<S75>/Bus Assignment1'
    localDW->TmpHiddenBufferAtBusAssignment1 = localDW->BusAssignment2_DIMS1;

    // MATLAB Function: '<S75>/Calculate Tropospheric Corrections' incorporates:
    //   Logic: '<S69>/Logical Operator2'

    CalculateTroposphericCorrecti_l(rtu_dayOfYear, rtu_parameters_gnss_Bus_o4 &&
      localB->LogicalOperator_k, rtu_userPos_LLH,
      localB->sf_CreateSatelliteElevationMask.elevationAngle,
      &localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS3,
      &localB->sf_CalculateTroposphericCorrect,
      &localDW->sf_CalculateTroposphericCorrect);

    // BusSelector: '<S75>/Bus Selector'
    localDW->BusSelector_DIMS1 = localDW->BusAssignment2_DIMS1.pseudorange;

    // BusSelector: '<S112>/Bus Selector1' incorporates:
    //   Sum: '<S75>/Add1'

    localB->idx = localDW->SFunction_DIMS2_h.pseudorange - 1;
    localB->i = (localDW->SFunction_DIMS2_h.pseudorange / 2) << 1;
    localB->vectorUB = localB->i - 2;

    // Sum: '<S75>/Add1' incorporates:
    //   BusSelector: '<S112>/Bus Selector1'
    //   Sum: '<S112>/Add1'

    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii += 2) {
      __m128d tmp;
      __m128d tmp_0;
      tmp_1 = _mm_loadu_pd(&localB->Add1_a[localB->ii]);
      tmp = _mm_loadu_pd(&localB->dualFrequencyCorrection[localB->ii]);
      tmp_0 = _mm_loadu_pd
        (&localB->sf_CalculateTroposphericCorrect.troposphericDelay[localB->ii]);
      _mm_storeu_pd(&localB->Add1_a[localB->ii], _mm_sub_pd(_mm_sub_pd(tmp_1,
        tmp), tmp_0));
    }

    for (localB->ii = localB->i; localB->ii <= localB->idx; localB->ii++) {
      localB->Add1_a[localB->ii] = (localB->Add1_a[localB->ii] -
        localB->dualFrequencyCorrection[localB->ii]) -
        localB->sf_CalculateTroposphericCorrect.troposphericDelay[localB->ii];
    }

    // BusAssignment: '<S75>/Bus Assignment1'
    localDW->BusAssignment1_DIMS1 = localDW->TmpHiddenBufferAtBusAssignment1;
    localDW->BusAssignment1_DIMS1.pseudorange = localDW->BusSelector_DIMS1;

    // MATLAB Function: '<S116>/Apply Elevation and NaN and Zero Mask' incorporates:
    //   BusAssignment: '<S112>/Bus Assignment2'
    //   BusAssignment: '<S75>/Bus Assignment1'
    //   Sum: '<S75>/Add1'

    localB->tmp_size[0] = localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->tmp_size[1] = localDW->BusAssignment1_DIMS1.satellite_position[1];
    localB->vectorUB = localDW->BusAssignment1_DIMS1.satellite_position[0] *
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->tmp_data[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii]);
    }

    localB->tmp_size_a[0] = localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->tmp_size_a[1] = localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    localB->end = localDW->BusAssignment1_DIMS1.satellite_velocity[0] *
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->tmp_data_a[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus__g[localB->ii]);
    }

    localB->tmp_size_g[0] = localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->tmp_size_g[1] = localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->tmp_data_e[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii]);
    }

    DDRTCM_any_jr(localB->tmp_data_e, localB->tmp_size_g,
                  localB->PRNsE1E5aE1E5b_intersect_data_p,
                  &localB->PRNsE1E5aE1E5b_intersect_size);
    localB->tmp_size_g[0] = localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->tmp_size_g[1] = localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->tmp_data_e[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus__g[localB->ii]);
    }

    localB->g_size = localDW->BusSelector_DIMS1;
    for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
    {
      localB->g_data_m[localB->ii] = std::isnan(localB->Add1_a[localB->ii]);
    }

    localB->rtb_measurementFrequency_Bus_ei[0] =
      localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->rtb_measurementFrequency_Bus_ei[1] =
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__l[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii]);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__l,
                  localB->rtb_measurementFrequency_Bus_ei, localB->h_data_h3,
                  &localB->PRNsE5E1_size);
    localB->rtb_measurementFrequency_Bus_ei[0] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->rtb_measurementFrequency_Bus_ei[1] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__l[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus__g[localB->ii]);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__l,
                  localB->rtb_measurementFrequency_Bus_ei, localB->tmp_data_c,
                  &localB->tmp_size_af);
    localB->tmp_size_c = localDW->BusSelector_DIMS1;
    for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
    {
      localB->tmp_data_p[localB->ii] = std::isnan(localB->Add1_a[localB->ii]);
    }

    localB->rtb_measurementFrequency_Bus__e[0] =
      localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->rtb_measurementFrequency_Bus__e[1] =
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->rtb_measurementFrequency_Bus_ax[localB->ii] =
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii] == 0.0);
    }

    localB->rtb_measurementFrequency_Bus__f[0] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->rtb_measurementFrequency_Bus__f[1] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->rtb_measurementFrequency_Bus_as[localB->ii] =
        (localB->rtb_measurementFrequency_Bus__g[localB->ii] == 0.0);
    }

    localB->rtb_measurementFrequency_Bus__h[0] =
      localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->rtb_measurementFrequency_Bus__h[1] =
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__i[localB->ii] =
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii] == 0.0);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__i,
                  localB->rtb_measurementFrequency_Bus__h, localB->tmp_data_k,
                  &localB->SVID_DIMS1_m);
    localB->rtb_measurementFrequency_Bus__h[0] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->rtb_measurementFrequency_Bus__h[1] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__i[localB->ii] =
        (localB->rtb_measurementFrequency_Bus__g[localB->ii] == 0.0);
    }

    localB->rtb_Add1_a_size = localDW->BusSelector_DIMS1;
    for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
    {
      localB->rtb_Add1_a_data[localB->ii] = (localB->Add1_a[localB->ii] < 1.0E+6);
    }

    localB->rtb_measurementFrequency_Bus_ei[0] =
      localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->rtb_measurementFrequency_Bus_ei[1] =
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__l[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii]);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__l,
                  localB->rtb_measurementFrequency_Bus_ei, localB->tmp_data_c,
                  &localB->tmp_size_p);
    localB->rtb_measurementFrequency_Bus_ei[0] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->rtb_measurementFrequency_Bus_ei[1] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__l[localB->ii] = std::isnan
        (localB->rtb_measurementFrequency_Bus__g[localB->ii]);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__l,
                  localB->rtb_measurementFrequency_Bus_ei, localB->tmp_data_c,
                  &localB->PRNsE1E5a_size);
    localB->tmp_size_ax = localDW->BusSelector_DIMS1;
    for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
    {
      localB->tmp_data_c[localB->ii] = std::isnan(localB->Add1_a[localB->ii]);
    }

    localB->rtb_measurementFrequency_Bus_ei[0] =
      localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->rtb_measurementFrequency_Bus_ei[1] =
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__l[localB->ii] =
        (localB->rtb_measurementFrequency_Bus_sa[localB->ii] == 0.0);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__l,
                  localB->rtb_measurementFrequency_Bus_ei, localB->tmp_data_k,
                  &localB->SVID_DIMS1_p);
    localB->rtb_measurementFrequency_Bus_ei[0] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->rtb_measurementFrequency_Bus_ei[1] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
      localB->rtb_measurementFrequency_Bus__l[localB->ii] =
        (localB->rtb_measurementFrequency_Bus__g[localB->ii] == 0.0);
    }

    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__l,
                  localB->rtb_measurementFrequency_Bus_ei, localB->tmp_data_k,
                  &localB->iia_size);
    localB->rtb_Add1_a_size_d = localDW->BusSelector_DIMS1;
    for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
    {
      localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii] = (localB->
        Add1_a[localB->ii] < 1.0E+6);
    }

    DDRTCM_any_jr(localB->tmp_data, localB->tmp_size, localB->tmp_data_k,
                  &localB->iib_size);
    DDRTCM_any_jr(localB->tmp_data_a, localB->tmp_size_a, localB->tmp_data_k,
                  &localB->SVID_DIMS1);
    DDRTCM_any_jr(localB->tmp_data_e, localB->tmp_size_g, localB->tmp_data_k,
                  &localB->BusConversion_InsertedFor_Calcu);
    DDRTCM_any_jr1(localB->g_data_m, &localB->g_size, localB->tmp_data_k,
                   &localB->SVID_DIMS1_pt, localB);
    DDRTCM_any_jr1(localB->tmp_data_p, &localB->tmp_size_c, localB->tmp_data_k,
                   &localB->g_size, localB);
    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus_ax,
                  localB->rtb_measurementFrequency_Bus__e, localB->tmp_data_p,
                  &localB->tmp_size_c);
    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus_as,
                  localB->rtb_measurementFrequency_Bus__f, localB->tmp_data_p,
                  &localB->SVID_DIMS1_f);
    DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus__i,
                  localB->rtb_measurementFrequency_Bus__h, localB->tmp_data_p,
                  &localB->SVID_DIMS1_o);
    DDRTCM_any_jr1(localB->rtb_Add1_a_data, &localB->rtb_Add1_a_size,
                   localB->tmp_data_p, &localB->SVID_DIMS1_n, localB);
    DDRTCM_any_jr1(localB->tmp_data_c, &localB->tmp_size_ax, localB->tmp_data_p,
                   &localB->SVID_DIMS1_l, localB);
    DDRTCM_any_jr1(localB->PRNsE1E5aE1E5b_intersect_data_p,
                   &localB->rtb_Add1_a_size_d, localB->tmp_data_c,
                   &localB->tmp_size_ax, localB);
    if ((localB->iib_size == localB->SVID_DIMS1) &&
        ((localB->PRNsE1E5aE1E5b_intersect_size == 1 ?
          localB->BusConversion_InsertedFor_Calcu :
          localB->PRNsE1E5aE1E5b_intersect_size) == localB->SVID_DIMS1_pt) &&
        (((localB->PRNsE5E1_size == 1 ? localB->tmp_size_af :
           localB->PRNsE5E1_size) == 1 ? localB->g_size : localB->PRNsE5E1_size ==
          1 ? localB->tmp_size_af : localB->PRNsE5E1_size) ==
         localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2) &&
        (localB->tmp_size_c == localB->SVID_DIMS1_f) && ((localB->SVID_DIMS1_m ==
          1 ? localB->SVID_DIMS1_o : localB->SVID_DIMS1_m) ==
         localB->SVID_DIMS1_n) &&
        ((localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2 == 1 ?
          (localB->tmp_size_p == 1 ? localB->PRNsE1E5a_size : localB->tmp_size_p)
          == 1 ? localB->SVID_DIMS1_l : localB->tmp_size_p == 1 ?
          localB->PRNsE1E5a_size : localB->tmp_size_p :
          localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2) ==
         ((localB->SVID_DIMS1_p == 1 ? localB->iia_size : localB->SVID_DIMS1_p) ==
          1 ? localB->tmp_size_ax : localB->SVID_DIMS1_p == 1 ? localB->iia_size
          : localB->SVID_DIMS1_p))) {
      localB->tmp_size[0] = localDW->BusAssignment1_DIMS1.satellite_position[0];
      localB->tmp_size[1] = localDW->BusAssignment1_DIMS1.satellite_position[1];
      for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
        localB->tmp_data[localB->ii] = std::isnan
          (localB->rtb_measurementFrequency_Bus_sa[localB->ii]);
      }

      DDRTCM_any_jr(localB->tmp_data, localB->tmp_size,
                    localB->PRNsE1E5aE1E5b_intersect_data_p,
                    &localB->PRNsE1E5aE1E5b_intersect_size);
      localB->tmp_size[0] = localDW->BusAssignment1_DIMS1.satellite_velocity[0];
      localB->tmp_size[1] = localDW->BusAssignment1_DIMS1.satellite_velocity[1];
      for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
        localB->tmp_data[localB->ii] = std::isnan
          (localB->rtb_measurementFrequency_Bus__g[localB->ii]);
      }

      DDRTCM_any_jr(localB->tmp_data, localB->tmp_size, localB->g_data_m,
                    &localB->g_size);
      localB->PRNsE5E1_size = localDW->BusSelector_DIMS1;
      for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
      {
        localB->h_data_h3[localB->ii] = std::isnan(localB->Add1_a[localB->ii]);
      }

      DDRTCM_any_jr1(localB->h_data_h3, &localB->PRNsE5E1_size,
                     localB->tmp_data_c, &localB->tmp_size_af, localB);
      localB->rtb_measurementFrequency_Bus__e[0] =
        localDW->BusAssignment1_DIMS1.satellite_position[0];
      localB->rtb_measurementFrequency_Bus__e[1] =
        localDW->BusAssignment1_DIMS1.satellite_position[1];
      for (localB->ii = 0; localB->ii < localB->vectorUB; localB->ii++) {
        localB->rtb_measurementFrequency_Bus_ax[localB->ii] =
          (localB->rtb_measurementFrequency_Bus_sa[localB->ii] == 0.0);
      }

      DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus_ax,
                    localB->rtb_measurementFrequency_Bus__e, localB->h_data_h3,
                    &localB->PRNsE5E1_size);
      localB->rtb_measurementFrequency_Bus__e[0] =
        localDW->BusAssignment1_DIMS1.satellite_velocity[0];
      localB->rtb_measurementFrequency_Bus__e[1] =
        localDW->BusAssignment1_DIMS1.satellite_velocity[1];
      for (localB->ii = 0; localB->ii < localB->end; localB->ii++) {
        localB->rtb_measurementFrequency_Bus_ax[localB->ii] =
          (localB->rtb_measurementFrequency_Bus__g[localB->ii] == 0.0);
      }

      DDRTCM_any_jr(localB->rtb_measurementFrequency_Bus_ax,
                    localB->rtb_measurementFrequency_Bus__e, localB->tmp_data_p,
                    &localB->tmp_size_c);
      localB->rtb_Add1_a_size = localDW->BusSelector_DIMS1;
      for (localB->ii = 0; localB->ii < localDW->BusSelector_DIMS1; localB->ii++)
      {
        localB->rtb_Add1_a_data[localB->ii] = (localB->Add1_a[localB->ii] <
          1.0E+6);
      }

      DDRTCM_any_jr1(localB->rtb_Add1_a_data, &localB->rtb_Add1_a_size,
                     localB->tmp_data_k, &localB->SVID_DIMS1_m, localB);
      localB->mask_all_size =
        localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2;
      for (localB->ii = 0; localB->ii <
           localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2; localB->ii
           ++) {
        localB->mask_all_data[localB->ii] =
          (localB->sf_CreateSatelliteElevationMask.elevationMask[localB->ii] &&
           ((!localB->PRNsE1E5aE1E5b_intersect_data_p[localB->ii]) &&
            (!localB->g_data_m[localB->ii]) && (!localB->tmp_data_c[localB->ii]))
           && ((!localB->h_data_h3[localB->ii]) && (!localB->tmp_data_p
             [localB->ii]) && (!localB->tmp_data_k[localB->ii])));
      }
    } else {
      DDRTCM_binary_expand_op_nb(localB->mask_all_data, &localB->mask_all_size,
        localB->sf_CreateSatelliteElevationMask.elevationMask,
        localDW->sf_CreateSatelliteElevationMask.SFunction_DIMS2,
        localB->rtb_measurementFrequency_Bus_sa, &localDW->BusAssignment1_DIMS1,
        localB->rtb_measurementFrequency_Bus__g, localB->Add1_a,
        localDW->BusSelector_DIMS1, localB);
    }

    localB->vectorUB = localB->mask_all_size - 1;
    localB->trueCount = 0;
    for (localB->i = 0; localB->i <= localB->vectorUB; localB->i++) {
      if (localB->mask_all_data[localB->i]) {
        localB->trueCount++;
      }
    }

    localB->end = localB->trueCount;
    localB->trueCount = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->b_data[localB->trueCount] = static_cast<int8_T>(localB->idx + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.satellite_position[0] = localB->end;
    localDW->SFunction_DIMS2.satellite_position[1] =
      localDW->BusAssignment1_DIMS1.satellite_position[1];
    localB->trueCount = localDW->BusAssignment1_DIMS1.satellite_position[0];
    localB->l_size_idx_0 = localDW->SFunction_DIMS2.satellite_position[0];
    localB->idx = localDW->BusAssignment1_DIMS1.satellite_position[1];
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      for (localB->i = 0; localB->i < localB->end; localB->i++) {
        localB->measurementFrequencyCorre_o.satellite_position[localB->i +
          localB->l_size_idx_0 * localB->ii] =
          localB->rtb_measurementFrequency_Bus_sa[(localB->trueCount *
          localB->ii + localB->b_data[localB->i]) - 1];
      }
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->end = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->c_data[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.satellite_velocity[0] = localB->end;
    localDW->SFunction_DIMS2.satellite_velocity[1] =
      localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    localB->trueCount = localDW->BusAssignment1_DIMS1.satellite_velocity[0];
    localB->l_size_idx_0 = localDW->SFunction_DIMS2.satellite_velocity[0];
    localB->idx = localDW->BusAssignment1_DIMS1.satellite_velocity[1];
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      for (localB->i = 0; localB->i < localB->end; localB->i++) {
        localB->measurementFrequencyCorre_o.satellite_velocity[localB->i +
          localB->l_size_idx_0 * localB->ii] =
          localB->rtb_measurementFrequency_Bus__g[(localB->trueCount *
          localB->ii + localB->c_data[localB->i]) - 1];
      }
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->idx = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->d_data[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.PRN = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.PRN[localB->ii] = localB->PRN_n
        [localB->d_data[localB->ii] - 1];
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->idx = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->e_data[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.pseudorange = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.pseudorange[localB->ii] =
        localB->Add1_a[localB->e_data[localB->ii] - 1];
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->idx = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->f_data[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.pseudorange_raw = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.pseudorange_raw[localB->ii] =
        localB->rtb_measurementFrequency_Bus_ps[localB->f_data[localB->ii] - 1];
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->idx = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->g_data_f[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.pseudorange_satclk_corrected = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.pseudorange_satclk_corrected
        [localB->ii] = localB->Add1_a[localB->g_data_f[localB->ii] - 1];
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->idx = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->h_data_g[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.deltarange = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.deltarange[localB->ii] =
        localB->rtb_measurementFrequency_Bus_de[localB->h_data_g[localB->ii] - 1];
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->trueCount++;
      }
    }

    localB->idx = localB->trueCount;
    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->i_data[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.deltarange_raw = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.deltarange_raw[localB->ii] =
        localB->rtb_measurementFrequency_Bus__b[localB->i_data[localB->ii] - 1];
    }

    localB->idx = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->idx++;
      }
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->j_data_c[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.deltarange_satclk_corrected = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.deltarange_satclk_corrected[localB->ii]
        = localB->rtb_measurementFrequency_Bus__d[localB->j_data_c[localB->ii] -
        1];
    }

    localB->idx = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->idx++;
      }
    }

    localB->trueCount = 0;
    for (localB->ii = 0; localB->ii <= localB->vectorUB; localB->ii++) {
      if (localB->mask_all_data[localB->ii]) {
        localB->k_data_o[localB->trueCount] = static_cast<int8_T>(localB->ii + 1);
        localB->trueCount++;
      }
    }

    localDW->SFunction_DIMS2.variance_pseudorange = localB->idx;
    for (localB->ii = 0; localB->ii < localB->idx; localB->ii++) {
      localB->measurementFrequencyCorre_o.variance_pseudorange[localB->ii] =
        localB->rtb_measurementFrequency_Bus_va[localB->k_data_o[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->l_size_idx_0 = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->l_data_l[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.variance_pseudorange_measured =
      localB->l_size_idx_0;
    for (localB->ii = 0; localB->ii < localB->l_size_idx_0; localB->ii++) {
      localB->measurementFrequencyCorre_o.variance_pseudorange_measured
        [localB->ii] = localB->rtb_measurementFrequency_Bus_bj[localB->
        l_data_l[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->m_size_idx_0 = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->m_data_m[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.variance_deltarange = localB->m_size_idx_0;
    for (localB->ii = 0; localB->ii < localB->m_size_idx_0; localB->ii++) {
      localB->measurementFrequencyCorre_o.variance_deltarange[localB->ii] =
        localB->rtb_measurementFrequency_Bus__j[localB->m_data_m[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->l_size_idx_0 = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->n_data_m[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.carrierphase = localB->l_size_idx_0;
    for (localB->ii = 0; localB->ii < localB->l_size_idx_0; localB->ii++) {
      localB->measurementFrequencyCorre_o.carrierphase[localB->ii] =
        localB->rtb_measurementFrequency_Bus_ca[localB->n_data_m[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->m_size_idx_0 = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->o_data_c[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.carrierphase_raw = localB->m_size_idx_0;
    for (localB->ii = 0; localB->ii < localB->m_size_idx_0; localB->ii++) {
      localB->measurementFrequencyCorre_o.carrierphase_raw[localB->ii] =
        localB->rtb_measurementFrequency_Bus__a[localB->o_data_c[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->j_size_idx_0 = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->p_data_f[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.carrierphase_satclk_corrected =
      localB->j_size_idx_0;
    for (localB->ii = 0; localB->ii < localB->j_size_idx_0; localB->ii++) {
      localB->measurementFrequencyCorre_o.carrierphase_satclk_corrected
        [localB->ii] = localB->rtb_measurementFrequency_Bus_ju[localB->
        p_data_f[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->k_size_idx_0 = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->q_data_p[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.variance_carrierphase_measured =
      localB->k_size_idx_0;
    for (localB->ii = 0; localB->ii < localB->k_size_idx_0; localB->ii++) {
      localB->measurementFrequencyCorre_o.variance_carrierphase_measured
        [localB->ii] = localB->rtb_measurementFrequency_Bus_jz[localB->
        q_data_p[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->trueCount = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->r_data[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.locktime = localB->trueCount;
    for (localB->ii = 0; localB->ii < localB->trueCount; localB->ii++) {
      localB->measurementFrequencyCorre_o.locktime[localB->ii] =
        localB->rtb_measurementFrequency_Bus_lo[localB->r_data[localB->ii] - 1];
    }

    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->i++;
      }
    }

    localB->trueCount = localB->i;
    localB->i = 0;
    for (localB->idx = 0; localB->idx <= localB->vectorUB; localB->idx++) {
      if (localB->mask_all_data[localB->idx]) {
        localB->s_data[localB->i] = static_cast<int8_T>(localB->idx + 1);
        localB->i++;
      }
    }

    localDW->SFunction_DIMS2.CN0 = localB->trueCount;
    for (localB->ii = 0; localB->ii < localB->trueCount; localB->ii++) {
      localB->measurementFrequencyCorre_o.CN0[localB->ii] =
        localB->rtb_measurementFrequency_Bus_CN[localB->s_data[localB->ii] - 1];
    }

    // MATLAB Function: '<S116>/Apply Differential Correction Mask1' incorporates:
    //   BusSelector: '<S75>/Bus Selector2'

    ApplyDifferentialCorrectionMa_j(&localB->measurementFrequencyCorre_o,
      &localDW->SFunction_DIMS2,
      localB->sf_CalculateDifferentialCorrect.diffPseudorangeCorrection,
      localB->sf_CalculateDifferentialCorrect.maskDiffCorr,
      &localDW->sf_CalculateDifferentialCorrect.SFunction_DIMS3,
      rtu_parameters_gnss_Bus_a, rtu_GalMeasurementB->base_position,
      &localB->LogicalOperator_k, &localB->sf_ApplyDifferentialCorrectionM,
      &localDW->sf_ApplyDifferentialCorrectionM);

    // BusSelector: '<S17>/Bus Selector'
    localDW->BusSelector_DIMS2[0] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [0];
    localDW->BusSelector_DIMS2[1] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [1];
    localDW->BusSelector_DIMS3[0] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [0];
    localDW->BusSelector_DIMS3[1] =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [1];
    localB->ii = localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.PRN;
    localDW->BusSelector_DIMS4 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.PRN;
    localB->i =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange;
    localDW->BusSelector_DIMS5 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange;
    localB->vectorUB =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_raw;
    localDW->BusSelector_DIMS6 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_raw;
    localB->trueCount =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_satclk_corrected;
    localDW->BusSelector_DIMS7 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.pseudorange_satclk_corrected;
    localB->end =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange;
    localDW->BusSelector_DIMS8 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange;
    localB->l_size_idx_0 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_raw;
    localDW->BusSelector_DIMS9 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_raw;
    localB->m_size_idx_0 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_satclk_corrected;
    localDW->BusSelector_DIMS10 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.deltarange_satclk_corrected;
    localB->j_size_idx_0 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange;
    localDW->BusSelector_DIMS11 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange;
    localB->k_size_idx_0 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange_measured;
    localDW->BusSelector_DIMS12 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_pseudorange_measured;
    localB->BusSelector_DIMS13_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_deltarange;
    localDW->BusSelector_DIMS13 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_deltarange;
    localB->BusSelector_DIMS14_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase;
    localDW->BusSelector_DIMS14 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase;
    localB->BusSelector_DIMS15_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_raw;
    localDW->BusSelector_DIMS15 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_raw;
    localB->BusSelector_DIMS16_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_satclk_corrected;
    localDW->BusSelector_DIMS16 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.carrierphase_satclk_corrected;
    localB->BusSelector_DIMS17_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_carrierphase_measured;
    localDW->BusSelector_DIMS17 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.variance_carrierphase_measured;
    localB->BusSelector_DIMS18_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.locktime;
    localDW->BusSelector_DIMS18 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.locktime;
    localB->BusSelector_DIMS19_tmp_tmp =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.CN0;
    localDW->BusSelector_DIMS19 =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.CN0;

    // BusSelector: '<S17>/Bus Selector'
    localB->time_receive =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.time_receive;

    // BusSelector: '<S17>/Bus Selector'
    localB->idx =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [0] *
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_position
      [1];
    if (localB->idx - 1 >= 0) {
      std::memcpy(&localB->satellite_position[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.satellite_position
                  [0], static_cast<uint32_T>(localB->idx) * sizeof(real_T));
    }

    localB->idx =
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [0] *
      localDW->sf_ApplyDifferentialCorrectionM.SFunction_DIMS2.satellite_velocity
      [1];
    if (localB->idx - 1 >= 0) {
      std::memcpy(&localB->satellite_velocity[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.satellite_velocity
                  [0], static_cast<uint32_T>(localB->idx) * sizeof(real_T));
    }

    if (localB->ii - 1 >= 0) {
      std::memcpy(&localB->PRN[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.PRN
                  [0], static_cast<uint32_T>(localB->ii) * sizeof(uint16_T));
    }

    if (localB->i - 1 >= 0) {
      std::memcpy(&localB->pseudorange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.pseudorange
                  [0], static_cast<uint32_T>(localB->i) * sizeof(real_T));
    }

    if (localB->vectorUB - 1 >= 0) {
      std::memcpy(&localB->pseudorange_raw[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.pseudorange_raw
                  [0], static_cast<uint32_T>(localB->vectorUB) * sizeof(real_T));
    }

    if (localB->trueCount - 1 >= 0) {
      std::memcpy(&localB->pseudorange_satclk_corrected[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.pseudorange_satclk_corrected
                  [0], static_cast<uint32_T>(localB->trueCount) * sizeof(real_T));
    }

    if (localB->end - 1 >= 0) {
      std::memcpy(&localB->deltarange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.deltarange
                  [0], static_cast<uint32_T>(localB->end) * sizeof(real_T));
    }

    if (localB->l_size_idx_0 - 1 >= 0) {
      std::memcpy(&localB->deltarange_raw[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.deltarange_raw
                  [0], static_cast<uint32_T>(localB->l_size_idx_0) * sizeof
                  (real_T));
    }

    if (localB->m_size_idx_0 - 1 >= 0) {
      std::memcpy(&localB->deltarange_satclk_corrected[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.deltarange_satclk_corrected
                  [0], static_cast<uint32_T>(localB->m_size_idx_0) * sizeof
                  (real_T));
    }

    if (localB->j_size_idx_0 - 1 >= 0) {
      std::memcpy(&localB->variance_pseudorange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_pseudorange
                  [0], static_cast<uint32_T>(localB->j_size_idx_0) * sizeof
                  (real_T));
    }

    if (localB->k_size_idx_0 - 1 >= 0) {
      std::memcpy(&localB->variance_pseudorange_measured[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_pseudorange_measured
                  [0], static_cast<uint32_T>(localB->k_size_idx_0) * sizeof
                  (real_T));
    }

    if (localB->BusSelector_DIMS13_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->variance_deltarange[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_deltarange
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS13_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS14_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->carrierphase[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.carrierphase
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS14_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS15_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->carrierphase_raw[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.carrierphase_raw
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS15_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS16_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->carrierphase_satclk_corrected[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.carrierphase_satclk_corrected
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS16_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS17_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->variance_carrierphase_measured[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.variance_carrierphase_measured
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS17_tmp_tmp)
                  * sizeof(real_T));
    }

    if (localB->BusSelector_DIMS18_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->locktime[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.locktime
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS18_tmp_tmp)
                  * sizeof(real32_T));
    }

    if (localB->BusSelector_DIMS19_tmp_tmp - 1 >= 0) {
      std::memcpy(&localB->CN0[0],
                  &localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.CN0
                  [0], static_cast<uint32_T>(localB->BusSelector_DIMS19_tmp_tmp)
                  * sizeof(real_T));
    }

    // BusSelector: '<S17>/Bus Selector'
    localB->base_position[0] =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.base_position
      [0];
    localB->base_position[1] =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.base_position
      [1];
    localB->base_position[2] =
      localB->sf_ApplyDifferentialCorrectionM.GPS_measurement_Bus_masked.base_position
      [2];

    // BusSelector: '<S112>/Bus Selector'
    localDW->BusSelector_DIMS1_i = localDW->BusAssignment2_DIMS1.PRN;
  }

  // End of Outputs for SubSystem: '<S4>/Galileo'
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = (rtNaN);
  } else if (std::isinf(u0) && std::isinf(u1)) {
    int32_T tmp;
    int32_T tmp_0;
    if (u0 > 0.0) {
      tmp = 1;
    } else {
      tmp = -1;
    }

    if (u1 > 0.0) {
      tmp_0 = 1;
    } else {
      tmp_0 = -1;
    }

    y = std::atan2(static_cast<real_T>(tmp), static_cast<real_T>(tmp_0));
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = std::atan2(u0, u1);
  }

  return y;
}

//
// Output and update for atomic system:
//    '<S18>/CalcDOP'
//    '<S145>/CalcDOP'
//
void DDRTCM::DDRTCM_CalcDOP(const real_T rtu_user_position[3], const
  GNSS_Measurement *rtu_gnssIn_measurement, const GNSS_Measurement_size
  *rtu_gnssIn_measurement_DIMS1, real_T *rty_HDOP, real_T *rty_VDOP,
  B_CalcDOP_DDRTCM_T *localB, DW_CalcDOP_DDRTCM_T *localDW)
{
  int32_T boffset;
  int32_T coffset;
  int32_T kAcol;
  int32_T rtu_gnssIn_measurement_DIMS1_id;
  int8_T ipiv[4];
  int8_T p[4];
  if ((rtu_gnssIn_measurement_DIMS1->satellite_position[0] != 0) &&
      (rtu_gnssIn_measurement_DIMS1->satellite_position[1] != 0) &&
      (rtu_gnssIn_measurement->time_receive != 0.0)) {
    int32_T jBcol;
    int32_T jj;
    int32_T loop_ub;
    int32_T pipk;
    localB->a_tmp = std::cos(rtu_user_position[0]);
    localB->N = 6.3995936257584924E+6 / std::sqrt(localB->a_tmp * localB->a_tmp *
      0.0067394967422761756 + 1.0);
    localB->a_tmp = (localB->N + rtu_user_position[2]) * localB->a_tmp * std::
      cos(rtu_user_position[1]);
    localB->userPosition_idx_1 = (localB->N + rtu_user_position[2]) * std::cos
      (rtu_user_position[0]) * std::sin(rtu_user_position[1]);
    localB->N = (0.99330562000985889 * localB->N + rtu_user_position[2]) * std::
      sin(rtu_user_position[0]);
    jBcol = rtu_gnssIn_measurement_DIMS1->satellite_position[0];
    loop_ub = rtu_gnssIn_measurement_DIMS1->satellite_position[0] << 2;
    if (loop_ub - 1 >= 0) {
      std::memset(&localB->A_data[0], 0, static_cast<uint32_T>(loop_ub) * sizeof
                  (real_T));
    }

    jj = rtu_gnssIn_measurement_DIMS1->satellite_position[0];
    if (rtu_gnssIn_measurement_DIMS1->satellite_position[0] - 1 >= 0) {
      coffset = rtu_gnssIn_measurement_DIMS1->satellite_position[0];
      boffset = rtu_gnssIn_measurement_DIMS1->satellite_position[0];
      kAcol = rtu_gnssIn_measurement_DIMS1->satellite_position[0];
      rtu_gnssIn_measurement_DIMS1_id =
        rtu_gnssIn_measurement_DIMS1->satellite_position[0];
    }

    for (pipk = 0; pipk < jj; pipk++) {
      localB->Range = rtu_gnssIn_measurement->satellite_position[pipk] -
        localB->a_tmp;
      localB->s = rtu_gnssIn_measurement->satellite_position[pipk + coffset] -
        localB->userPosition_idx_1;
      localB->oldh = rtu_gnssIn_measurement->satellite_position[(boffset << 1) +
        pipk] - localB->N;
      localB->Range = std::sqrt((localB->Range * localB->Range + localB->s *
        localB->s) + localB->oldh * localB->oldh);
      localB->A_data[pipk] = (rtu_gnssIn_measurement->satellite_position[pipk] -
        localB->a_tmp) / localB->Range;
      localB->A_data[pipk + jBcol] = (rtu_gnssIn_measurement->
        satellite_position[pipk + kAcol] - localB->userPosition_idx_1) /
        localB->Range;
      localB->A_data[pipk + (jBcol << 1)] =
        (rtu_gnssIn_measurement->satellite_position
         [(rtu_gnssIn_measurement_DIMS1_id << 1) + pipk] - localB->N) /
        localB->Range;
      localB->A_data[pipk + jBcol * 3] = 1.0;
    }

    for (pipk = 0; pipk < 4; pipk++) {
      coffset = pipk << 2;
      boffset = pipk * jBcol;
      localB->y[coffset] = 0.0;
      localB->y[coffset + 1] = 0.0;
      localB->y[coffset + 2] = 0.0;
      localB->y[coffset + 3] = 0.0;
      for (jj = 0; jj < jBcol; jj++) {
        localB->Range = localB->A_data[boffset + jj];
        localB->y[coffset] += localB->A_data[jj] * localB->Range;
        localB->y[coffset + 1] += localB->A_data[jBcol + jj] * localB->Range;
        localB->y[coffset + 2] += localB->A_data[(jBcol << 1) + jj] *
          localB->Range;
        localB->y[coffset + 3] += localB->A_data[3 * jBcol + jj] * localB->Range;
      }
    }

    std::memset(&localB->Q[0], 0, sizeof(real_T) << 4U);
    ipiv[0] = 1;
    ipiv[1] = 2;
    ipiv[2] = 3;
    for (pipk = 0; pipk < 3; pipk++) {
      jj = pipk * 5;
      coffset = 4 - pipk;
      boffset = 0;
      localB->Range = std::abs(localB->y[jj]);
      for (loop_ub = 2; loop_ub <= coffset; loop_ub++) {
        localB->s = std::abs(localB->y[(jj + loop_ub) - 1]);
        if (localB->s > localB->Range) {
          boffset = loop_ub - 1;
          localB->Range = localB->s;
        }
      }

      if (localB->y[jj + boffset] != 0.0) {
        if (boffset != 0) {
          loop_ub = pipk + boffset;
          ipiv[pipk] = static_cast<int8_T>(loop_ub + 1);
          localB->Range = localB->y[pipk];
          localB->y[pipk] = localB->y[loop_ub];
          localB->y[loop_ub] = localB->Range;
          localB->Range = localB->y[pipk + 4];
          localB->y[pipk + 4] = localB->y[loop_ub + 4];
          localB->y[loop_ub + 4] = localB->Range;
          localB->Range = localB->y[pipk + 8];
          localB->y[pipk + 8] = localB->y[loop_ub + 8];
          localB->y[loop_ub + 8] = localB->Range;
          localB->Range = localB->y[pipk + 12];
          localB->y[pipk + 12] = localB->y[loop_ub + 12];
          localB->y[loop_ub + 12] = localB->Range;
        }

        coffset = (jj - pipk) + 4;
        boffset = (((((coffset - jj) - 1) / 2) << 1) + jj) + 2;
        jBcol = boffset - 2;
        for (loop_ub = jj + 2; loop_ub <= jBcol; loop_ub += 2) {
          __m128d tmp;
          tmp = _mm_loadu_pd(&localB->y[loop_ub - 1]);
          _mm_storeu_pd(&localB->y[loop_ub - 1], _mm_div_pd(tmp, _mm_set1_pd
            (localB->y[jj])));
        }

        for (loop_ub = boffset; loop_ub <= coffset; loop_ub++) {
          localB->y[loop_ub - 1] /= localB->y[jj];
        }
      }

      boffset = jj + 6;
      jBcol = 2 - pipk;
      for (loop_ub = 0; loop_ub <= jBcol; loop_ub++) {
        localB->Range = localB->y[((loop_ub << 2) + jj) + 4];
        if (localB->Range != 0.0) {
          kAcol = (boffset - pipk) + 2;
          for (coffset = boffset; coffset <= kAcol; coffset++) {
            localB->y[coffset - 1] += localB->y[((jj + coffset) - boffset) + 1] *
              -localB->Range;
          }
        }

        boffset += 4;
      }
    }

    p[0] = 1;
    p[1] = 2;
    p[2] = 3;
    p[3] = 4;
    if (ipiv[0] > 1) {
      pipk = p[ipiv[0] - 1];
      p[ipiv[0] - 1] = 1;
      p[0] = static_cast<int8_T>(pipk);
    }

    if (ipiv[1] > 2) {
      pipk = p[ipiv[1] - 1];
      p[ipiv[1] - 1] = p[1];
      p[1] = static_cast<int8_T>(pipk);
    }

    if (ipiv[2] > 3) {
      pipk = p[ipiv[2] - 1];
      p[ipiv[2] - 1] = p[2];
      p[2] = static_cast<int8_T>(pipk);
    }

    for (jj = 0; jj < 4; jj++) {
      boffset = (p[jj] - 1) << 2;
      localB->Q[jj + boffset] = 1.0;
      for (loop_ub = jj + 1; loop_ub < 5; loop_ub++) {
        pipk = (boffset + loop_ub) - 1;
        if (localB->Q[pipk] != 0.0) {
          for (coffset = loop_ub + 1; coffset < 5; coffset++) {
            jBcol = (boffset + coffset) - 1;
            localB->Q[jBcol] -= localB->y[(((loop_ub - 1) << 2) + coffset) - 1] *
              localB->Q[pipk];
          }
        }
      }
    }

    for (jj = 0; jj < 4; jj++) {
      jBcol = jj << 2;
      for (loop_ub = 3; loop_ub >= 0; loop_ub--) {
        kAcol = loop_ub << 2;
        pipk = loop_ub + jBcol;
        localB->Range = localB->Q[pipk];
        if (localB->Range != 0.0) {
          localB->Q[pipk] = localB->Range / localB->y[loop_ub + kAcol];
          for (coffset = 0; coffset < loop_ub; coffset++) {
            boffset = coffset + jBcol;
            localB->Q[boffset] -= localB->y[coffset + kAcol] * localB->Q[pipk];
          }
        }
      }
    }

    localB->Range = std::sqrt(localB->a_tmp * localB->a_tmp +
      localB->userPosition_idx_1 * localB->userPosition_idx_1);
    localB->b_userPhi = std::atan(localB->N / (localB->Range *
      -0.99664718933525243 * 0.0033528106647474805));
    localB->s = 0.1;
    localB->oldh = 0.0;
    pipk = 0;
    while ((std::abs(localB->s - localB->oldh) > 1.0E-12) && (pipk < 3000)) {
      localB->oldh = localB->s;
      localB->b_userPhi = std::cos(localB->b_userPhi);
      localB->b_N = 6.3995936257584924E+6 / std::sqrt(localB->b_userPhi *
        localB->b_userPhi * 0.0067394967422764341 + 1.0);
      localB->b_userPhi = std::atan(localB->N / ((1.0 - 0.0066943799901413165 *
        localB->b_N / (localB->b_N + localB->s)) * localB->Range));
      localB->s = localB->Range / std::cos(localB->b_userPhi) - localB->b_N;
      pipk++;
    }

    localB->N = localB->b_userPhi * 57.295779513082323 / 180.0 *
      3.1415926535897931;
    localB->Range = rt_atan2d_snf(localB->userPosition_idx_1, localB->a_tmp) *
      57.295779513082323 / 180.0 * 3.1415926535897931;
    localB->a_tmp = std::cos(localB->Range);
    localB->userPosition_idx_1 = std::sin(localB->N);
    localB->Range = std::sin(localB->Range);
    localB->N = std::cos(localB->N);
    localB->Rot[0] = -localB->Range;
    localB->Rot[3] = -(localB->userPosition_idx_1 * localB->a_tmp);
    localB->Rot[6] = localB->N * localB->a_tmp;
    localB->Rot[1] = localB->a_tmp;
    localB->Rot[4] = -(localB->userPosition_idx_1 * localB->Range);
    localB->Rot[7] = localB->N * localB->Range;
    localB->Rot[2] = 0.0;
    localB->Rot[5] = localB->N;
    localB->Rot[8] = localB->userPosition_idx_1;
    for (pipk = 0; pipk < 3; pipk++) {
      for (jj = 0; jj < 3; jj++) {
        loop_ub = 3 * jj + pipk;
        localB->Rot_m[loop_ub] = 0.0;
        coffset = jj << 2;
        localB->Rot_m[loop_ub] += localB->Rot[3 * pipk] * localB->Q[coffset];
        localB->Rot_m[loop_ub] += localB->Rot[3 * pipk + 1] * localB->Q[coffset
          + 1];
        localB->Rot_m[loop_ub] += localB->Rot[3 * pipk + 2] * localB->Q[coffset
          + 2];
      }

      for (jj = 0; jj < 3; jj++) {
        loop_ub = 3 * jj + pipk;
        localB->Qtemp[loop_ub] = 0.0;
        localB->Qtemp[loop_ub] += localB->Rot[3 * jj] * localB->Rot_m[pipk];
        localB->Qtemp[loop_ub] += localB->Rot[3 * jj + 1] * localB->Rot_m[pipk +
          3];
        localB->Qtemp[loop_ub] += localB->Rot[3 * jj + 2] * localB->Rot_m[pipk +
          6];
      }
    }

    if ((localB->Qtemp[0] < 0.0) || (localB->Qtemp[4] < 0.0) || (localB->Qtemp[8]
         < 0.0)) {
      *rty_VDOP = (rtNaN);
      *rty_HDOP = (rtNaN);
    } else {
      *rty_VDOP = std::sqrt(localB->Qtemp[8]);
      *rty_HDOP = std::sqrt(localB->Qtemp[0] + localB->Qtemp[4]);
    }
  } else {
    *rty_HDOP = (rtNaN);
    *rty_VDOP = (rtNaN);
  }

  localDW->SFunction_DIMS2 = *rtu_gnssIn_measurement_DIMS1;
}

void DDRTCM::DDRTCM_binary_expand_op_mzk34n(real_T in1[3], const real_T
  in2_data[], const int32_T in2_size[2])
{
  int32_T stride_0_1;
  stride_0_1 = (in2_size[1] != 1);
  in1[0] = in2_data[0] - in1[0];
  in1[1] = in2_data[stride_0_1] - in1[1];
  in1[2] = in2_data[stride_0_1 << 1] - in1[2];
}

// Function for MATLAB Function: '<S123>/calculate Variance'
void DDRTCM::calculate_Satellite_Elevation_c(const real_T user_Position_llh[3],
  const real_T satellite_Position_ecef_data[], const int32_T
  satellite_Position_ecef_size[2], real_T *elevation_Angle, real_T
  *azimuth_Angle, B_MATLABFunction_DDRTCM_T *localB)
{
  localB->a_tmp = std::cos(user_Position_llh[0]);
  localB->N_d = 6.3995936257584924E+6 / std::sqrt(localB->a_tmp * localB->a_tmp *
    0.0067394967422761756 + 1.0);
  localB->user_Position_ecef_b = std::cos(user_Position_llh[1]);
  localB->user_Position_ecef[0] = (localB->N_d + user_Position_llh[2]) *
    localB->a_tmp * localB->user_Position_ecef_b;
  localB->user_Position_ecef_n = std::sin(user_Position_llh[1]);
  localB->user_Position_ecef[1] = (localB->N_d + user_Position_llh[2]) * std::
    cos(user_Position_llh[0]) * localB->user_Position_ecef_n;
  localB->user_Position_ecef_l = std::sin(user_Position_llh[0]);
  localB->user_Position_ecef[2] = (0.99330562000985889 * localB->N_d +
    user_Position_llh[2]) * localB->user_Position_ecef_l;
  if (satellite_Position_ecef_size[1] == 3) {
    for (int32_T i{0}; i <= 0; i += 2) {
      __m128d tmp;
      tmp = _mm_loadu_pd(&localB->user_Position_ecef[i]);
      _mm_storeu_pd(&localB->user_Position_ecef[i], _mm_sub_pd(_mm_loadu_pd
        (&satellite_Position_ecef_data[i]), tmp));
    }

    for (int32_T i{2}; i < 3; i++) {
      localB->user_Position_ecef[i] = satellite_Position_ecef_data[i] -
        localB->user_Position_ecef[i];
    }
  } else {
    DDRTCM_binary_expand_op_mzk34n(localB->user_Position_ecef,
      satellite_Position_ecef_data, satellite_Position_ecef_size);
  }

  localB->scale_l = 3.3121686421112381E-170;
  localB->absxk_o = std::abs(localB->user_Position_ecef[0]);
  if (localB->absxk_o > 3.3121686421112381E-170) {
    localB->N_d = 1.0;
    localB->scale_l = localB->absxk_o;
  } else {
    localB->t_b = localB->absxk_o / 3.3121686421112381E-170;
    localB->N_d = localB->t_b * localB->t_b;
  }

  localB->absxk_o = std::abs(localB->user_Position_ecef[1]);
  if (localB->absxk_o > localB->scale_l) {
    localB->t_b = localB->scale_l / localB->absxk_o;
    localB->N_d = localB->N_d * localB->t_b * localB->t_b + 1.0;
    localB->scale_l = localB->absxk_o;
  } else {
    localB->t_b = localB->absxk_o / localB->scale_l;
    localB->N_d += localB->t_b * localB->t_b;
  }

  localB->absxk_o = std::abs(localB->user_Position_ecef[2]);
  if (localB->absxk_o > localB->scale_l) {
    localB->t_b = localB->scale_l / localB->absxk_o;
    localB->N_d = localB->N_d * localB->t_b * localB->t_b + 1.0;
    localB->scale_l = localB->absxk_o;
  } else {
    localB->t_b = localB->absxk_o / localB->scale_l;
    localB->N_d += localB->t_b * localB->t_b;
  }

  localB->N_d = localB->scale_l * std::sqrt(localB->N_d);
  localB->elevation_Angle_tmp[0] = -localB->user_Position_ecef_n;
  localB->elevation_Angle_tmp[1] = localB->user_Position_ecef_b;
  localB->elevation_Angle_tmp[2] = 0.0;
  localB->elevation_Angle_tmp[3] = -localB->user_Position_ecef_l *
    localB->user_Position_ecef_b;
  localB->elevation_Angle_tmp[4] = -std::sin(user_Position_llh[0]) *
    localB->user_Position_ecef_n;
  localB->elevation_Angle_tmp[5] = localB->a_tmp;
  localB->elevation_Angle_tmp[6] = localB->a_tmp * localB->user_Position_ecef_b;
  localB->elevation_Angle_tmp[7] = localB->a_tmp * localB->user_Position_ecef_n;
  localB->elevation_Angle_tmp[8] = localB->user_Position_ecef_l;
  localB->user_Position_ecef_n = 0.0;
  localB->a_tmp = 0.0;
  localB->user_Position_ecef_b = 0.0;
  for (int32_T i{0}; i < 3; i++) {
    localB->user_Position_ecef_l = localB->user_Position_ecef[i] / localB->N_d;
    localB->scale_l = localB->elevation_Angle_tmp[i + 3];
    localB->absxk_o = localB->scale_l * 0.0;
    localB->t_b = localB->elevation_Angle_tmp[i + 6];
    localB->user_Position_ecef_n += ((localB->elevation_Angle_tmp[i] * 0.0 +
      localB->absxk_o) + localB->t_b) * localB->user_Position_ecef_l;
    localB->t_b *= 0.0;
    localB->a_tmp += ((localB->absxk_o + localB->elevation_Angle_tmp[i]) +
                      localB->t_b) * localB->user_Position_ecef_l;
    localB->user_Position_ecef_b += ((localB->elevation_Angle_tmp[i] * 0.0 +
      localB->scale_l) + localB->t_b) * localB->user_Position_ecef_l;
    localB->user_Position_ecef[i] = localB->user_Position_ecef_l;
  }

  *elevation_Angle = std::asin(localB->user_Position_ecef_n);
  *azimuth_Angle = rt_atan2d_snf(localB->a_tmp, localB->user_Position_ecef_b);
}

void DDRTCM::DDRTCM_binary_expand_op_mzk(real_T in1[3], real_T in2, real_T in3,
  const int8_T in4[3], real_T in5, real_T in6, const int8_T in7[3], const real_T
  in8[4], const real_T in9_data[], const int32_T in9_size[2], int32_T in10,
  const int32_T in11_size[2], B_MATLABFunction_DDRTCM_T *localB)
{
  localB->in2[0] = in2;
  localB->in2[3] = -in3;
  localB->in2[6] = 0.0;
  localB->in2[1] = in3;
  localB->in2[4] = in2;
  localB->in2[7] = 0.0;
  localB->in5[0] = in5;
  localB->in5[3] = 0.0;
  localB->in5[6] = in6;
  localB->in2[2] = in4[0];
  localB->in5[1] = in7[0];
  localB->in2[5] = in4[1];
  localB->in5[4] = in7[1];
  localB->in2[8] = in4[2];
  localB->in5[7] = in7[2];
  localB->in5[2] = -in6;
  localB->in5[5] = 0.0;
  localB->in5[8] = in5;
  localB->stride_0_0 = (in11_size[1] != 1);
  for (localB->i2 = 0; localB->i2 < 3; localB->i2++) {
    for (localB->i1 = 0; localB->i1 < 3; localB->i1++) {
      localB->in2_tmp = 3 * localB->i2 + localB->i1;
      localB->in2_n[localB->in2_tmp] = 0.0;
      localB->in2_n[localB->in2_tmp] += localB->in5[3 * localB->i1] *
        localB->in2[localB->i2];
      localB->in2_n[localB->in2_tmp] += localB->in5[3 * localB->i1 + 1] *
        localB->in2[localB->i2 + 3];
      localB->in2_n[localB->in2_tmp] += localB->in5[3 * localB->i1 + 2] *
        localB->in2[localB->i2 + 6];
    }

    localB->in8[localB->i2] = in8[localB->i2] - in9_data[localB->i2 *
      localB->stride_0_0 * in9_size[0] + in10];
  }

  for (localB->i2 = 0; localB->i2 <= 0; localB->i2 += 2) {
    __m128d tmp;
    __m128d tmp_0;
    _mm_storeu_pd(&in1[localB->i2], _mm_set1_pd(0.0));
    tmp = _mm_loadu_pd(&localB->in2_n[localB->i2]);
    tmp_0 = _mm_loadu_pd(&in1[localB->i2]);
    _mm_storeu_pd(&in1[localB->i2], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd
      (localB->in8[0])), tmp_0));
    tmp = _mm_loadu_pd(&localB->in2_n[localB->i2 + 3]);
    tmp_0 = _mm_loadu_pd(&in1[localB->i2]);
    _mm_storeu_pd(&in1[localB->i2], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd
      (localB->in8[1])), tmp_0));
    tmp = _mm_loadu_pd(&localB->in2_n[localB->i2 + 6]);
    tmp_0 = _mm_loadu_pd(&in1[localB->i2]);
    _mm_storeu_pd(&in1[localB->i2], _mm_add_pd(_mm_mul_pd(tmp, _mm_set1_pd
      (localB->in8[2])), tmp_0));
  }

  for (localB->i2 = 2; localB->i2 < 3; localB->i2++) {
    in1[localB->i2] = 0.0;
    in1[localB->i2] += localB->in2_n[localB->i2] * localB->in8[0];
    in1[localB->i2] += localB->in2_n[localB->i2 + 3] * localB->in8[1];
    in1[localB->i2] += localB->in2_n[localB->i2 + 6] * localB->in8[2];
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_inv(const real_T x_data[], const int32_T x_size[2], real_T
  y_data[], int32_T y_size[2], B_MATLABFunction_DDRTCM_T *localB)
{
  if ((x_size[0] == 0) || (x_size[1] == 0)) {
    y_size[0] = x_size[0];
    y_size[1] = x_size[1];
    localB->b_yk = x_size[0] * x_size[1];
    if (localB->b_yk - 1 >= 0) {
      std::memcpy(&y_data[0], &x_data[0], static_cast<uint32_T>(localB->b_yk) *
                  sizeof(real_T));
    }
  } else {
    localB->n_p = x_size[0];
    y_size[0] = x_size[0];
    y_size[1] = x_size[1];
    localB->b_yk = x_size[0] * x_size[1];
    std::memset(&y_data[0], 0, static_cast<uint32_T>(localB->b_yk) * sizeof
                (real_T));
    localB->A_size_idx_0 = x_size[0];
    std::memcpy(&localB->A_data[0], &x_data[0], static_cast<uint32_T>
                (localB->b_yk) * sizeof(real_T));
    localB->ldap1 = x_size[0];
    localB->mmj = x_size[0];
    localB->ipiv_data_tmp = 0;
    localB->ipiv_data[localB->ipiv_data_tmp] = 1;
    localB->b_yk = 1;
    for (localB->pipk = 2; localB->pipk <= localB->ldap1; localB->pipk++) {
      localB->b_yk++;
      localB->ipiv_data[localB->pipk - 1] = static_cast<int8_T>(localB->b_yk);
    }

    localB->ldap1 = x_size[0];
    if (x_size[0] - 1 <= x_size[0]) {
      localB->b_yk = x_size[0] - 1;
    } else {
      localB->b_yk = x_size[0];
    }

    for (localB->pipk = 0; localB->pipk < localB->b_yk; localB->pipk++) {
      localB->mmj_tmp = localB->n_p - localB->pipk;
      localB->jj_e = (localB->ldap1 + 1) * localB->pipk;
      if (localB->mmj_tmp < 1) {
        localB->kAcol_a = -1;
      } else {
        localB->kAcol_a = 0;
        if (localB->mmj_tmp > 1) {
          localB->smax_l = std::abs(localB->A_data[localB->jj_e]);
          for (localB->jy = 2; localB->jy <= localB->mmj_tmp; localB->jy++) {
            localB->s_d = std::abs(localB->A_data[(localB->jj_e + localB->jy) -
              1]);
            if (localB->s_d > localB->smax_l) {
              localB->kAcol_a = localB->jy - 1;
              localB->smax_l = localB->s_d;
            }
          }
        }
      }

      if (localB->A_data[localB->jj_e + localB->kAcol_a] != 0.0) {
        if (localB->kAcol_a != 0) {
          localB->kAcol_a += localB->pipk;
          localB->ipiv_data[localB->pipk] = static_cast<int8_T>(localB->kAcol_a
            + 1);
          for (localB->jy = 0; localB->jy < localB->n_p; localB->jy++) {
            localB->smax_tmp = localB->jy * localB->n_p;
            localB->jA_a = localB->smax_tmp + localB->pipk;
            localB->smax_l = localB->A_data[localB->jA_a];
            localB->smax_tmp += localB->kAcol_a;
            localB->A_data[localB->jA_a] = localB->A_data[localB->smax_tmp];
            localB->A_data[localB->smax_tmp] = localB->smax_l;
          }
        }

        localB->kAcol_a = localB->jj_e + localB->mmj_tmp;
        localB->jy = (((((localB->kAcol_a - localB->jj_e) - 1) / 2) << 1) +
                      localB->jj_e) + 2;
        localB->jA_a = localB->jy - 2;
        for (localB->smax_tmp = localB->jj_e + 2; localB->smax_tmp <=
             localB->jA_a; localB->smax_tmp += 2) {
          __m128d tmp;
          tmp = _mm_loadu_pd(&localB->A_data[localB->smax_tmp - 1]);
          _mm_storeu_pd(&localB->A_data[localB->smax_tmp - 1], _mm_div_pd(tmp,
            _mm_set1_pd(localB->A_data[localB->jj_e])));
        }

        for (localB->smax_tmp = localB->jy; localB->smax_tmp <= localB->kAcol_a;
             localB->smax_tmp++) {
          localB->A_data[localB->smax_tmp - 1] /= localB->A_data[localB->jj_e];
        }
      }

      localB->kAcol_a = localB->mmj_tmp - 1;
      localB->jy = localB->jj_e + localB->n_p;
      localB->jA_a = (localB->jj_e + localB->ldap1) + 2;
      for (localB->smax_tmp = 0; localB->smax_tmp < localB->kAcol_a;
           localB->smax_tmp++) {
        localB->smax_l = localB->A_data[localB->smax_tmp * localB->n_p +
          localB->jy];
        if (localB->smax_l != 0.0) {
          localB->m_a = (localB->mmj_tmp + localB->jA_a) - 1;
          for (localB->ijA = localB->jA_a; localB->ijA < localB->m_a;
               localB->ijA++) {
            localB->A_data[localB->ijA - 1] += localB->A_data[((localB->jj_e +
              localB->ijA) - localB->jA_a) + 1] * -localB->smax_l;
          }
        }

        localB->jA_a += localB->n_p;
      }
    }

    localB->ldap1 = x_size[0];
    localB->p_data_p[localB->ipiv_data_tmp] = 1;
    localB->b_yk = 1;
    for (localB->pipk = 2; localB->pipk <= localB->ldap1; localB->pipk++) {
      localB->b_yk++;
      localB->p_data_p[localB->pipk - 1] = static_cast<int8_T>(localB->b_yk);
    }

    for (localB->b_yk = 0; localB->b_yk < localB->mmj; localB->b_yk++) {
      localB->ipiv_c = localB->ipiv_data[localB->b_yk];
      if (localB->ipiv_c > localB->b_yk + 1) {
        localB->pipk = localB->p_data_p[localB->ipiv_c - 1];
        localB->p_data_p[localB->ipiv_c - 1] = localB->p_data_p[localB->b_yk];
        localB->p_data_p[localB->b_yk] = static_cast<int8_T>(localB->pipk);
      }
    }

    localB->ldap1 = x_size[0];
    for (localB->b_yk = 0; localB->b_yk < localB->ldap1; localB->b_yk++) {
      localB->pipk = localB->p_data_p[localB->b_yk] - 1;
      localB->jy = (localB->p_data_p[localB->b_yk] - 1) * y_size[0];
      y_data[localB->b_yk + localB->jy] = 1.0;
      for (localB->mmj = localB->b_yk + 1; localB->mmj <= localB->n_p;
           localB->mmj++) {
        localB->kAcol_a = (y_size[0] * localB->pipk + localB->mmj) - 1;
        if (y_data[localB->kAcol_a] != 0.0) {
          for (localB->jj_e = localB->mmj + 1; localB->jj_e <= localB->n_p;
               localB->jj_e++) {
            localB->ipiv_data_tmp = (localB->jj_e + localB->jy) - 1;
            y_data[localB->ipiv_data_tmp] -= localB->A_data[((localB->mmj - 1) *
              localB->A_size_idx_0 + localB->jj_e) - 1] * y_data[localB->kAcol_a];
          }
        }
      }
    }

    localB->b_yk = x_size[0];
    for (localB->pipk = 0; localB->pipk < localB->b_yk; localB->pipk++) {
      localB->mmj = localB->n_p * localB->pipk - 1;
      for (localB->jj_e = localB->n_p; localB->jj_e >= 1; localB->jj_e--) {
        localB->kAcol_a = (localB->jj_e - 1) * localB->n_p;
        localB->ldap1 = localB->jj_e + localB->mmj;
        if (y_data[localB->ldap1] != 0.0) {
          y_data[localB->ldap1] /= localB->A_data[(localB->jj_e +
            localB->kAcol_a) - 1];
          for (localB->jy = 0; localB->jy <= localB->jj_e - 2; localB->jy++) {
            localB->jA_a = (localB->jy + localB->mmj) + 1;
            y_data[localB->jA_a] -= localB->A_data[localB->jy + localB->kAcol_a]
              * y_data[localB->ldap1];
          }
        }
      }
    }
  }
}

void DDRTCM::DDRTCM_binary_expand_op_mzk3(real_T in1[3], const real_T in2[4],
  const real_T in3_data[], const int32_T in3_size[2], int32_T in4, const int32_T
  in5_size[2])
{
  int32_T stride_0_1;
  stride_0_1 = (in5_size[1] != 1);
  in1[0] = in2[0] - in3_data[in4];
  in1[1] = in2[1] - in3_data[in3_size[0] * stride_0_1 + in4];
  in1[2] = in2[2] - in3_data[(stride_0_1 << 1) * in3_size[0] + in4];
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_mldivide(const real_T A[16], const real_T B_data[], const
  int32_T B_size[2], real_T Y_data[], int32_T Y_size[2],
  B_MATLABFunction_DDRTCM_T *localB)
{
  if (B_size[1] == 0) {
    Y_size[0] = 4;
    Y_size[1] = 0;
  } else {
    std::memcpy(&localB->b_A[0], &A[0], sizeof(real_T) << 4U);
    localB->ipiv[0] = 1;
    localB->ipiv[1] = 2;
    localB->ipiv[2] = 3;
    localB->ipiv[3] = 4;
    for (localB->b_j = 0; localB->b_j < 3; localB->b_j++) {
      localB->jj = localB->b_j * 5;
      localB->jA = 4 - localB->b_j;
      localB->a = 0;
      localB->smax = std::abs(localB->b_A[localB->jj]);
      for (localB->jBcol = 2; localB->jBcol <= localB->jA; localB->jBcol++) {
        localB->s_g = std::abs(localB->b_A[(localB->jj + localB->jBcol) - 1]);
        if (localB->s_g > localB->smax) {
          localB->a = localB->jBcol - 1;
          localB->smax = localB->s_g;
        }
      }

      if (localB->b_A[localB->jj + localB->a] != 0.0) {
        if (localB->a != 0) {
          localB->jA = localB->b_j + localB->a;
          localB->ipiv[localB->b_j] = static_cast<int8_T>(localB->jA + 1);
          localB->smax = localB->b_A[localB->b_j];
          localB->b_A[localB->b_j] = localB->b_A[localB->jA];
          localB->b_A[localB->jA] = localB->smax;
          localB->smax = localB->b_A[localB->b_j + 4];
          localB->b_A[localB->b_j + 4] = localB->b_A[localB->jA + 4];
          localB->b_A[localB->jA + 4] = localB->smax;
          localB->smax = localB->b_A[localB->b_j + 8];
          localB->b_A[localB->b_j + 8] = localB->b_A[localB->jA + 8];
          localB->b_A[localB->jA + 8] = localB->smax;
          localB->smax = localB->b_A[localB->b_j + 12];
          localB->b_A[localB->b_j + 12] = localB->b_A[localB->jA + 12];
          localB->b_A[localB->jA + 12] = localB->smax;
        }

        localB->jA = (localB->jj - localB->b_j) + 4;
        localB->a = (((((localB->jA - localB->jj) - 1) / 2) << 1) + localB->jj)
          + 2;
        localB->jBcol = localB->a - 2;
        for (localB->b_i = localB->jj + 2; localB->b_i <= localB->jBcol;
             localB->b_i += 2) {
          __m128d tmp;
          tmp = _mm_loadu_pd(&localB->b_A[localB->b_i - 1]);
          _mm_storeu_pd(&localB->b_A[localB->b_i - 1], _mm_div_pd(tmp,
            _mm_set1_pd(localB->b_A[localB->jj])));
        }

        for (localB->b_i = localB->a; localB->b_i <= localB->jA; localB->b_i++)
        {
          localB->b_A[localB->b_i - 1] /= localB->b_A[localB->jj];
        }
      }

      localB->jA = localB->jj + 6;
      localB->a = 2 - localB->b_j;
      for (localB->jBcol = 0; localB->jBcol <= localB->a; localB->jBcol++) {
        localB->smax = localB->b_A[((localB->jBcol << 2) + localB->jj) + 4];
        if (localB->smax != 0.0) {
          localB->b_i = (localB->jA - localB->b_j) + 2;
          for (localB->kAcol = localB->jA; localB->kAcol <= localB->b_i;
               localB->kAcol++) {
            localB->b_A[localB->kAcol - 1] += localB->b_A[((localB->jj +
              localB->kAcol) - localB->jA) + 1] * -localB->smax;
          }
        }

        localB->jA += 4;
      }
    }

    Y_size[0] = 4;
    Y_size[1] = B_size[1];
    localB->jA = B_size[1] << 2;
    std::memcpy(&Y_data[0], &B_data[0], static_cast<uint32_T>(localB->jA) *
                sizeof(real_T));
    for (localB->b_j = 0; localB->b_j < 3; localB->b_j++) {
      localB->ipiv_h = localB->ipiv[localB->b_j];
      if (localB->b_j + 1 != localB->ipiv_h) {
        localB->jj = B_size[1];
        for (localB->jA = 0; localB->jA < localB->jj; localB->jA++) {
          localB->smax = Y_data[(localB->jA << 2) + localB->b_j];
          Y_data[localB->b_j + (localB->jA << 2)] = Y_data[((localB->jA << 2) +
            localB->ipiv_h) - 1];
          Y_data[(localB->ipiv_h + (localB->jA << 2)) - 1] = localB->smax;
        }
      }
    }

    localB->jA = B_size[1];
    for (localB->a = 0; localB->a < localB->jA; localB->a++) {
      localB->jBcol = localB->a << 2;
      for (localB->b_i = 0; localB->b_i < 4; localB->b_i++) {
        localB->kAcol = localB->b_i << 2;
        localB->b_j = localB->b_i + localB->jBcol;
        if (Y_data[localB->b_j] != 0.0) {
          for (localB->c_i = localB->b_i + 2; localB->c_i < 5; localB->c_i++) {
            localB->jj = (localB->c_i + localB->jBcol) - 1;
            Y_data[localB->jj] -= localB->b_A[(localB->c_i + localB->kAcol) - 1]
              * Y_data[localB->b_j];
          }
        }
      }
    }

    localB->jA = B_size[1];
    for (localB->a = 0; localB->a < localB->jA; localB->a++) {
      localB->jBcol = localB->a << 2;
      for (localB->b_i = 3; localB->b_i >= 0; localB->b_i--) {
        localB->kAcol = localB->b_i << 2;
        localB->b_j = localB->b_i + localB->jBcol;
        if (Y_data[localB->b_j] != 0.0) {
          Y_data[localB->b_j] /= localB->b_A[localB->b_i + localB->kAcol];
          for (localB->c_i = 0; localB->c_i < localB->b_i; localB->c_i++) {
            localB->jj = localB->c_i + localB->jBcol;
            Y_data[localB->jj] -= localB->b_A[localB->c_i + localB->kAcol] *
              Y_data[localB->b_j];
          }
        }
      }
    }
  }
}

void DDRTCM::DDRTCM_minus_m(real_T in1_data[], int32_T in1_size[2], const real_T
  in2_data[], const int32_T in2_size[2], B_MATLABFunction_DDRTCM_T *localB)
{
  localB->in1_size_idx_0 = in2_size[0] == 1 ? in1_size[0] : in2_size[0];
  localB->in1_size_idx_1 = in2_size[1] == 1 ? in1_size[1] : in2_size[1];
  localB->stride_0_0_f = (in1_size[0] != 1);
  localB->stride_0_1 = (in1_size[1] != 1);
  localB->stride_1_0 = (in2_size[0] != 1);
  localB->stride_1_1 = (in2_size[1] != 1);
  localB->aux_0_1 = 0;
  localB->aux_1_1 = 0;
  localB->loop_ub_p = in2_size[1] == 1 ? in1_size[1] : in2_size[1];
  for (localB->i4 = 0; localB->i4 < localB->loop_ub_p; localB->i4++) {
    localB->loop_ub_e = in2_size[0] == 1 ? in1_size[0] : in2_size[0];
    for (localB->i3_c = 0; localB->i3_c < localB->loop_ub_e; localB->i3_c++) {
      localB->in1_data[localB->i3_c + localB->in1_size_idx_0 * localB->i4] =
        in1_data[localB->i3_c * localB->stride_0_0_f + in1_size[0] *
        localB->aux_0_1] - in2_data[localB->i3_c * localB->stride_1_0 +
        in2_size[0] * localB->aux_1_1];
    }

    localB->aux_1_1 += localB->stride_1_1;
    localB->aux_0_1 += localB->stride_0_1;
  }

  in1_size[0] = localB->in1_size_idx_0;
  in1_size[1] = localB->in1_size_idx_1;
  for (localB->i4 = 0; localB->i4 < localB->in1_size_idx_1; localB->i4++) {
    for (localB->i3_c = 0; localB->i3_c < localB->in1_size_idx_0; localB->i3_c++)
    {
      in1_data[localB->i3_c + in1_size[0] * localB->i4] = localB->
        in1_data[localB->in1_size_idx_0 * localB->i4 + localB->i3_c];
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_mtimes(const real_T A_data[], const int32_T A_size[2], const
  real_T B_data[], real_T C_data[], int32_T *C_size, B_MATLABFunction_DDRTCM_T
  *localB)
{
  *C_size = A_size[0];
  localB->b_h = A_size[0];
  if (localB->b_h - 1 >= 0) {
    std::memset(&C_data[0], 0, static_cast<uint32_T>(localB->b_h) * sizeof
                (real_T));
  }

  localB->b_h = A_size[1];
  for (localB->i_l = 0; localB->i_l < localB->b_h; localB->i_l++) {
    localB->aoffset_o = localB->i_l * A_size[0];
    localB->d_h = A_size[0];
    localB->scalarLB = (A_size[0] / 2) << 1;
    localB->vectorUB_m = localB->scalarLB - 2;
    for (localB->b_i_m = 0; localB->b_i_m <= localB->vectorUB_m; localB->b_i_m +=
         2) {
      __m128d tmp;
      tmp = _mm_loadu_pd(&C_data[localB->b_i_m]);
      _mm_storeu_pd(&C_data[localB->b_i_m], _mm_add_pd(_mm_mul_pd(_mm_loadu_pd
        (&A_data[localB->aoffset_o + localB->b_i_m]), _mm_set1_pd(B_data
        [localB->i_l])), tmp));
    }

    for (localB->b_i_m = localB->scalarLB; localB->b_i_m < localB->d_h;
         localB->b_i_m++) {
      C_data[localB->b_i_m] += A_data[localB->aoffset_o + localB->b_i_m] *
        B_data[localB->i_l];
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
real_T DDRTCM::DDRTCM_maximum(const real_T x_data[], const int32_T *x_size)
{
  real_T ex;
  int32_T last;
  last = *x_size;
  if (static_cast<uint8_T>(*x_size - 1) + 1 <= 2) {
    if (static_cast<uint8_T>(*x_size - 1) + 1 == 1) {
      ex = x_data[0];
    } else {
      ex = x_data[*x_size - 1];
      if (x_data[0] < ex) {
      } else if (std::isnan(x_data[0])) {
        if (!std::isnan(ex)) {
        } else {
          ex = x_data[0];
        }
      } else {
        ex = x_data[0];
      }
    }
  } else {
    int32_T idx;
    int32_T k;
    if (!std::isnan(x_data[0])) {
      idx = 1;
    } else {
      boolean_T exitg1;
      idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= *x_size)) {
        if (!std::isnan(x_data[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (idx == 0) {
      ex = x_data[0];
    } else {
      ex = x_data[idx - 1];
      for (k = idx + 1; k <= last; k++) {
        real_T tmp;
        tmp = x_data[k - 1];
        if (ex < tmp) {
          ex = tmp;
        }
      }
    }
  }

  return ex;
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_RAIM_detect_Fault(const real_T
  e_GNSS_Measurement_satellite_po[], const int32_T
  e_GNSS_Measurement_satellite__0[2], const real_T
  e_GNSS_Measurement_pseudorange_[], const int32_T
  *e_GNSS_Measurement_pseudorang_0, const real_T
  e_GNSS_Measurement_variance_pse[], const real_T user_position_llh[3], real_T
  clockerror, const real_T b_table_chi_square[80], real_T m, real_T
  *test_statistic, real_T *threshold, real_T *HPL, real_T H_data[], int32_T
  H_size[2], real_T W_data[], int32_T W_size[2], real_T y_data[], int32_T
  *y_size, B_MATLABFunction_DDRTCM_T *localB)
{
  static const int8_T ab[3]{ 0, 0, 1 };

  static const int8_T bb[3]{ 0, 1, 0 };

  __m128d tmp_0;
  __m128d tmp_1;
  __m128d tmp_2;
  localB->sinus_lambda = std::cos(user_position_llh[0]);
  localB->N = 6.3995936257584924E+6 / std::sqrt(localB->sinus_lambda *
    localB->sinus_lambda * 0.0067394967422761756 + 1.0);
  localB->user_state_pre[0] = (localB->N + user_position_llh[2]) *
    localB->sinus_lambda * std::cos(user_position_llh[1]);
  localB->user_state_pre[1] = (localB->N + user_position_llh[2]) * std::cos
    (user_position_llh[0]) * std::sin(user_position_llh[1]);
  localB->user_state_pre[2] = (0.99330562000985889 * localB->N +
    user_position_llh[2]) * std::sin(user_position_llh[0]);
  localB->user_state_pre[3] = clockerror;
  localB->loop_ub = *e_GNSS_Measurement_pseudorang_0;
  for (localB->k = 0; localB->k < localB->loop_ub; localB->k++) {
    localB->cb_data[localB->k] = !std::isnan
      (e_GNSS_Measurement_pseudorange_[localB->k]);
  }

  localB->k = *e_GNSS_Measurement_pseudorang_0 - 1;
  localB->trueCount = 0;
  for (localB->coffset = 0; localB->coffset <= localB->k; localB->coffset++) {
    if (localB->cb_data[localB->coffset]) {
      localB->trueCount++;
    }
  }

  localB->h_size = localB->trueCount;
  localB->trueCount = 0;
  for (localB->coffset = 0; localB->coffset <= localB->k; localB->coffset++) {
    if (localB->cb_data[localB->coffset]) {
      localB->h_data[localB->trueCount] = static_cast<int8_T>(localB->coffset +
        1);
      localB->trueCount++;
    }
  }

  if (localB->h_size < 1) {
    localB->loop_ub = -1;
  } else {
    localB->loop_ub = localB->h_size - 1;
  }

  localB->satellitePosition_ecef_size[0] = localB->loop_ub + 1;
  localB->satellitePosition_ecef_size[1] = e_GNSS_Measurement_satellite__0[1];
  localB->trueCount = e_GNSS_Measurement_satellite__0[1];
  for (localB->k = 0; localB->k < localB->trueCount; localB->k++) {
    for (localB->boffset = 0; localB->boffset <= localB->loop_ub;
         localB->boffset++) {
      localB->satellitePosition_ecef_data[localB->boffset + (localB->loop_ub + 1)
        * localB->k] =
        e_GNSS_Measurement_satellite_po[e_GNSS_Measurement_satellite__0[0] *
        localB->k + localB->boffset];
    }
  }

  localB->sinus_lambda = std::sqrt(localB->user_state_pre[0] *
    localB->user_state_pre[0] + localB->user_state_pre[1] *
    localB->user_state_pre[1]);
  localB->cosinus_phi_d = std::atan(localB->user_state_pre[2] /
    (localB->sinus_lambda * -0.99664718933525243 * 0.0033528106647474805));
  localB->N = 0.1;
  localB->oldh = 0.0;
  localB->k = 0;
  while ((std::abs(localB->N - localB->oldh) > 1.0E-12) && (localB->k < 3000)) {
    localB->oldh = localB->N;
    localB->cosinus_phi_d = std::cos(localB->cosinus_phi_d);
    localB->b_N = 6.3995936257584924E+6 / std::sqrt(localB->cosinus_phi_d *
      localB->cosinus_phi_d * 0.0067394967422764341 + 1.0);
    localB->cosinus_phi_d = std::atan(localB->user_state_pre[2] / ((1.0 -
      0.0066943799901413165 * localB->b_N / (localB->b_N + localB->N)) *
      localB->sinus_lambda));
    localB->N = localB->sinus_lambda / std::cos(localB->cosinus_phi_d) -
      localB->b_N;
    localB->k++;
  }

  localB->position_llh[0] = localB->cosinus_phi_d * 57.295779513082323 *
    0.017453292519943295;
  localB->position_llh[1] = rt_atan2d_snf(localB->user_state_pre[1],
    localB->user_state_pre[0]) * 57.295779513082323 * 0.017453292519943295;
  localB->position_llh[2] = localB->N;
  H_size[0] = localB->h_size;
  H_size[1] = 4;
  localB->loop_ub = localB->h_size << 2;
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&H_data[0], 0, static_cast<uint32_T>(localB->loop_ub) * sizeof
                (real_T));
  }

  localB->trueCount = localB->h_size;
  for (localB->coffset = 0; localB->coffset < localB->trueCount; localB->coffset
       ++) {
    localB->sinus_lambda = std::sin(localB->position_llh[1]);
    localB->N = std::cos(localB->position_llh[1]);
    localB->oldh = std::sin((1.5707963267948966 - localB->position_llh[0]) -
      3.1415926535897931);
    localB->cosinus_phi_d = std::cos((1.5707963267948966 - localB->position_llh
      [0]) - 3.1415926535897931);
    if (e_GNSS_Measurement_satellite__0[1] == 3) {
      localB->cosinus_lambda[0] = localB->N;
      localB->cosinus_lambda[3] = -localB->sinus_lambda;
      localB->cosinus_lambda[6] = 0.0;
      localB->cosinus_lambda[1] = localB->sinus_lambda;
      localB->cosinus_lambda[4] = localB->N;
      localB->cosinus_lambda[7] = 0.0;
      localB->cosinus_phi[0] = localB->cosinus_phi_d;
      localB->cosinus_phi[3] = 0.0;
      localB->cosinus_phi[6] = localB->oldh;
      localB->cosinus_lambda[2] = 0.0;
      localB->cosinus_phi[1] = 0.0;
      localB->cosinus_lambda[5] = 0.0;
      localB->cosinus_phi[4] = 1.0;
      localB->cosinus_lambda[8] = 1.0;
      localB->cosinus_phi[7] = 0.0;
      localB->cosinus_phi[2] = -localB->oldh;
      localB->cosinus_phi[5] = 0.0;
      localB->cosinus_phi[8] = localB->cosinus_phi_d;
      for (localB->k = 0; localB->k < 3; localB->k++) {
        for (localB->boffset = 0; localB->boffset < 3; localB->boffset++) {
          localB->loop_ub = 3 * localB->boffset + localB->k;
          localB->cosinus_lambda_m[localB->loop_ub] = 0.0;
          localB->cosinus_lambda_m[localB->loop_ub] += localB->cosinus_phi[3 *
            localB->k] * localB->cosinus_lambda[localB->boffset];
          localB->cosinus_lambda_m[localB->loop_ub] += localB->cosinus_phi[3 *
            localB->k + 1] * localB->cosinus_lambda[localB->boffset + 3];
          localB->cosinus_lambda_m[localB->loop_ub] += localB->cosinus_phi[3 *
            localB->k + 2] * localB->cosinus_lambda[localB->boffset + 6];
        }

        localB->user_state_pre_j[localB->k] = localB->user_state_pre[localB->k]
          - localB->satellitePosition_ecef_data
          [localB->satellitePosition_ecef_size[0] * localB->k + localB->coffset];
      }

      for (localB->k = 0; localB->k <= 0; localB->k += 2) {
        tmp_0 = _mm_loadu_pd(&localB->cosinus_lambda_m[localB->k]);
        tmp_1 = _mm_loadu_pd(&localB->cosinus_lambda_m[localB->k + 3]);
        tmp_2 = _mm_loadu_pd(&localB->cosinus_lambda_m[localB->k + 6]);
        _mm_storeu_pd(&localB->satellitePosition_ned[localB->k], _mm_add_pd
                      (_mm_mul_pd(tmp_2, _mm_set1_pd(localB->user_state_pre_j[2])),
                       _mm_add_pd(_mm_mul_pd(tmp_1, _mm_set1_pd
          (localB->user_state_pre_j[1])), _mm_add_pd(_mm_mul_pd(tmp_0,
          _mm_set1_pd(localB->user_state_pre_j[0])), _mm_set1_pd(0.0)))));
      }

      for (localB->k = 2; localB->k < 3; localB->k++) {
        localB->satellitePosition_ned[localB->k] = (localB->
          cosinus_lambda_m[localB->k + 3] * localB->user_state_pre_j[1] +
          localB->cosinus_lambda_m[localB->k] * localB->user_state_pre_j[0]) +
          localB->cosinus_lambda_m[localB->k + 6] * localB->user_state_pre_j[2];
      }
    } else {
      DDRTCM_binary_expand_op_mzk(localB->satellitePosition_ned, localB->N,
        localB->sinus_lambda, ab, localB->cosinus_phi_d, localB->oldh, bb,
        localB->user_state_pre, localB->satellitePosition_ecef_data,
        localB->satellitePosition_ecef_size, localB->coffset,
        e_GNSS_Measurement_satellite__0, localB);
    }

    localB->sinus_lambda = 3.3121686421112381E-170;
    localB->N = std::abs(localB->satellitePosition_ned[0]);
    if (localB->N > 3.3121686421112381E-170) {
      localB->cosinus_phi_d = 1.0;
      localB->sinus_lambda = localB->N;
    } else {
      localB->oldh = localB->N / 3.3121686421112381E-170;
      localB->cosinus_phi_d = localB->oldh * localB->oldh;
    }

    localB->N = std::abs(localB->satellitePosition_ned[1]);
    if (localB->N > localB->sinus_lambda) {
      localB->oldh = localB->sinus_lambda / localB->N;
      localB->cosinus_phi_d = localB->cosinus_phi_d * localB->oldh *
        localB->oldh + 1.0;
      localB->sinus_lambda = localB->N;
    } else {
      localB->oldh = localB->N / localB->sinus_lambda;
      localB->cosinus_phi_d += localB->oldh * localB->oldh;
    }

    localB->N = std::abs(localB->satellitePosition_ned[2]);
    if (localB->N > localB->sinus_lambda) {
      localB->oldh = localB->sinus_lambda / localB->N;
      localB->cosinus_phi_d = localB->cosinus_phi_d * localB->oldh *
        localB->oldh + 1.0;
      localB->sinus_lambda = localB->N;
    } else {
      localB->oldh = localB->N / localB->sinus_lambda;
      localB->cosinus_phi_d += localB->oldh * localB->oldh;
    }

    localB->cosinus_phi_d = localB->sinus_lambda * std::sqrt
      (localB->cosinus_phi_d);
    H_data[localB->coffset] = localB->satellitePosition_ned[0] /
      localB->cosinus_phi_d;
    H_data[localB->coffset + H_size[0]] = localB->satellitePosition_ned[1] /
      localB->cosinus_phi_d;
    H_data[localB->coffset + (H_size[0] << 1)] = localB->satellitePosition_ned[2]
      / localB->cosinus_phi_d;
    H_data[localB->coffset + H_size[0] * 3] = 1.0;
  }

  if (localB->h_size < 1) {
    localB->trueCount = 0;
  } else {
    localB->trueCount = localB->h_size;
  }

  localB->matrix_pseudorange_variance_siz[0] = static_cast<int8_T>
    (localB->trueCount);
  localB->matrix_pseudorange_variance_siz[1] = static_cast<int8_T>
    (localB->trueCount);
  localB->loop_ub = static_cast<int8_T>(localB->trueCount) * static_cast<int8_T>
    (localB->trueCount);
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&localB->matrix_pseudorange_variance_dat[0], 0,
                static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
  }

  for (localB->k = 0; localB->k < localB->trueCount; localB->k++) {
    localB->matrix_pseudorange_variance_dat[localB->k + static_cast<int8_T>
      (localB->trueCount) * localB->k] = e_GNSS_Measurement_variance_pse
      [localB->k];
  }

  DDRTCM_inv(localB->matrix_pseudorange_variance_dat,
             localB->matrix_pseudorange_variance_siz, W_data, W_size, localB);
  localB->loop_ub = localB->h_size;
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&localB->pseudorange_pre_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub) * sizeof(real_T));
  }

  localB->k = localB->h_size;
  for (localB->trueCount = 0; localB->trueCount < localB->k; localB->trueCount++)
  {
    if (e_GNSS_Measurement_satellite__0[1] == 3) {
      localB->position_llh[0] = localB->user_state_pre[0] -
        localB->satellitePosition_ecef_data[localB->trueCount];
      localB->position_llh[1] = localB->user_state_pre[1] -
        localB->satellitePosition_ecef_data[localB->trueCount +
        localB->satellitePosition_ecef_size[0]];
      localB->position_llh[2] = localB->user_state_pre[2] -
        localB->satellitePosition_ecef_data[(localB->
        satellitePosition_ecef_size[0] << 1) + localB->trueCount];
    } else {
      DDRTCM_binary_expand_op_mzk3(localB->position_llh, localB->user_state_pre,
        localB->satellitePosition_ecef_data, localB->satellitePosition_ecef_size,
        localB->trueCount, e_GNSS_Measurement_satellite__0);
    }

    localB->sinus_lambda = 3.3121686421112381E-170;
    localB->N = std::abs(localB->position_llh[0]);
    if (localB->N > 3.3121686421112381E-170) {
      localB->cosinus_phi_d = 1.0;
      localB->sinus_lambda = localB->N;
    } else {
      localB->oldh = localB->N / 3.3121686421112381E-170;
      localB->cosinus_phi_d = localB->oldh * localB->oldh;
    }

    localB->N = std::abs(localB->position_llh[1]);
    if (localB->N > localB->sinus_lambda) {
      localB->oldh = localB->sinus_lambda / localB->N;
      localB->cosinus_phi_d = localB->cosinus_phi_d * localB->oldh *
        localB->oldh + 1.0;
      localB->sinus_lambda = localB->N;
    } else {
      localB->oldh = localB->N / localB->sinus_lambda;
      localB->cosinus_phi_d += localB->oldh * localB->oldh;
    }

    localB->N = std::abs(localB->position_llh[2]);
    if (localB->N > localB->sinus_lambda) {
      localB->oldh = localB->sinus_lambda / localB->N;
      localB->cosinus_phi_d = localB->cosinus_phi_d * localB->oldh *
        localB->oldh + 1.0;
      localB->sinus_lambda = localB->N;
    } else {
      localB->oldh = localB->N / localB->sinus_lambda;
      localB->cosinus_phi_d += localB->oldh * localB->oldh;
    }

    localB->pseudorange_pre_data[localB->trueCount] = localB->sinus_lambda * std::
      sqrt(localB->cosinus_phi_d) + clockerror;
  }

  *y_size = localB->h_size;
  localB->loop_ub = localB->h_size;
  for (localB->k = 0; localB->k < localB->loop_ub; localB->k++) {
    y_data[localB->k] = e_GNSS_Measurement_pseudorange_[localB->h_data[localB->k]
      - 1] - localB->pseudorange_pre_data[localB->k];
  }

  localB->k = W_size[1];
  for (localB->trueCount = 0; localB->trueCount < localB->k; localB->trueCount++)
  {
    localB->coffset = localB->trueCount << 2;
    localB->boffset = localB->trueCount * W_size[0];
    localB->b_y_data[localB->coffset] = 0.0;
    localB->b_y_data[localB->coffset + 1] = 0.0;
    localB->b_y_data[localB->coffset + 2] = 0.0;
    localB->b_y_data[localB->coffset + 3] = 0.0;
    localB->loop_ub = H_size[0];
    for (localB->aoffset = 0; localB->aoffset < localB->loop_ub; localB->aoffset
         ++) {
      localB->sinus_lambda = W_data[localB->boffset + localB->aoffset];
      localB->b_y_data[localB->coffset] += H_data[localB->aoffset] *
        localB->sinus_lambda;
      localB->b_y_data[localB->coffset + 1] += H_data[H_size[0] +
        localB->aoffset] * localB->sinus_lambda;
      localB->b_y_data[localB->coffset + 2] += H_data[(H_size[0] << 1) +
        localB->aoffset] * localB->sinus_lambda;
      localB->b_y_data[localB->coffset + 3] += H_data[3 * H_size[0] +
        localB->aoffset] * localB->sinus_lambda;
    }
  }

  localB->k = W_size[1];
  for (localB->trueCount = 0; localB->trueCount < 4; localB->trueCount++) {
    localB->coffset = localB->trueCount << 2;
    localB->boffset = localB->trueCount * H_size[0];
    localB->c_y[localB->coffset] = 0.0;
    localB->c_y[localB->coffset + 1] = 0.0;
    localB->c_y[localB->coffset + 2] = 0.0;
    localB->c_y[localB->coffset + 3] = 0.0;
    for (localB->loop_ub = 0; localB->loop_ub < localB->k; localB->loop_ub++) {
      localB->aoffset = localB->loop_ub << 2;
      localB->sinus_lambda = H_data[localB->boffset + localB->loop_ub];
      localB->c_y[localB->coffset] += localB->b_y_data[localB->aoffset] *
        localB->sinus_lambda;
      localB->c_y[localB->coffset + 1] += localB->b_y_data[localB->aoffset + 1] *
        localB->sinus_lambda;
      localB->c_y[localB->coffset + 2] += localB->b_y_data[localB->aoffset + 2] *
        localB->sinus_lambda;
      localB->c_y[localB->coffset + 3] += localB->b_y_data[localB->aoffset + 3] *
        localB->sinus_lambda;
    }
  }

  localB->A_size[0] = 4;
  localB->A_size[1] = localB->h_size;
  localB->loop_ub = localB->h_size;
  for (localB->k = 0; localB->k < localB->loop_ub; localB->k++) {
    localB->A_data_c[localB->k << 2] = H_data[localB->k];
    localB->A_data_c[1 + (localB->k << 2)] = H_data[localB->k + H_size[0]];
    localB->A_data_c[2 + (localB->k << 2)] = H_data[(H_size[0] << 1) + localB->k];
    localB->A_data_c[3 + (localB->k << 2)] = H_data[H_size[0] * 3 + localB->k];
  }

  DDRTCM_mldivide(localB->c_y, localB->A_data_c, localB->A_size,
                  localB->b_y_data, localB->satellitePosition_ecef_size, localB);
  localB->k = W_size[1];
  for (localB->trueCount = 0; localB->trueCount < localB->k; localB->trueCount++)
  {
    localB->coffset = localB->trueCount << 2;
    localB->boffset = localB->trueCount * W_size[0];
    localB->A_data_c[localB->coffset] = 0.0;
    localB->A_data_c[localB->coffset + 1] = 0.0;
    localB->A_data_c[localB->coffset + 2] = 0.0;
    localB->A_data_c[localB->coffset + 3] = 0.0;
    localB->loop_ub = localB->satellitePosition_ecef_size[1];
    for (localB->aoffset = 0; localB->aoffset < localB->loop_ub; localB->aoffset
         ++) {
      localB->b_aoffset = localB->aoffset << 2;
      localB->sinus_lambda = W_data[localB->boffset + localB->aoffset];
      localB->A_data_c[localB->coffset] += localB->b_y_data[localB->b_aoffset] *
        localB->sinus_lambda;
      localB->A_data_c[localB->coffset + 1] += localB->b_y_data
        [localB->b_aoffset + 1] * localB->sinus_lambda;
      localB->A_data_c[localB->coffset + 2] += localB->b_y_data
        [localB->b_aoffset + 2] * localB->sinus_lambda;
      localB->A_data_c[localB->coffset + 3] += localB->b_y_data
        [localB->b_aoffset + 3] * localB->sinus_lambda;
    }
  }

  localB->S_size[0] = localB->h_size;
  localB->S_size[1] = localB->h_size;
  localB->loop_ub = localB->h_size * localB->h_size;
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&localB->S_data[0], 0, static_cast<uint32_T>(localB->loop_ub) *
                sizeof(real_T));
  }

  if (localB->h_size > 0) {
    localB->k = localB->h_size;
    for (localB->trueCount = 0; localB->trueCount < localB->k; localB->trueCount
         ++) {
      localB->S_data[localB->trueCount + localB->S_size[0] * localB->trueCount] =
        1.0;
    }
  }

  localB->k = localB->h_size;
  localB->f_size[0] = localB->h_size;
  localB->f_size[1] = W_size[1];
  localB->boffset = W_size[1];
  for (localB->loop_ub = 0; localB->loop_ub < localB->boffset; localB->loop_ub++)
  {
    localB->aoffset = localB->loop_ub * localB->k;
    localB->b_aoffset = localB->loop_ub << 2;
    localB->trueCount = (localB->k / 2) << 1;
    localB->coffset = localB->trueCount - 2;
    for (localB->m_i = 0; localB->m_i <= localB->coffset; localB->m_i += 2) {
      __m128d tmp;
      tmp_0 = _mm_loadu_pd(&H_data[localB->m_i]);
      tmp_1 = _mm_loadu_pd(&H_data[H_size[0] + localB->m_i]);
      tmp_2 = _mm_loadu_pd(&H_data[(H_size[0] << 1) + localB->m_i]);
      tmp = _mm_loadu_pd(&H_data[3 * H_size[0] + localB->m_i]);
      _mm_storeu_pd(&localB->f_data[localB->aoffset + localB->m_i], _mm_add_pd
                    (_mm_add_pd(_mm_add_pd(_mm_mul_pd(tmp_0, _mm_set1_pd
        (localB->A_data_c[localB->b_aoffset])), _mm_mul_pd(tmp_1, _mm_set1_pd
        (localB->A_data_c[localB->b_aoffset + 1]))), _mm_mul_pd(tmp_2,
        _mm_set1_pd(localB->A_data_c[localB->b_aoffset + 2]))), _mm_mul_pd(tmp,
        _mm_set1_pd(localB->A_data_c[localB->b_aoffset + 3]))));
    }

    for (localB->m_i = localB->trueCount; localB->m_i < localB->k; localB->m_i++)
    {
      localB->f_data[localB->aoffset + localB->m_i] = ((H_data[H_size[0] +
        localB->m_i] * localB->A_data_c[localB->b_aoffset + 1] + H_data
        [localB->m_i] * localB->A_data_c[localB->b_aoffset]) + H_data[(H_size[0]
        << 1) + localB->m_i] * localB->A_data_c[localB->b_aoffset + 2]) +
        H_data[3 * H_size[0] + localB->m_i] * localB->A_data_c[localB->b_aoffset
        + 3];
    }
  }

  if (localB->h_size == W_size[1]) {
    localB->loop_ub = localB->h_size * localB->h_size;
    localB->trueCount = (localB->loop_ub / 2) << 1;
    localB->coffset = localB->trueCount - 2;
    for (localB->boffset = 0; localB->boffset <= localB->coffset;
         localB->boffset += 2) {
      tmp_0 = _mm_loadu_pd(&localB->S_data[localB->boffset]);
      tmp_1 = _mm_loadu_pd(&localB->f_data[localB->boffset]);
      _mm_storeu_pd(&localB->S_data[localB->boffset], _mm_sub_pd(tmp_0, tmp_1));
    }

    for (localB->boffset = localB->trueCount; localB->boffset < localB->loop_ub;
         localB->boffset++) {
      localB->S_data[localB->boffset] -= localB->f_data[localB->boffset];
    }
  } else {
    DDRTCM_minus_m(localB->S_data, localB->S_size, localB->f_data,
                   localB->f_size, localB);
  }

  DDRTCM_mtimes(localB->S_data, localB->S_size, y_data,
                localB->pseudorange_pre_data, &localB->pseudorange_pre_size,
                localB);
  localB->aoffset = W_size[1];
  localB->k = W_size[1];
  for (localB->trueCount = 0; localB->trueCount < localB->k; localB->trueCount++)
  {
    localB->coffset = localB->trueCount * W_size[0];
    localB->d_y_data[localB->trueCount] = 0.0;
    localB->boffset = localB->pseudorange_pre_size;
    for (localB->loop_ub = 0; localB->loop_ub < localB->boffset; localB->loop_ub
         ++) {
      localB->d_y_data[localB->trueCount] += W_data[localB->coffset +
        localB->loop_ub] * localB->pseudorange_pre_data[localB->loop_ub];
    }
  }

  localB->sinus_lambda = 0.0;
  for (localB->k = 0; localB->k < localB->aoffset; localB->k++) {
    localB->sinus_lambda += localB->d_y_data[localB->k] *
      localB->pseudorange_pre_data[localB->k];
  }

  *test_statistic = std::sqrt(localB->sinus_lambda);
  localB->cosinus_phi_d = static_cast<real_T>(localB->h_size) - m;
  *threshold = std::sqrt(b_table_chi_square[static_cast<int32_T>
    (localB->cosinus_phi_d) - 1]);
  localB->pseudorange_pre_size = localB->h_size;
  localB->loop_ub = localB->h_size;
  if (localB->loop_ub - 1 >= 0) {
    std::memset(&localB->pseudorange_pre_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub) * sizeof(real_T));
  }

  localB->k = localB->h_size;
  for (localB->trueCount = 0; localB->trueCount < localB->k; localB->trueCount++)
  {
    localB->sinus_lambda = localB->A_data_c[localB->trueCount << 2];
    localB->N = localB->A_data_c[(localB->trueCount << 2) + 1];
    localB->pseudorange_pre_data[localB->trueCount] = std::sqrt
      ((localB->sinus_lambda * localB->sinus_lambda + localB->N * localB->N) /
       localB->S_data[localB->S_size[0] * localB->trueCount + localB->trueCount])
      * std::sqrt(localB->matrix_pseudorange_variance_dat
                  [localB->matrix_pseudorange_variance_siz[0] *
                  localB->trueCount + localB->trueCount]);
  }

  *HPL = std::sqrt(b_table_chi_square[static_cast<int32_T>(localB->cosinus_phi_d)
                   + 39] / localB->cosinus_phi_d) * DDRTCM_maximum
    (localB->pseudorange_pre_data, &localB->pseudorange_pre_size);
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_sqrt_le(real_T x_data[], const int32_T x_size[2])
{
  int32_T b_tmp;
  int32_T scalarLB;
  int32_T vectorUB;
  b_tmp = x_size[0] * x_size[1];
  scalarLB = (b_tmp / 2) << 1;
  vectorUB = scalarLB - 2;
  for (int32_T k{0}; k <= vectorUB; k += 2) {
    __m128d tmp;
    tmp = _mm_loadu_pd(&x_data[k]);
    _mm_storeu_pd(&x_data[k], _mm_sqrt_pd(tmp));
  }

  for (int32_T k{scalarLB}; k < b_tmp; k++) {
    x_data[k] = std::sqrt(x_data[k]);
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_mtimes_j(const real_T A_data[], const int32_T A_size[2],
  const real_T B_data[], const int32_T B_size[2], real_T C_data[], int32_T
  C_size[2])
{
  int32_T c;
  int32_T mc;
  mc = A_size[0] - 1;
  C_size[0] = A_size[0];
  C_size[1] = 4;
  c = A_size[1];
  for (int32_T j{0}; j < 4; j++) {
    int32_T boffset;
    int32_T coffset;
    coffset = (mc + 1) * j;
    boffset = j * B_size[0];
    if (mc >= 0) {
      std::memset(&C_data[coffset], 0, static_cast<uint32_T>(((mc + coffset) -
        coffset) + 1) * sizeof(real_T));
    }

    for (int32_T i{0}; i < c; i++) {
      real_T bkj;
      int32_T aoffset;
      int32_T scalarLB;
      int32_T tmp_0;
      int32_T vectorUB;
      aoffset = i * A_size[0];
      bkj = B_data[boffset + i];
      scalarLB = ((mc + 1) / 2) << 1;
      vectorUB = scalarLB - 2;
      for (int32_T b_i{0}; b_i <= vectorUB; b_i += 2) {
        __m128d tmp;
        tmp_0 = coffset + b_i;
        tmp = _mm_loadu_pd(&C_data[tmp_0]);
        _mm_storeu_pd(&C_data[tmp_0], _mm_add_pd(_mm_mul_pd(_mm_loadu_pd
          (&A_data[aoffset + b_i]), _mm_set1_pd(bkj)), tmp));
      }

      for (int32_T b_i{scalarLB}; b_i <= mc; b_i++) {
        tmp_0 = coffset + b_i;
        C_data[tmp_0] += A_data[aoffset + b_i] * bkj;
      }
    }
  }
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
boolean_T DDRTCM::DDRTCM_any_e(const boolean_T x[40])
{
  int32_T k;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 40)) {
    if (x[k]) {
      y = true;
      exitg1 = true;
    } else {
      k++;
    }
  }

  return y;
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
real_T DDRTCM::DDRTCM_xnrm2(int32_T n, const real_T x_data[], int32_T ix0,
  B_MATLABFunction_DDRTCM_T *localB)
{
  real_T y;
  y = 0.0;
  if (n >= 1) {
    if (n == 1) {
      y = std::abs(x_data[ix0 - 1]);
    } else {
      localB->scale = 3.3121686421112381E-170;
      localB->kend = (ix0 + n) - 1;
      for (localB->k_m = ix0; localB->k_m <= localB->kend; localB->k_m++) {
        localB->absxk = std::abs(x_data[localB->k_m - 1]);
        if (localB->absxk > localB->scale) {
          localB->t = localB->scale / localB->absxk;
          y = y * localB->t * localB->t + 1.0;
          localB->scale = localB->absxk;
        } else {
          localB->t = localB->absxk / localB->scale;
          y += localB->t * localB->t;
        }
      }

      y = localB->scale * std::sqrt(y);
    }
  }

  return y;
}

real_T rt_hypotd_snf(real_T u0, real_T u1)
{
  real_T a;
  real_T b;
  real_T y;
  a = std::abs(u0);
  b = std::abs(u1);
  if (a < b) {
    a /= b;
    y = std::sqrt(a * a + 1.0) * b;
  } else if (a > b) {
    b /= a;
    y = std::sqrt(b * b + 1.0) * a;
  } else if (std::isnan(b)) {
    y = (rtNaN);
  } else {
    y = a * 1.4142135623730951;
  }

  return y;
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_xgemv(int32_T m, int32_T n, const real_T A_data[], int32_T
  ia0, int32_T lda, const real_T x_data[], int32_T ix0, real_T y_data[])
{
  if (n != 0) {
    int32_T b;
    int32_T iy;
    if (n - 1 >= 0) {
      std::memset(&y_data[0], 0, static_cast<uint32_T>(n) * sizeof(real_T));
    }

    iy = 0;
    b = (n - 1) * lda + ia0;
    for (int32_T b_iy{ia0}; lda < 0 ? b_iy >= b : b_iy <= b; b_iy += lda) {
      real_T c;
      int32_T d;
      c = 0.0;
      d = b_iy + m;
      for (int32_T ia{b_iy}; ia < d; ia++) {
        c += x_data[((ix0 + ia) - b_iy) - 1] * A_data[ia - 1];
      }

      y_data[iy] += c;
      iy++;
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_xgerc(int32_T m, int32_T n, real_T alpha1, int32_T ix0,
  const real_T y_data[], real_T A_data[], int32_T ia0, int32_T lda)
{
  if (!(alpha1 == 0.0)) {
    int32_T jA;
    jA = ia0;
    for (int32_T j{0}; j < n; j++) {
      real_T temp;
      temp = y_data[j];
      if (temp != 0.0) {
        int32_T b;
        temp *= alpha1;
        b = m + jA;
        for (int32_T ijA{jA}; ijA < b; ijA++) {
          A_data[ijA - 1] += A_data[((ix0 + ijA) - jA) - 1] * temp;
        }
      }

      jA += lda;
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_xgeqrf(real_T A_data[], const int32_T A_size[2], real_T
  tau_data[], int32_T *tau_size, B_MATLABFunction_DDRTCM_T *localB)
{
  localB->m_ic = A_size[0];
  localB->n = A_size[1];
  if (A_size[0] <= A_size[1]) {
    localB->minmana = A_size[0];
  } else {
    localB->minmana = A_size[1];
  }

  if (A_size[0] <= A_size[1]) {
    localB->minmn = A_size[0];
  } else {
    localB->minmn = A_size[1];
  }

  *tau_size = localB->minmana;
  if (localB->minmana - 1 >= 0) {
    std::memset(&tau_data[0], 0, static_cast<uint32_T>(localB->minmana) * sizeof
                (real_T));
  }

  if ((A_size[0] != 0) && (A_size[1] != 0) && (localB->minmn >= 1)) {
    *tau_size = localB->minmana;
    if (localB->minmana - 1 >= 0) {
      std::memset(&tau_data[0], 0, static_cast<uint32_T>(localB->minmana) *
                  sizeof(real_T));
    }

    localB->minmana = A_size[0];
    localB->ii = A_size[1];
    if (localB->ii - 1 >= 0) {
      std::memset(&localB->work_data_b[0], 0, static_cast<uint32_T>(localB->ii) *
                  sizeof(real_T));
    }

    for (localB->i_o = 0; localB->i_o < localB->minmn; localB->i_o++) {
      localB->ii = localB->i_o * localB->minmana + localB->i_o;
      localB->mmi = localB->m_ic - localB->i_o;
      if (localB->i_o + 1 < localB->m_ic) {
        localB->atmp = A_data[localB->ii];
        localB->ix0 = localB->ii + 2;
        tau_data[localB->i_o] = 0.0;
        if (localB->mmi > 0) {
          localB->xnorm = DDRTCM_xnrm2(localB->mmi - 1, A_data, localB->ii + 2,
            localB);
          if (localB->xnorm != 0.0) {
            localB->xnorm = rt_hypotd_snf(A_data[localB->ii], localB->xnorm);
            if (A_data[localB->ii] >= 0.0) {
              localB->xnorm = -localB->xnorm;
            }

            if (std::abs(localB->xnorm) < 1.0020841800044864E-292) {
              __m128d tmp;
              localB->knt = 0;
              localB->d_n = localB->ii + localB->mmi;
              do {
                localB->knt++;
                localB->coltop = (((((localB->d_n - localB->ii) - 1) / 2) << 1)
                                  + localB->ii) + 2;
                localB->vectorUB = localB->coltop - 2;
                for (localB->mmip1 = localB->ix0; localB->mmip1 <=
                     localB->vectorUB; localB->mmip1 += 2) {
                  tmp = _mm_loadu_pd(&A_data[localB->mmip1 - 1]);
                  _mm_storeu_pd(&A_data[localB->mmip1 - 1], _mm_mul_pd(tmp,
                    _mm_set1_pd(9.9792015476736E+291)));
                }

                for (localB->mmip1 = localB->coltop; localB->mmip1 <=
                     localB->d_n; localB->mmip1++) {
                  A_data[localB->mmip1 - 1] *= 9.9792015476736E+291;
                }

                localB->xnorm *= 9.9792015476736E+291;
                localB->atmp *= 9.9792015476736E+291;
              } while ((std::abs(localB->xnorm) < 1.0020841800044864E-292) &&
                       (localB->knt < 20));

              localB->xnorm = rt_hypotd_snf(localB->atmp, DDRTCM_xnrm2
                (localB->mmi - 1, A_data, localB->ii + 2, localB));
              if (localB->atmp >= 0.0) {
                localB->xnorm = -localB->xnorm;
              }

              tau_data[localB->i_o] = (localB->xnorm - localB->atmp) /
                localB->xnorm;
              localB->atmp = 1.0 / (localB->atmp - localB->xnorm);
              localB->d_n = localB->ii + localB->mmi;
              localB->coltop = (((((localB->d_n - localB->ii) - 1) / 2) << 1) +
                                localB->ii) + 2;
              localB->vectorUB = localB->coltop - 2;
              for (localB->mmip1 = localB->ix0; localB->mmip1 <=
                   localB->vectorUB; localB->mmip1 += 2) {
                tmp = _mm_loadu_pd(&A_data[localB->mmip1 - 1]);
                _mm_storeu_pd(&A_data[localB->mmip1 - 1], _mm_mul_pd(tmp,
                  _mm_set1_pd(localB->atmp)));
              }

              for (localB->mmip1 = localB->coltop; localB->mmip1 <= localB->d_n;
                   localB->mmip1++) {
                A_data[localB->mmip1 - 1] *= localB->atmp;
              }

              for (localB->ix0 = 0; localB->ix0 < localB->knt; localB->ix0++) {
                localB->xnorm *= 1.0020841800044864E-292;
              }

              localB->atmp = localB->xnorm;
            } else {
              tau_data[localB->i_o] = (localB->xnorm - A_data[localB->ii]) /
                localB->xnorm;
              localB->atmp = 1.0 / (A_data[localB->ii] - localB->xnorm);
              localB->mmip1 = localB->ii + localB->mmi;
              localB->coltop = (((((localB->mmip1 - localB->ii) - 1) / 2) << 1)
                                + localB->ii) + 2;
              localB->vectorUB = localB->coltop - 2;
              for (localB->knt = localB->ix0; localB->knt <= localB->vectorUB;
                   localB->knt += 2) {
                __m128d tmp;
                tmp = _mm_loadu_pd(&A_data[localB->knt - 1]);
                _mm_storeu_pd(&A_data[localB->knt - 1], _mm_mul_pd(tmp,
                  _mm_set1_pd(localB->atmp)));
              }

              for (localB->knt = localB->coltop; localB->knt <= localB->mmip1;
                   localB->knt++) {
                A_data[localB->knt - 1] *= localB->atmp;
              }

              localB->atmp = localB->xnorm;
            }
          }
        }

        A_data[localB->ii] = localB->atmp;
      } else {
        tau_data[localB->i_o] = 0.0;
      }

      if (localB->i_o + 1 < localB->n) {
        localB->xnorm = A_data[localB->ii];
        A_data[localB->ii] = 1.0;
        localB->ix0 = (localB->ii + localB->minmana) + 1;
        if (tau_data[localB->i_o] != 0.0) {
          boolean_T exitg2;
          localB->mmip1 = localB->ii + localB->mmi;
          while ((localB->mmi > 0) && (A_data[localB->mmip1 - 1] == 0.0)) {
            localB->mmi--;
            localB->mmip1--;
          }

          localB->mmip1 = (localB->n - localB->i_o) - 1;
          exitg2 = false;
          while ((!exitg2) && (localB->mmip1 > 0)) {
            int32_T exitg1;
            localB->coltop = (localB->mmip1 - 1) * localB->minmana + localB->ix0;
            localB->vectorUB = localB->coltop;
            do {
              exitg1 = 0;
              if (localB->vectorUB <= (localB->coltop + localB->mmi) - 1) {
                if (A_data[localB->vectorUB - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  localB->vectorUB++;
                }
              } else {
                localB->mmip1--;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }
        } else {
          localB->mmi = 0;
          localB->mmip1 = 0;
        }

        if (localB->mmi > 0) {
          DDRTCM_xgemv(localB->mmi, localB->mmip1, A_data, localB->ix0,
                       localB->minmana, A_data, localB->ii + 1,
                       localB->work_data_b);
          DDRTCM_xgerc(localB->mmi, localB->mmip1, -tau_data[localB->i_o],
                       localB->ii + 1, localB->work_data_b, A_data, localB->ix0,
                       localB->minmana);
        }

        A_data[localB->ii] = localB->xnorm;
      }
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
real_T DDRTCM::DDRTCM_xnrm2_a(int32_T n, const real_T x_data[], int32_T ix0,
  B_MATLABFunction_DDRTCM_T *localB)
{
  real_T y;
  y = 0.0;
  if (n >= 1) {
    if (n == 1) {
      y = std::abs(x_data[ix0 - 1]);
    } else {
      localB->scale_d = 3.3121686421112381E-170;
      localB->kend_m = (ix0 + n) - 1;
      for (localB->k_mj = ix0; localB->k_mj <= localB->kend_m; localB->k_mj++) {
        localB->absxk_e = std::abs(x_data[localB->k_mj - 1]);
        if (localB->absxk_e > localB->scale_d) {
          localB->t_bj = localB->scale_d / localB->absxk_e;
          y = y * localB->t_bj * localB->t_bj + 1.0;
          localB->scale_d = localB->absxk_e;
        } else {
          localB->t_bj = localB->absxk_e / localB->scale_d;
          y += localB->t_bj * localB->t_bj;
        }
      }

      y = localB->scale_d * std::sqrt(y);
    }
  }

  return y;
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_xgemv_k(int32_T m, int32_T n, const real_T A_data[], int32_T
  ia0, int32_T lda, const real_T x_data[], int32_T ix0, real_T y[4])
{
  if (n != 0) {
    int32_T b;
    int32_T iy;
    if (n - 1 >= 0) {
      std::memset(&y[0], 0, static_cast<uint32_T>(n) * sizeof(real_T));
    }

    iy = 0;
    b = (n - 1) * lda + ia0;
    for (int32_T b_iy{ia0}; lda < 0 ? b_iy >= b : b_iy <= b; b_iy += lda) {
      real_T c;
      int32_T d;
      c = 0.0;
      d = b_iy + m;
      for (int32_T ia{b_iy}; ia < d; ia++) {
        c += x_data[((ix0 + ia) - b_iy) - 1] * A_data[ia - 1];
      }

      y[iy] += c;
      iy++;
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_xgerc_m(int32_T m, int32_T n, real_T alpha1, int32_T ix0,
  const real_T y[4], real_T A_data[], int32_T ia0, int32_T lda)
{
  if (!(alpha1 == 0.0)) {
    int32_T jA;
    jA = ia0;
    for (int32_T j{0}; j < n; j++) {
      real_T temp;
      temp = y[j];
      if (temp != 0.0) {
        int32_T b;
        temp *= alpha1;
        b = m + jA;
        for (int32_T ijA{jA}; ijA < b; ijA++) {
          A_data[ijA - 1] += A_data[((ix0 + ijA) - jA) - 1] * temp;
        }
      }

      jA += lda;
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_xgeqrf_d(real_T A_data[], const int32_T A_size[2], real_T
  tau_data[], int32_T *tau_size, B_MATLABFunction_DDRTCM_T *localB)
{
  localB->m_if = A_size[0];
  if (A_size[0] <= 4) {
    localB->minmana_l = A_size[0];
  } else {
    localB->minmana_l = 4;
  }

  if (A_size[0] <= 4) {
    localB->minmn_o = A_size[0];
  } else {
    localB->minmn_o = 4;
  }

  *tau_size = localB->minmana_l;
  if (localB->minmana_l - 1 >= 0) {
    std::memset(&tau_data[0], 0, static_cast<uint32_T>(localB->minmana_l) *
                sizeof(real_T));
  }

  if ((A_size[0] != 0) && (localB->minmn_o >= 1)) {
    *tau_size = localB->minmana_l;
    if (localB->minmana_l - 1 >= 0) {
      std::memset(&tau_data[0], 0, static_cast<uint32_T>(localB->minmana_l) *
                  sizeof(real_T));
    }

    localB->minmana_l = A_size[0];
    localB->work[0] = 0.0;
    localB->work[1] = 0.0;
    localB->work[2] = 0.0;
    localB->work[3] = 0.0;
    for (localB->i_i = 0; localB->i_i < localB->minmn_o; localB->i_i++) {
      localB->ii_o = localB->i_i * localB->minmana_l + localB->i_i;
      localB->mmi_i = localB->m_if - localB->i_i;
      if (localB->i_i + 1 < localB->m_if) {
        localB->atmp_h = A_data[localB->ii_o];
        localB->ix0_f = localB->ii_o + 2;
        tau_data[localB->i_i] = 0.0;
        if (localB->mmi_i > 0) {
          localB->xnorm_b = DDRTCM_xnrm2_a(localB->mmi_i - 1, A_data,
            localB->ii_o + 2, localB);
          if (localB->xnorm_b != 0.0) {
            localB->xnorm_b = rt_hypotd_snf(A_data[localB->ii_o],
              localB->xnorm_b);
            if (A_data[localB->ii_o] >= 0.0) {
              localB->xnorm_b = -localB->xnorm_b;
            }

            if (std::abs(localB->xnorm_b) < 1.0020841800044864E-292) {
              __m128d tmp;
              localB->knt_g = 0;
              localB->d_c = localB->ii_o + localB->mmi_i;
              do {
                localB->knt_g++;
                localB->coltop_o = (((((localB->d_c - localB->ii_o) - 1) / 2) <<
                                     1) + localB->ii_o) + 2;
                localB->vectorUB_l = localB->coltop_o - 2;
                for (localB->mmip1_f = localB->ix0_f; localB->mmip1_f <=
                     localB->vectorUB_l; localB->mmip1_f += 2) {
                  tmp = _mm_loadu_pd(&A_data[localB->mmip1_f - 1]);
                  _mm_storeu_pd(&A_data[localB->mmip1_f - 1], _mm_mul_pd(tmp,
                    _mm_set1_pd(9.9792015476736E+291)));
                }

                for (localB->mmip1_f = localB->coltop_o; localB->mmip1_f <=
                     localB->d_c; localB->mmip1_f++) {
                  A_data[localB->mmip1_f - 1] *= 9.9792015476736E+291;
                }

                localB->xnorm_b *= 9.9792015476736E+291;
                localB->atmp_h *= 9.9792015476736E+291;
              } while ((std::abs(localB->xnorm_b) < 1.0020841800044864E-292) &&
                       (localB->knt_g < 20));

              localB->xnorm_b = rt_hypotd_snf(localB->atmp_h, DDRTCM_xnrm2_a
                (localB->mmi_i - 1, A_data, localB->ii_o + 2, localB));
              if (localB->atmp_h >= 0.0) {
                localB->xnorm_b = -localB->xnorm_b;
              }

              tau_data[localB->i_i] = (localB->xnorm_b - localB->atmp_h) /
                localB->xnorm_b;
              localB->atmp_h = 1.0 / (localB->atmp_h - localB->xnorm_b);
              localB->d_c = localB->ii_o + localB->mmi_i;
              localB->coltop_o = (((((localB->d_c - localB->ii_o) - 1) / 2) << 1)
                                  + localB->ii_o) + 2;
              localB->vectorUB_l = localB->coltop_o - 2;
              for (localB->mmip1_f = localB->ix0_f; localB->mmip1_f <=
                   localB->vectorUB_l; localB->mmip1_f += 2) {
                tmp = _mm_loadu_pd(&A_data[localB->mmip1_f - 1]);
                _mm_storeu_pd(&A_data[localB->mmip1_f - 1], _mm_mul_pd(tmp,
                  _mm_set1_pd(localB->atmp_h)));
              }

              for (localB->mmip1_f = localB->coltop_o; localB->mmip1_f <=
                   localB->d_c; localB->mmip1_f++) {
                A_data[localB->mmip1_f - 1] *= localB->atmp_h;
              }

              for (localB->ix0_f = 0; localB->ix0_f < localB->knt_g;
                   localB->ix0_f++) {
                localB->xnorm_b *= 1.0020841800044864E-292;
              }

              localB->atmp_h = localB->xnorm_b;
            } else {
              tau_data[localB->i_i] = (localB->xnorm_b - A_data[localB->ii_o]) /
                localB->xnorm_b;
              localB->atmp_h = 1.0 / (A_data[localB->ii_o] - localB->xnorm_b);
              localB->mmip1_f = localB->ii_o + localB->mmi_i;
              localB->coltop_o = (((((localB->mmip1_f - localB->ii_o) - 1) / 2) <<
                                   1) + localB->ii_o) + 2;
              localB->vectorUB_l = localB->coltop_o - 2;
              for (localB->knt_g = localB->ix0_f; localB->knt_g <=
                   localB->vectorUB_l; localB->knt_g += 2) {
                __m128d tmp;
                tmp = _mm_loadu_pd(&A_data[localB->knt_g - 1]);
                _mm_storeu_pd(&A_data[localB->knt_g - 1], _mm_mul_pd(tmp,
                  _mm_set1_pd(localB->atmp_h)));
              }

              for (localB->knt_g = localB->coltop_o; localB->knt_g <=
                   localB->mmip1_f; localB->knt_g++) {
                A_data[localB->knt_g - 1] *= localB->atmp_h;
              }

              localB->atmp_h = localB->xnorm_b;
            }
          }
        }

        A_data[localB->ii_o] = localB->atmp_h;
      } else {
        tau_data[localB->i_i] = 0.0;
      }

      if (localB->i_i + 1 < 4) {
        localB->xnorm_b = A_data[localB->ii_o];
        A_data[localB->ii_o] = 1.0;
        localB->ix0_f = (localB->ii_o + localB->minmana_l) + 1;
        if (tau_data[localB->i_i] != 0.0) {
          boolean_T exitg2;
          localB->mmip1_f = localB->ii_o + localB->mmi_i;
          while ((localB->mmi_i > 0) && (A_data[localB->mmip1_f - 1] == 0.0)) {
            localB->mmi_i--;
            localB->mmip1_f--;
          }

          localB->mmip1_f = 3 - localB->i_i;
          exitg2 = false;
          while ((!exitg2) && (localB->mmip1_f > 0)) {
            int32_T exitg1;
            localB->coltop_o = (localB->mmip1_f - 1) * localB->minmana_l +
              localB->ix0_f;
            localB->vectorUB_l = localB->coltop_o;
            do {
              exitg1 = 0;
              if (localB->vectorUB_l <= (localB->coltop_o + localB->mmi_i) - 1)
              {
                if (A_data[localB->vectorUB_l - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  localB->vectorUB_l++;
                }
              } else {
                localB->mmip1_f--;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }
        } else {
          localB->mmi_i = 0;
          localB->mmip1_f = 0;
        }

        if (localB->mmi_i > 0) {
          DDRTCM_xgemv_k(localB->mmi_i, localB->mmip1_f, A_data, localB->ix0_f,
                         localB->minmana_l, A_data, localB->ii_o + 1,
                         localB->work);
          DDRTCM_xgerc_m(localB->mmi_i, localB->mmip1_f, -tau_data[localB->i_i],
                         localB->ii_o + 1, localB->work, A_data, localB->ix0_f,
                         localB->minmana_l);
        }

        A_data[localB->ii_o] = localB->xnorm_b;
      }
    }
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_qr(const real_T A_data[], const int32_T A_size[2], real_T
  Q_data[], int32_T Q_size[2], real_T R_data[], int32_T R_size[2],
  B_MATLABFunction_DDRTCM_T *localB)
{
  localB->m = A_size[0];
  Q_size[0] = static_cast<int8_T>(A_size[0]);
  Q_size[1] = static_cast<int8_T>(A_size[0]);
  R_size[0] = A_size[0];
  R_size[1] = 4;
  if (A_size[0] > 4) {
    for (localB->b_itau = 0; localB->b_itau < 4; localB->b_itau++) {
      for (localB->l_i = 0; localB->l_i < localB->m; localB->l_i++) {
        Q_data[localB->l_i + Q_size[0] * localB->b_itau] = A_data[A_size[0] *
          localB->b_itau + localB->l_i];
      }
    }

    for (localB->b_itau = 5; localB->b_itau <= localB->m; localB->b_itau++) {
      for (localB->l_i = 0; localB->l_i < localB->m; localB->l_i++) {
        Q_data[localB->l_i + Q_size[0] * (localB->b_itau - 1)] = 0.0;
      }
    }

    DDRTCM_xgeqrf(Q_data, Q_size, localB->b_tau_data, &localB->tau_size, localB);
    for (localB->b_itau = 0; localB->b_itau < 4; localB->b_itau++) {
      for (localB->l_i = 0; localB->l_i <= localB->b_itau; localB->l_i++) {
        R_data[localB->l_i + R_size[0] * localB->b_itau] = Q_data[Q_size[0] *
          localB->b_itau + localB->l_i];
      }

      for (localB->l_i = localB->b_itau + 2; localB->l_i <= localB->m;
           localB->l_i++) {
        R_data[(localB->l_i + R_size[0] * localB->b_itau) - 1] = 0.0;
      }
    }

    localB->b_itau = A_size[0] - 1;
    for (localB->l_i = 4; localB->l_i <= localB->b_itau; localB->l_i++) {
      localB->b_ia = localB->l_i * localB->m;
      std::memset(&Q_data[localB->b_ia], 0, static_cast<uint32_T>((localB->m +
        localB->b_ia) - localB->b_ia) * sizeof(real_T));
      Q_data[localB->b_ia + localB->l_i] = 1.0;
    }

    localB->l_i = static_cast<int8_T>(Q_size[1]);
    if (localB->l_i - 1 >= 0) {
      std::memset(&localB->work_data[0], 0, static_cast<uint32_T>(localB->l_i) *
                  sizeof(real_T));
    }

    for (localB->b_itau = 3; localB->b_itau >= 0; localB->b_itau--) {
      localB->l_i = localB->b_itau * localB->m + localB->b_itau;
      Q_data[localB->l_i] = 1.0;
      localB->lastv_tmp = localB->m - localB->b_itau;
      localB->lastv = localB->lastv_tmp;
      localB->b_ia = (localB->l_i + localB->m) + 1;
      if (localB->b_tau_data[localB->b_itau] != 0.0) {
        boolean_T exitg2;
        localB->b_lastv = localB->l_i + localB->lastv_tmp;
        while ((localB->lastv > 0) && (Q_data[localB->b_lastv - 1] == 0.0)) {
          localB->lastv--;
          localB->b_lastv--;
        }

        localB->b_lastv = localB->lastv_tmp - 1;
        exitg2 = false;
        while ((!exitg2) && (localB->b_lastv > 0)) {
          int32_T exitg1;
          localB->c_lastc = (localB->b_lastv - 1) * localB->m + localB->b_ia;
          localB->b_coltop = localB->c_lastc;
          do {
            exitg1 = 0;
            if (localB->b_coltop <= (localB->c_lastc + localB->lastv) - 1) {
              if (Q_data[localB->b_coltop - 1] != 0.0) {
                exitg1 = 1;
              } else {
                localB->b_coltop++;
              }
            } else {
              localB->b_lastv--;
              exitg1 = 2;
            }
          } while (exitg1 == 0);

          if (exitg1 == 1) {
            exitg2 = true;
          }
        }
      } else {
        localB->lastv = 0;
        localB->b_lastv = 0;
      }

      if (localB->lastv > 0) {
        DDRTCM_xgemv(localB->lastv, localB->b_lastv, Q_data, localB->b_ia,
                     localB->m, Q_data, localB->l_i + 1, localB->work_data);
        DDRTCM_xgerc(localB->lastv, localB->b_lastv, -localB->b_tau_data
                     [localB->b_itau], localB->l_i + 1, localB->work_data,
                     Q_data, localB->b_ia, localB->m);
      }

      localB->b_ia = (localB->l_i + localB->m) - localB->b_itau;
      localB->lastv = (((((localB->b_ia - localB->l_i) - 1) / 2) << 1) +
                       localB->l_i) + 2;
      localB->b_lastv = localB->lastv - 2;
      for (localB->c_lastc = localB->l_i + 2; localB->c_lastc <= localB->b_lastv;
           localB->c_lastc += 2) {
        __m128d tmp;
        tmp = _mm_loadu_pd(&Q_data[localB->c_lastc - 1]);
        _mm_storeu_pd(&Q_data[localB->c_lastc - 1], _mm_mul_pd(tmp, _mm_set1_pd(
          -localB->b_tau_data[localB->b_itau])));
      }

      for (localB->c_lastc = localB->lastv; localB->c_lastc <= localB->b_ia;
           localB->c_lastc++) {
        Q_data[localB->c_lastc - 1] *= -localB->b_tau_data[localB->b_itau];
      }

      Q_data[localB->l_i] = 1.0 - localB->b_tau_data[localB->b_itau];
      for (localB->b_ia = 0; localB->b_ia < localB->b_itau; localB->b_ia++) {
        Q_data[(localB->l_i - localB->b_ia) - 1] = 0.0;
      }
    }
  } else {
    localB->b_A_size[0] = A_size[0];
    localB->b_A_size[1] = 4;
    localB->l_i = A_size[0] << 2;
    if (localB->l_i - 1 >= 0) {
      std::memcpy(&localB->b_A_data[0], &A_data[0], static_cast<uint32_T>
                  (localB->l_i) * sizeof(real_T));
    }

    DDRTCM_xgeqrf_d(localB->b_A_data, localB->b_A_size, localB->tau_data,
                    &localB->tau_size, localB);
    localB->b_itau = A_size[0];
    for (localB->l_i = 0; localB->l_i < localB->b_itau; localB->l_i++) {
      for (localB->b_ia = 0; localB->b_ia <= localB->l_i; localB->b_ia++) {
        R_data[localB->b_ia + R_size[0] * localB->l_i] = localB->b_A_data
          [localB->b_A_size[0] * localB->l_i + localB->b_ia];
      }

      for (localB->b_ia = localB->l_i + 2; localB->b_ia <= localB->m;
           localB->b_ia++) {
        R_data[(localB->b_ia + R_size[0] * localB->l_i) - 1] = 0.0;
      }
    }

    localB->b_itau = A_size[0] + 1;
    for (localB->l_i = localB->b_itau; localB->l_i < 5; localB->l_i++) {
      for (localB->b_ia = 0; localB->b_ia < localB->m; localB->b_ia++) {
        R_data[localB->b_ia + R_size[0] * (localB->l_i - 1)] = localB->b_A_data
          [(localB->l_i - 1) * localB->b_A_size[0] + localB->b_ia];
      }
    }

    if (A_size[0] >= 1) {
      localB->b_itau = A_size[0] - 1;
      for (localB->l_i = localB->m; localB->l_i <= localB->b_itau; localB->l_i++)
      {
        localB->b_ia = localB->l_i * localB->m;
        if (localB->m - 1 >= 0) {
          std::memset(&localB->b_A_data[localB->b_ia], 0, static_cast<uint32_T>
                      ((localB->m + localB->b_ia) - localB->b_ia) * sizeof
                      (real_T));
        }

        localB->b_A_data[localB->b_ia + localB->l_i] = 1.0;
      }

      localB->b_itau = A_size[0] - 1;
      localB->b_work[0] = 0.0;
      localB->b_work[1] = 0.0;
      localB->b_work[2] = 0.0;
      localB->b_work[3] = 0.0;
      localB->l_i = A_size[0];
      while (localB->l_i >= 1) {
        localB->b_ia = (localB->l_i - 1) * localB->m + localB->l_i;
        if (localB->l_i < localB->m) {
          localB->b_A_data[localB->b_ia - 1] = 1.0;
          localB->c_lastc = (localB->m - localB->l_i) - 1;
          localB->lastv_tmp = localB->b_ia + localB->m;
          if (localB->tau_data[localB->b_itau] != 0.0) {
            boolean_T exitg2;
            localB->b_lastv = localB->c_lastc + 2;
            localB->c_lastc += localB->b_ia;
            while ((localB->b_lastv > 0) && (localB->b_A_data[localB->c_lastc] ==
                    0.0)) {
              localB->b_lastv--;
              localB->c_lastc--;
            }

            localB->c_lastc = localB->m - localB->l_i;
            exitg2 = false;
            while ((!exitg2) && (localB->c_lastc > 0)) {
              int32_T exitg1;
              localB->b_coltop = (localB->c_lastc - 1) * localB->m +
                localB->lastv_tmp;
              localB->lastv = localB->b_coltop;
              do {
                exitg1 = 0;
                if (localB->lastv <= (localB->b_coltop + localB->b_lastv) - 1) {
                  if (localB->b_A_data[localB->lastv - 1] != 0.0) {
                    exitg1 = 1;
                  } else {
                    localB->lastv++;
                  }
                } else {
                  localB->c_lastc--;
                  exitg1 = 2;
                }
              } while (exitg1 == 0);

              if (exitg1 == 1) {
                exitg2 = true;
              }
            }
          } else {
            localB->b_lastv = 0;
            localB->c_lastc = 0;
          }

          if (localB->b_lastv > 0) {
            DDRTCM_xgemv_k(localB->b_lastv, localB->c_lastc, localB->b_A_data,
                           localB->lastv_tmp, localB->m, localB->b_A_data,
                           localB->b_ia, localB->b_work);
            DDRTCM_xgerc_m(localB->b_lastv, localB->c_lastc, -localB->
                           tau_data[localB->b_itau], localB->b_ia,
                           localB->b_work, localB->b_A_data, localB->lastv_tmp,
                           localB->m);
          }

          localB->c_lastc = localB->lastv_tmp - localB->l_i;
          localB->lastv = ((((localB->c_lastc - localB->b_ia) / 2) << 1) +
                           localB->b_ia) + 1;
          localB->b_lastv = localB->lastv - 2;
          for (localB->b_coltop = localB->b_ia + 1; localB->b_coltop <=
               localB->b_lastv; localB->b_coltop += 2) {
            __m128d tmp;
            tmp = _mm_loadu_pd(&localB->b_A_data[localB->b_coltop - 1]);
            _mm_storeu_pd(&localB->b_A_data[localB->b_coltop - 1], _mm_mul_pd
                          (tmp, _mm_set1_pd(-localB->tau_data[localB->b_itau])));
          }

          for (localB->b_coltop = localB->lastv; localB->b_coltop <=
               localB->c_lastc; localB->b_coltop++) {
            localB->b_A_data[localB->b_coltop - 1] *= -localB->tau_data
              [localB->b_itau];
          }
        }

        localB->b_A_data[localB->b_ia - 1] = 1.0 - localB->tau_data
          [localB->b_itau];
        for (localB->lastv = 0; localB->lastv <= localB->l_i - 2; localB->lastv
             ++) {
          localB->b_A_data[(localB->b_ia - localB->lastv) - 2] = 0.0;
        }

        localB->b_itau--;
        localB->l_i--;
      }
    }

    localB->b_itau = A_size[0];
    for (localB->l_i = 0; localB->l_i < localB->b_itau; localB->l_i++) {
      for (localB->b_ia = 0; localB->b_ia < localB->m; localB->b_ia++) {
        Q_data[localB->b_ia + Q_size[0] * localB->l_i] = localB->b_A_data
          [localB->b_A_size[0] * localB->l_i + localB->b_ia];
      }
    }
  }
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_eml_find_c(const boolean_T x[40], int32_T i_data[], int32_T
  i_size[2])
{
  int32_T idx;
  int32_T ii;
  boolean_T exitg1;
  idx = 0;
  i_size[0] = 1;
  ii = 0;
  exitg1 = false;
  while ((!exitg1) && (ii < 40)) {
    if (x[ii]) {
      idx++;
      i_data[idx - 1] = ii + 1;
      if (idx >= 40) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (idx < 1) {
    i_size[1] = 0;
  } else {
    i_size[1] = idx;
  }
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_eml_find_c0(const boolean_T x_data[], const int32_T x_size[2],
  int32_T i_data[], int32_T i_size[2])
{
  int32_T idx;
  int32_T ii;
  boolean_T exitg1;
  idx = 0;
  i_size[0] = 1;
  i_size[1] = x_size[1];
  ii = 0;
  exitg1 = false;
  while ((!exitg1) && (ii <= x_size[1] - 1)) {
    if (x_data[ii]) {
      idx++;
      i_data[idx - 1] = ii + 1;
      if (idx >= x_size[1]) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (x_size[1] == 1) {
    if (idx == 0) {
      i_size[0] = 1;
      i_size[1] = 0;
    }
  } else if (idx < 1) {
    i_size[1] = 0;
  } else {
    i_size[1] = idx;
  }
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_merge_h(int32_T idx_data[], real_T x_data[], int32_T offset,
  int32_T np, int32_T nq, int32_T iwork_data[], real_T xwork_data[])
{
  if (nq != 0) {
    int32_T iout;
    int32_T offset1;
    int32_T p;
    int32_T q;
    offset1 = np + nq;
    for (q = 0; q < offset1; q++) {
      iout = offset + q;
      iwork_data[q] = idx_data[iout];
      xwork_data[q] = x_data[iout];
    }

    p = 0;
    q = np;
    iout = offset - 1;
    int32_T exitg1;
    do {
      exitg1 = 0;
      iout++;
      if (xwork_data[p] <= xwork_data[q]) {
        idx_data[iout] = iwork_data[p];
        x_data[iout] = xwork_data[p];
        if (p + 1 < np) {
          p++;
        } else {
          exitg1 = 1;
        }
      } else {
        idx_data[iout] = iwork_data[q];
        x_data[iout] = xwork_data[q];
        if (q + 1 < offset1) {
          q++;
        } else {
          offset1 = iout - p;
          for (q = p + 1; q <= np; q++) {
            iout = offset1 + q;
            idx_data[iout] = iwork_data[q - 1];
            x_data[iout] = xwork_data[q - 1];
          }

          exitg1 = 1;
        }
      }
    } while (exitg1 == 0);
  }
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_sort_g(real_T x_data[], int32_T x_size[2], int32_T idx_data[],
  int32_T idx_size[2], B_MATLABFunction_DDRTCM_T *localB)
{
  localB->b_x_size_a[1] = x_size[1];
  localB->n_m = x_size[1];
  if (localB->n_m - 1 >= 0) {
    std::memcpy(&localB->b_x_data_p[0], &x_data[0], static_cast<uint32_T>
                (localB->n_m) * sizeof(real_T));
  }

  idx_size[0] = 1;
  idx_size[1] = x_size[1];
  localB->n_m = x_size[1];
  if (localB->n_m - 1 >= 0) {
    std::memset(&idx_data[0], 0, static_cast<uint32_T>(localB->n_m) * sizeof
                (int32_T));
  }

  if (x_size[1] != 0) {
    int32_T bLen;
    int32_T i4;
    int32_T nTail;
    idx_size[0] = 1;
    idx_size[1] = x_size[1];
    localB->n_m = x_size[1];
    if (localB->n_m - 1 >= 0) {
      std::memset(&idx_data[0], 0, static_cast<uint32_T>(localB->n_m) * sizeof
                  (int32_T));
    }

    localB->b_x_size_a[1] = x_size[1];
    localB->n_m = x_size[1];
    if (localB->n_m - 1 >= 0) {
      std::memcpy(&localB->b_x_data_p[0], &x_data[0], static_cast<uint32_T>
                  (localB->n_m) * sizeof(real_T));
    }

    localB->n_m = x_size[1] - 1;
    localB->x4_l[0] = 0.0;
    localB->idx4_j[0] = 0;
    localB->x4_l[1] = 0.0;
    localB->idx4_j[1] = 0;
    localB->x4_l[2] = 0.0;
    localB->idx4_j[2] = 0;
    localB->x4_l[3] = 0.0;
    localB->idx4_j[3] = 0;
    localB->quartetOffset_c = x_size[1];
    if (localB->quartetOffset_c - 1 >= 0) {
      std::memset(&localB->xwork_data_c[0], 0, static_cast<uint32_T>
                  (localB->quartetOffset_c) * sizeof(real_T));
    }

    bLen = 0;
    localB->ib_j = -1;
    nTail = x_size[1];
    for (localB->wOffset_h = 0; localB->wOffset_h < nTail; localB->wOffset_h++)
    {
      localB->d3 = localB->b_x_data_p[localB->wOffset_h];
      if (std::isnan(localB->d3)) {
        localB->quartetOffset_c = localB->n_m - bLen;
        idx_data[localB->quartetOffset_c] = localB->wOffset_h + 1;
        localB->xwork_data_c[localB->quartetOffset_c] = localB->d3;
        bLen++;
      } else {
        localB->ib_j++;
        localB->idx4_j[localB->ib_j] = static_cast<int8_T>(localB->wOffset_h + 1);
        localB->x4_l[localB->ib_j] = localB->d3;
        if (localB->ib_j + 1 == 4) {
          localB->quartetOffset_c = localB->wOffset_h - bLen;
          if (localB->x4_l[0] <= localB->x4_l[1]) {
            localB->ib_j = 1;
            localB->i2_c = 2;
          } else {
            localB->ib_j = 2;
            localB->i2_c = 1;
          }

          if (localB->x4_l[2] <= localB->x4_l[3]) {
            localB->i3_p = 3;
            i4 = 4;
          } else {
            localB->i3_p = 4;
            i4 = 3;
          }

          localB->d3 = localB->x4_l[localB->ib_j - 1];
          localB->d2 = localB->x4_l[localB->i3_p - 1];
          if (localB->d3 <= localB->d2) {
            localB->d3 = localB->x4_l[localB->i2_c - 1];
            if (localB->d3 <= localB->d2) {
              localB->perm_j[0] = static_cast<int8_T>(localB->ib_j);
              localB->perm_j[1] = static_cast<int8_T>(localB->i2_c);
              localB->perm_j[2] = static_cast<int8_T>(localB->i3_p);
              localB->perm_j[3] = static_cast<int8_T>(i4);
            } else if (localB->d3 <= localB->x4_l[i4 - 1]) {
              localB->perm_j[0] = static_cast<int8_T>(localB->ib_j);
              localB->perm_j[1] = static_cast<int8_T>(localB->i3_p);
              localB->perm_j[2] = static_cast<int8_T>(localB->i2_c);
              localB->perm_j[3] = static_cast<int8_T>(i4);
            } else {
              localB->perm_j[0] = static_cast<int8_T>(localB->ib_j);
              localB->perm_j[1] = static_cast<int8_T>(localB->i3_p);
              localB->perm_j[2] = static_cast<int8_T>(i4);
              localB->perm_j[3] = static_cast<int8_T>(localB->i2_c);
            }
          } else {
            localB->d2 = localB->x4_l[i4 - 1];
            if (localB->d3 <= localB->d2) {
              if (localB->x4_l[localB->i2_c - 1] <= localB->d2) {
                localB->perm_j[0] = static_cast<int8_T>(localB->i3_p);
                localB->perm_j[1] = static_cast<int8_T>(localB->ib_j);
                localB->perm_j[2] = static_cast<int8_T>(localB->i2_c);
                localB->perm_j[3] = static_cast<int8_T>(i4);
              } else {
                localB->perm_j[0] = static_cast<int8_T>(localB->i3_p);
                localB->perm_j[1] = static_cast<int8_T>(localB->ib_j);
                localB->perm_j[2] = static_cast<int8_T>(i4);
                localB->perm_j[3] = static_cast<int8_T>(localB->i2_c);
              }
            } else {
              localB->perm_j[0] = static_cast<int8_T>(localB->i3_p);
              localB->perm_j[1] = static_cast<int8_T>(i4);
              localB->perm_j[2] = static_cast<int8_T>(localB->ib_j);
              localB->perm_j[3] = static_cast<int8_T>(localB->i2_c);
            }
          }

          localB->i3_p = localB->quartetOffset_c - 3;
          idx_data[localB->i3_p] = localB->idx4_j[localB->perm_j[0] - 1];
          localB->ib_j = localB->quartetOffset_c - 2;
          idx_data[localB->ib_j] = localB->idx4_j[localB->perm_j[1] - 1];
          localB->i2_c = localB->quartetOffset_c - 1;
          idx_data[localB->i2_c] = localB->idx4_j[localB->perm_j[2] - 1];
          idx_data[localB->quartetOffset_c] = localB->idx4_j[localB->perm_j[3] -
            1];
          localB->b_x_data_p[localB->i3_p] = localB->x4_l[localB->perm_j[0] - 1];
          localB->b_x_data_p[localB->ib_j] = localB->x4_l[localB->perm_j[1] - 1];
          localB->b_x_data_p[localB->i2_c] = localB->x4_l[localB->perm_j[2] - 1];
          localB->b_x_data_p[localB->quartetOffset_c] = localB->x4_l
            [localB->perm_j[3] - 1];
          localB->ib_j = -1;
        }
      }
    }

    i4 = x_size[1] - bLen;
    if (localB->ib_j + 1 > 0) {
      localB->perm_j[1] = 0;
      localB->perm_j[2] = 0;
      localB->perm_j[3] = 0;
      switch (localB->ib_j + 1) {
       case 1:
        localB->perm_j[0] = 1;
        break;

       case 2:
        if (localB->x4_l[0] <= localB->x4_l[1]) {
          localB->perm_j[0] = 1;
          localB->perm_j[1] = 2;
        } else {
          localB->perm_j[0] = 2;
          localB->perm_j[1] = 1;
        }
        break;

       default:
        if (localB->x4_l[0] <= localB->x4_l[1]) {
          if (localB->x4_l[1] <= localB->x4_l[2]) {
            localB->perm_j[0] = 1;
            localB->perm_j[1] = 2;
            localB->perm_j[2] = 3;
          } else if (localB->x4_l[0] <= localB->x4_l[2]) {
            localB->perm_j[0] = 1;
            localB->perm_j[1] = 3;
            localB->perm_j[2] = 2;
          } else {
            localB->perm_j[0] = 3;
            localB->perm_j[1] = 1;
            localB->perm_j[2] = 2;
          }
        } else if (localB->x4_l[0] <= localB->x4_l[2]) {
          localB->perm_j[0] = 2;
          localB->perm_j[1] = 1;
          localB->perm_j[2] = 3;
        } else if (localB->x4_l[1] <= localB->x4_l[2]) {
          localB->perm_j[0] = 2;
          localB->perm_j[1] = 3;
          localB->perm_j[2] = 1;
        } else {
          localB->perm_j[0] = 3;
          localB->perm_j[1] = 2;
          localB->perm_j[2] = 1;
        }
        break;
      }

      localB->i2_c = static_cast<uint8_T>(localB->ib_j + 1);
      for (nTail = 0; nTail < localB->i2_c; nTail++) {
        int8_T perm;
        perm = localB->perm_j[nTail];
        localB->i3_p = ((i4 - localB->ib_j) + nTail) - 1;
        idx_data[localB->i3_p] = localB->idx4_j[perm - 1];
        localB->b_x_data_p[localB->i3_p] = localB->x4_l[perm - 1];
      }
    }

    localB->ib_j = bLen >> 1;
    for (nTail = 0; nTail < localB->ib_j; nTail++) {
      localB->i2_c = i4 + nTail;
      localB->i3_p = idx_data[localB->i2_c];
      localB->quartetOffset_c = localB->n_m - nTail;
      idx_data[localB->i2_c] = idx_data[localB->quartetOffset_c];
      idx_data[localB->quartetOffset_c] = localB->i3_p;
      localB->b_x_data_p[localB->i2_c] = localB->xwork_data_c
        [localB->quartetOffset_c];
      localB->b_x_data_p[localB->quartetOffset_c] = localB->xwork_data_c
        [localB->i2_c];
    }

    if ((static_cast<uint32_T>(bLen) & 1U) != 0U) {
      localB->n_m = i4 + localB->ib_j;
      localB->b_x_data_p[localB->n_m] = localB->xwork_data_c[localB->n_m];
    }

    if (i4 > 1) {
      localB->quartetOffset_c = x_size[1];
      if (localB->quartetOffset_c - 1 >= 0) {
        std::memset(&localB->iwork_data_f[0], 0, static_cast<uint32_T>
                    (localB->quartetOffset_c) * sizeof(int32_T));
      }

      localB->quartetOffset_c = i4 >> 2;
      bLen = 4;
      while (localB->quartetOffset_c > 1) {
        if ((static_cast<uint32_T>(localB->quartetOffset_c) & 1U) != 0U) {
          localB->quartetOffset_c--;
          localB->wOffset_h = bLen * localB->quartetOffset_c;
          nTail = i4 - localB->wOffset_h;
          if (nTail > bLen) {
            DDRTCM_merge_h(idx_data, localB->b_x_data_p, localB->wOffset_h, bLen,
                           nTail - bLen, localB->iwork_data_f,
                           localB->xwork_data_c);
          }
        }

        nTail = bLen << 1;
        localB->quartetOffset_c >>= 1;
        for (localB->wOffset_h = 0; localB->wOffset_h < localB->quartetOffset_c;
             localB->wOffset_h++) {
          DDRTCM_merge_h(idx_data, localB->b_x_data_p, localB->wOffset_h * nTail,
                         bLen, bLen, localB->iwork_data_f, localB->xwork_data_c);
        }

        bLen = nTail;
      }

      if (i4 > bLen) {
        DDRTCM_merge_h(idx_data, localB->b_x_data_p, 0, bLen, i4 - bLen,
                       localB->iwork_data_f, localB->xwork_data_c);
      }
    }
  }

  x_size[0] = 1;
  x_size[1] = localB->b_x_size_a[1];
  localB->n_m = localB->b_x_size_a[1];
  if (localB->n_m - 1 >= 0) {
    std::memcpy(&x_data[0], &localB->b_x_data_p[0], static_cast<uint32_T>
                (localB->n_m) * sizeof(real_T));
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
real_T DDRTCM::DDRTCM_sum(const real_T x_data[], const int32_T x_size[2])
{
  real_T y;
  int32_T vlen;
  vlen = x_size[1];
  if (x_size[1] == 0) {
    y = 0.0;
  } else {
    y = x_data[0];
    for (int32_T k{2}; k <= vlen; k++) {
      y += x_data[k - 1];
    }
  }

  return y;
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_eml_find_c0wi(const real_T x_data[], const int32_T x_size[2],
  int32_T i_data[], int32_T i_size[2])
{
  int32_T idx;
  int32_T ii;
  int32_T k;
  boolean_T exitg1;
  k = (x_size[1] >= 1);
  idx = 0;
  i_size[0] = 1;
  i_size[1] = k;
  ii = 0;
  exitg1 = false;
  while ((!exitg1) && (ii <= x_size[1] - 1)) {
    if (x_data[ii] != 0.0) {
      idx = 1;
      i_data[0] = ii + 1;
      exitg1 = true;
    } else {
      ii++;
    }
  }

  if (k == 1) {
    if (idx == 0) {
      i_size[0] = 1;
      i_size[1] = 0;
    }
  } else {
    i_size[1] = (idx >= 1);
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
real_T DDRTCM::DDRTCM_norm(const real_T x_data[], const int32_T *x_size)
{
  real_T y;
  if (*x_size == 0) {
    y = 0.0;
  } else {
    y = 0.0;
    if (*x_size == 1) {
      y = std::abs(x_data[0]);
    } else {
      real_T scale;
      int32_T b;
      scale = 3.3121686421112381E-170;
      b = *x_size;
      for (int32_T k{0}; k < b; k++) {
        real_T absxk;
        absxk = std::abs(x_data[k]);
        if (absxk > scale) {
          real_T t;
          t = scale / absxk;
          y = y * t * t + 1.0;
          scale = absxk;
        } else {
          real_T t;
          t = absxk / scale;
          y += t * t;
        }
      }

      y = scale * std::sqrt(y);
    }
  }

  return y;
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_eml_find_c0w(const boolean_T x_data[], const int32_T *x_size,
  int32_T i_data[], int32_T *i_size)
{
  int32_T idx;
  int32_T ii;
  boolean_T exitg1;
  idx = 0;
  *i_size = *x_size;
  ii = 0;
  exitg1 = false;
  while ((!exitg1) && (ii <= *x_size - 1)) {
    if (x_data[ii]) {
      idx++;
      i_data[idx - 1] = ii + 1;
      if (idx >= *x_size) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (*x_size == 1) {
    if (idx == 0) {
      *i_size = 0;
    }
  } else if (idx < 1) {
    *i_size = 0;
  } else {
    *i_size = idx;
  }
}

// Function for MATLAB Function: '<S123>/Weighted RAIM Parity'
void DDRTCM::DDRTCM_sort_j(real_T x_data[], int32_T x_size[2], int32_T idx_data[],
  int32_T idx_size[2], B_MATLABFunction_DDRTCM_T *localB)
{
  localB->b_x_size[1] = x_size[1];
  localB->n_c = x_size[1];
  if (localB->n_c - 1 >= 0) {
    std::memcpy(&localB->b_x_data[0], &x_data[0], static_cast<uint32_T>
                (localB->n_c) * sizeof(real_T));
  }

  idx_size[0] = 1;
  idx_size[1] = x_size[1];
  localB->n_c = x_size[1];
  if (localB->n_c - 1 >= 0) {
    std::memset(&idx_data[0], 0, static_cast<uint32_T>(localB->n_c) * sizeof
                (int32_T));
  }

  if (x_size[1] != 0) {
    int32_T bLen;
    int32_T i4;
    int32_T nTail;
    idx_size[0] = 1;
    idx_size[1] = x_size[1];
    localB->n_c = x_size[1];
    if (localB->n_c - 1 >= 0) {
      std::memset(&idx_data[0], 0, static_cast<uint32_T>(localB->n_c) * sizeof
                  (int32_T));
    }

    localB->b_x_size[1] = x_size[1];
    localB->n_c = x_size[1];
    if (localB->n_c - 1 >= 0) {
      std::memcpy(&localB->b_x_data[0], &x_data[0], static_cast<uint32_T>
                  (localB->n_c) * sizeof(real_T));
    }

    localB->n_c = x_size[1] - 1;
    localB->x4[0] = 0.0;
    localB->idx4[0] = 0;
    localB->x4[1] = 0.0;
    localB->idx4[1] = 0;
    localB->x4[2] = 0.0;
    localB->idx4[2] = 0;
    localB->x4[3] = 0.0;
    localB->idx4[3] = 0;
    localB->quartetOffset = x_size[1];
    if (localB->quartetOffset - 1 >= 0) {
      std::memset(&localB->xwork_data[0], 0, static_cast<uint32_T>
                  (localB->quartetOffset) * sizeof(real_T));
    }

    bLen = 0;
    localB->ib = -1;
    nTail = x_size[1];
    for (localB->wOffset = 0; localB->wOffset < nTail; localB->wOffset++) {
      localB->d1 = localB->b_x_data[localB->wOffset];
      if (std::isnan(localB->d1)) {
        localB->quartetOffset = localB->n_c - bLen;
        idx_data[localB->quartetOffset] = localB->wOffset + 1;
        localB->xwork_data[localB->quartetOffset] = localB->d1;
        bLen++;
      } else {
        localB->ib++;
        localB->idx4[localB->ib] = static_cast<int8_T>(localB->wOffset + 1);
        localB->x4[localB->ib] = localB->d1;
        if (localB->ib + 1 == 4) {
          localB->quartetOffset = localB->wOffset - bLen;
          if (localB->x4[0] <= localB->x4[1]) {
            localB->ib = 1;
            localB->i2_m = 2;
          } else {
            localB->ib = 2;
            localB->i2_m = 1;
          }

          if (localB->x4[2] <= localB->x4[3]) {
            localB->i3 = 3;
            i4 = 4;
          } else {
            localB->i3 = 4;
            i4 = 3;
          }

          localB->d1 = localB->x4[localB->ib - 1];
          localB->d = localB->x4[localB->i3 - 1];
          if (localB->d1 <= localB->d) {
            localB->d1 = localB->x4[localB->i2_m - 1];
            if (localB->d1 <= localB->d) {
              localB->perm[0] = static_cast<int8_T>(localB->ib);
              localB->perm[1] = static_cast<int8_T>(localB->i2_m);
              localB->perm[2] = static_cast<int8_T>(localB->i3);
              localB->perm[3] = static_cast<int8_T>(i4);
            } else if (localB->d1 <= localB->x4[i4 - 1]) {
              localB->perm[0] = static_cast<int8_T>(localB->ib);
              localB->perm[1] = static_cast<int8_T>(localB->i3);
              localB->perm[2] = static_cast<int8_T>(localB->i2_m);
              localB->perm[3] = static_cast<int8_T>(i4);
            } else {
              localB->perm[0] = static_cast<int8_T>(localB->ib);
              localB->perm[1] = static_cast<int8_T>(localB->i3);
              localB->perm[2] = static_cast<int8_T>(i4);
              localB->perm[3] = static_cast<int8_T>(localB->i2_m);
            }
          } else {
            localB->d = localB->x4[i4 - 1];
            if (localB->d1 <= localB->d) {
              if (localB->x4[localB->i2_m - 1] <= localB->d) {
                localB->perm[0] = static_cast<int8_T>(localB->i3);
                localB->perm[1] = static_cast<int8_T>(localB->ib);
                localB->perm[2] = static_cast<int8_T>(localB->i2_m);
                localB->perm[3] = static_cast<int8_T>(i4);
              } else {
                localB->perm[0] = static_cast<int8_T>(localB->i3);
                localB->perm[1] = static_cast<int8_T>(localB->ib);
                localB->perm[2] = static_cast<int8_T>(i4);
                localB->perm[3] = static_cast<int8_T>(localB->i2_m);
              }
            } else {
              localB->perm[0] = static_cast<int8_T>(localB->i3);
              localB->perm[1] = static_cast<int8_T>(i4);
              localB->perm[2] = static_cast<int8_T>(localB->ib);
              localB->perm[3] = static_cast<int8_T>(localB->i2_m);
            }
          }

          localB->i3 = localB->quartetOffset - 3;
          idx_data[localB->i3] = localB->idx4[localB->perm[0] - 1];
          localB->ib = localB->quartetOffset - 2;
          idx_data[localB->ib] = localB->idx4[localB->perm[1] - 1];
          localB->i2_m = localB->quartetOffset - 1;
          idx_data[localB->i2_m] = localB->idx4[localB->perm[2] - 1];
          idx_data[localB->quartetOffset] = localB->idx4[localB->perm[3] - 1];
          localB->b_x_data[localB->i3] = localB->x4[localB->perm[0] - 1];
          localB->b_x_data[localB->ib] = localB->x4[localB->perm[1] - 1];
          localB->b_x_data[localB->i2_m] = localB->x4[localB->perm[2] - 1];
          localB->b_x_data[localB->quartetOffset] = localB->x4[localB->perm[3] -
            1];
          localB->ib = -1;
        }
      }
    }

    i4 = x_size[1] - bLen;
    if (localB->ib + 1 > 0) {
      localB->perm[1] = 0;
      localB->perm[2] = 0;
      localB->perm[3] = 0;
      switch (localB->ib + 1) {
       case 1:
        localB->perm[0] = 1;
        break;

       case 2:
        if (localB->x4[0] <= localB->x4[1]) {
          localB->perm[0] = 1;
          localB->perm[1] = 2;
        } else {
          localB->perm[0] = 2;
          localB->perm[1] = 1;
        }
        break;

       default:
        if (localB->x4[0] <= localB->x4[1]) {
          if (localB->x4[1] <= localB->x4[2]) {
            localB->perm[0] = 1;
            localB->perm[1] = 2;
            localB->perm[2] = 3;
          } else if (localB->x4[0] <= localB->x4[2]) {
            localB->perm[0] = 1;
            localB->perm[1] = 3;
            localB->perm[2] = 2;
          } else {
            localB->perm[0] = 3;
            localB->perm[1] = 1;
            localB->perm[2] = 2;
          }
        } else if (localB->x4[0] <= localB->x4[2]) {
          localB->perm[0] = 2;
          localB->perm[1] = 1;
          localB->perm[2] = 3;
        } else if (localB->x4[1] <= localB->x4[2]) {
          localB->perm[0] = 2;
          localB->perm[1] = 3;
          localB->perm[2] = 1;
        } else {
          localB->perm[0] = 3;
          localB->perm[1] = 2;
          localB->perm[2] = 1;
        }
        break;
      }

      localB->i2_m = static_cast<uint8_T>(localB->ib + 1);
      for (nTail = 0; nTail < localB->i2_m; nTail++) {
        int8_T perm;
        perm = localB->perm[nTail];
        localB->i3 = ((i4 - localB->ib) + nTail) - 1;
        idx_data[localB->i3] = localB->idx4[perm - 1];
        localB->b_x_data[localB->i3] = localB->x4[perm - 1];
      }
    }

    localB->ib = bLen >> 1;
    for (nTail = 0; nTail < localB->ib; nTail++) {
      localB->i2_m = i4 + nTail;
      localB->i3 = idx_data[localB->i2_m];
      localB->quartetOffset = localB->n_c - nTail;
      idx_data[localB->i2_m] = idx_data[localB->quartetOffset];
      idx_data[localB->quartetOffset] = localB->i3;
      localB->b_x_data[localB->i2_m] = localB->xwork_data[localB->quartetOffset];
      localB->b_x_data[localB->quartetOffset] = localB->xwork_data[localB->i2_m];
    }

    if ((static_cast<uint32_T>(bLen) & 1U) != 0U) {
      localB->n_c = i4 + localB->ib;
      localB->b_x_data[localB->n_c] = localB->xwork_data[localB->n_c];
    }

    if (i4 > 1) {
      localB->quartetOffset = x_size[1];
      if (localB->quartetOffset - 1 >= 0) {
        std::memset(&localB->iwork_data[0], 0, static_cast<uint32_T>
                    (localB->quartetOffset) * sizeof(int32_T));
      }

      localB->quartetOffset = i4 >> 2;
      bLen = 4;
      while (localB->quartetOffset > 1) {
        if ((static_cast<uint32_T>(localB->quartetOffset) & 1U) != 0U) {
          localB->quartetOffset--;
          localB->wOffset = bLen * localB->quartetOffset;
          nTail = i4 - localB->wOffset;
          if (nTail > bLen) {
            DDRTCM_merge_h(idx_data, localB->b_x_data, localB->wOffset, bLen,
                           nTail - bLen, localB->iwork_data, localB->xwork_data);
          }
        }

        nTail = bLen << 1;
        localB->quartetOffset >>= 1;
        for (localB->wOffset = 0; localB->wOffset < localB->quartetOffset;
             localB->wOffset++) {
          DDRTCM_merge_h(idx_data, localB->b_x_data, localB->wOffset * nTail,
                         bLen, bLen, localB->iwork_data, localB->xwork_data);
        }

        bLen = nTail;
      }

      if (i4 > bLen) {
        DDRTCM_merge_h(idx_data, localB->b_x_data, 0, bLen, i4 - bLen,
                       localB->iwork_data, localB->xwork_data);
      }
    }
  }

  x_size[0] = 1;
  x_size[1] = localB->b_x_size[1];
  localB->n_c = localB->b_x_size[1];
  if (localB->n_c - 1 >= 0) {
    std::memcpy(&x_data[0], &localB->b_x_data[0], static_cast<uint32_T>
                (localB->n_c) * sizeof(real_T));
  }
}

// Function for MATLAB Function: '<S123>/Fault Exclusion'
void DDRTCM::DDRTCM_nullAssignment(real_T x_data[], int32_T x_size[2], const
  int32_T idx_data[], const int32_T idx_size[2])
{
  int32_T b_size_idx_1;
  int32_T c;
  int32_T k0;
  int32_T nxout;
  boolean_T b_data[40];
  b_size_idx_1 = x_size[1];
  nxout = x_size[1];
  if (nxout - 1 >= 0) {
    std::memset(&b_data[0], 0, static_cast<uint32_T>(nxout) * sizeof(boolean_T));
  }

  nxout = idx_size[1];
  for (int32_T b_k{0}; b_k < nxout; b_k++) {
    b_data[idx_data[b_k] - 1] = true;
  }

  nxout = 0;
  for (int32_T b_k{0}; b_k < b_size_idx_1; b_k++) {
    nxout += b_data[b_k];
  }

  nxout = x_size[1] - nxout;
  k0 = -1;
  c = x_size[1];
  for (int32_T b_k{0}; b_k < c; b_k++) {
    if ((b_k + 1 > b_size_idx_1) || (!b_data[b_k])) {
      k0++;
      x_data[k0] = x_data[b_k];
    }
  }

  if (nxout < 1) {
    x_size[1] = 0;
  } else {
    x_size[1] = nxout;
  }
}

void DDRTCM::DDRTCM_binary_expand_op_mz(real_T in1_data[], const int32_T
  in1_size[2], int32_T in2, const real_T in3_data[], const int32_T *in3_size,
  real_T in4, const real_T in5_data[], const int32_T in5_size[2])
{
  int32_T loop_ub;
  int32_T stride_0_0;
  int32_T stride_1_0;

  // Outputs for Function Call SubSystem: '<S122>/GNSS Fault Detection Identification Exclusion' 
  // MATLAB Function: '<S123>/Weighted RAIM Parity'
  stride_0_0 = (*in3_size != 1);
  stride_1_0 = (in5_size[0] != 1);
  loop_ub = in5_size[0] == 1 ? *in3_size : in5_size[0];
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[i + in1_size[0] * in2] = in3_data[i * stride_0_0] - in5_data[i *
      stride_1_0 + in5_size[0] * in2] * in4;
  }

  // End of MATLAB Function: '<S123>/Weighted RAIM Parity'
  // End of Outputs for SubSystem: '<S122>/GNSS Fault Detection Identification Exclusion' 
}

//
// System initialize for atomic system:
//    '<S122>/MATLAB Function'
//    '<S249>/MATLAB Function'
//
void DDRTCM::DDRTCM_MATLABFunction_Init(real_T *rty_1, real_T *rty_2, real_T
  *rty_3, real_T rty_4[80], real_T rty_5[80], real_T rty_6[80],
  B_MATLABFunction_DDRTCM_T *localB, DW_MATLABFunction_DDRTCM_T *localDW,
  P_MATLABFunction_DDRTCM_T *localP)
{
  // SystemInitialize for Function Call SubSystem: '<S122>/GNSS Fault Detection Identification Exclusion' 
  // SystemInitialize for Outport: '<S123>/GNSS_Measurement_out'
  localB->GNSS_measurement_out = localP->GNSS_Measurement_out_Y0;
  localDW->SFunction_DIMS2.satellite_position[0] = 1;
  localDW->SFunction_DIMS2.satellite_velocity[0] = 1;
  localDW->SFunction_DIMS2.satellite_position[1] = 1;
  localDW->SFunction_DIMS2.satellite_velocity[1] = 1;
  localDW->SFunction_DIMS2.PRN = 1;
  localDW->SFunction_DIMS2.pseudorange = 1;
  localDW->SFunction_DIMS2.pseudorange_raw = 1;
  localDW->SFunction_DIMS2.pseudorange_satclk_corrected = 1;
  localDW->SFunction_DIMS2.deltarange = 1;
  localDW->SFunction_DIMS2.deltarange_raw = 1;
  localDW->SFunction_DIMS2.deltarange_satclk_corrected = 1;
  localDW->SFunction_DIMS2.variance_pseudorange = 1;
  localDW->SFunction_DIMS2.variance_pseudorange_measured = 1;
  localDW->SFunction_DIMS2.variance_deltarange = 1;
  localDW->SFunction_DIMS2.carrierphase = 1;
  localDW->SFunction_DIMS2.carrierphase_raw = 1;
  localDW->SFunction_DIMS2.carrierphase_satclk_corrected = 1;
  localDW->SFunction_DIMS2.variance_carrierphase_measured = 1;
  localDW->SFunction_DIMS2.locktime = 1;
  localDW->SFunction_DIMS2.CN0 = 1;

  // SystemInitialize for Outport: '<S123>/alert'
  *rty_1 = localP->alert_Y0;

  // SystemInitialize for Outport: '<S123>/HPL'
  *rty_2 = localP->HPL_Y0;

  // SystemInitialize for Outport: '<S123>/test_statistic'
  *rty_3 = localP->test_statistic_Y0;
  for (int32_T i{0}; i < 80; i++) {
    // SystemInitialize for MATLAB Function: '<S123>/Fault Exclusion'
    localDW->BUFFER[i] = (rtNaN);

    // SystemInitialize for Outport: '<S123>/PRNs_identified'
    rty_4[i] = localP->PRNs_identified_Y0;

    // SystemInitialize for Outport: '<S123>/PRNs_to_exclude'
    rty_5[i] = localP->PRNs_to_exclude_Y0;

    // SystemInitialize for Outport: '<S123>/PRNs_excluded'
    rty_6[i] = localP->PRNs_excluded_Y0;
  }

  // End of SystemInitialize for SubSystem: '<S122>/GNSS Fault Detection Identification Exclusion' 
}

//
// Output and update for atomic system:
//    '<S122>/MATLAB Function'
//    '<S249>/MATLAB Function'
//
void DDRTCM::DDRTCM_MATLABFunction(const parameters_integrity_t
  *rtu_IntegrityParameters, const GNSS_Measurement *rtu_1, const
  GNSS_Measurement_size *rtu_1_DIMS1, boolean_T rtu_3, boolean_T rtu_4,
  boolean_T rtu_6, boolean_T rtu_7, boolean_T rtu_8, boolean_T rtu_9, real_T
  rtu_28, real_T rtu_31, real_T rtu_33, real_T rtu_35, real_T rtu_36, real_T
  rtu_37, boolean_T rtu_38, const real_T rtu_39[3], real_T rtu_40, boolean_T
  *rty_useOriginalGNSSmeasurement, real_T *rty_1, real_T *rty_2, real_T *rty_3,
  real_T rty_4[80], real_T rty_5[80], real_T rty_6[80],
  B_MATLABFunction_DDRTCM_T *localB, DW_MATLABFunction_DDRTCM_T *localDW,
  P_DDRTCM_T *DDRTCM_P)
{
  static const real_T h[36]{ 5.0, 0.4529, 10.0, 0.3553, 15.0, 0.3063, 20.0,
    0.2638, 25.0, 0.2593, 30.0, 0.2555, 35.0, 0.2504, 40.0, 0.2438, 45.0, 0.2396,
    50.0, 0.2359, 55.0, 0.2339, 60.0, 0.2302, 65.0, 0.2295, 70.0, 0.2278, 75.0,
    0.2297, 80.0, 0.231, 85.0, 0.2274, 90.0, 0.2277 };

  *rty_useOriginalGNSSmeasurement = false;
  if (rtu_IntegrityParameters->enable_integrity) {
    // Outputs for Function Call SubSystem: '<S122>/GNSS Fault Detection Identification Exclusion' 
    // SignalConversion generated from: '<S123>/Bus Assignment'
    localDW->TmpHiddenBufferAtBusAssignmentI = *rtu_1_DIMS1;

    // MATLAB Function: '<S123>/Weighted RAIM Parity' incorporates:
    //   SignalConversion generated from: '<S123>/Bus Assignment'

    std::memcpy(&localB->GNSS_Measurement_out.satellite_position[0],
                &rtu_1->satellite_position[0], 120U * sizeof(real_T));
    std::memcpy(&localB->GNSS_Measurement_out.PRN[0], &rtu_1->PRN[0], 40U *
                sizeof(uint16_T));

    // SignalConversion generated from: '<S123>/Bus Assignment'
    std::memcpy(&localB->GNSS_Measurement_out.pseudorange[0],
                &rtu_1->pseudorange[0], 40U * sizeof(real_T));

    // MATLAB Function: '<S123>/calculate Variance' incorporates:
    //   BusCreator generated from: '<S123>/calculate Variance'

    for (localB->i = 0; localB->i < 40; localB->i++) {
      localB->variance_pseudorange[localB->i] = (rtNaN);
    }

    switch (static_cast<int32_T>(rtu_37)) {
     case 1:
      if (rtu_1_DIMS1->pseudorange < 1) {
        localB->c = 0;
      } else {
        localB->c = rtu_1_DIMS1->pseudorange;
      }

      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = 4.0;
      }
      break;

     case 2:
      localB->b = rtu_1_DIMS1->pseudorange;
      if (rtu_1_DIMS1->pseudorange - 1 >= 0) {
        localB->rtu_1_DIMS1_idx_0 = rtu_1_DIMS1->satellite_position[0];
        localB->c = rtu_1_DIMS1->satellite_position[1];
      }

      for (localB->i = 0; localB->i < localB->b; localB->i++) {
        if ((rtu_1->PRN[localB->i] >= 1) && (rtu_1->PRN[localB->i] <= 37)) {
          localB->threshold = 0.85;
        } else if ((rtu_1->PRN[localB->i] >= 71) && (rtu_1->PRN[localB->i] <=
                    102)) {
          localB->threshold = 0.85;
        } else if (rtu_1->PRN[localB->i] >= 120) {
          if (rtu_1->PRN[localB->i] <= 140) {
            localB->threshold = 0.85;
          } else {
            localB->threshold = 1.0E+20;
          }
        } else {
          localB->threshold = 1.0E+20;
        }

        localB->rtu_1_size[0] = 1;
        localB->rtu_1_size[1] = localB->c;
        for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
          localB->rtu_1_data[localB->idx] = rtu_1->satellite_position
            [localB->rtu_1_DIMS1_idx_0 * localB->idx + localB->i];
        }

        calculate_Satellite_Elevation_c(rtu_39, localB->rtu_1_data,
          localB->rtu_1_size, &localB->numIdentifiedFaults, &localB->sigma_mp,
          localB);
        if ((rtu_1->PRN[localB->i] >= 1) && (rtu_1->PRN[localB->i] <= 37)) {
          if (rtu_3 && rtu_4) {
            localB->sigma_mp = 0.0;
          } else {
            localB->sigma_mp = (rt_powd_snf(0.53 - localB->numIdentifiedFaults /
              3.1415926535897931, 3.0) * 16.0 + 1.0) * 0.4;
          }
        } else if (rtu_1->PRN[localB->i] >= 71) {
          if (rtu_1->PRN[localB->i] <= 102) {
            if (rtu_6 && (rtu_7 || rtu_8 || rtu_9)) {
              localB->sigma_mp = 0.0;
            } else {
              localB->sigma_mp = 2.0;
            }
          } else {
            localB->sigma_mp = 1.0E+20;
          }
        } else {
          localB->sigma_mp = 1.0E+20;
        }

        if (localB->numIdentifiedFaults >= 0.069813170079773182) {
          localB->trop_factor = std::sin(localB->numIdentifiedFaults);
          localB->trop_factor = 1.001 / std::sqrt(localB->trop_factor *
            localB->trop_factor + 0.002001);
        } else if ((localB->numIdentifiedFaults < 0.069813170079773182) &&
                   (localB->numIdentifiedFaults >= 0.034906585039886591)) {
          localB->trop_factor = std::sin(localB->numIdentifiedFaults);
          localB->sigma_noise = 4.0 - localB->numIdentifiedFaults * 180.0 /
            3.1415926535897931;
          localB->trop_factor = 1.001 / std::sqrt(localB->trop_factor *
            localB->trop_factor + 0.002001) * (localB->sigma_noise *
            localB->sigma_noise * 0.015 + 1.0);
        } else {
          localB->trop_factor = std::sin(localB->numIdentifiedFaults);
          localB->sigma_noise = 4.0 - localB->numIdentifiedFaults * 180.0 /
            3.1415926535897931;
          localB->trop_factor = 1.001 / std::sqrt(localB->trop_factor *
            localB->trop_factor + 0.002001) * (localB->sigma_noise *
            localB->sigma_noise * 0.015 + 1.0);
        }

        localB->trop_factor *= 0.12;
        if ((rtu_1->PRN[localB->i] >= 1) && (rtu_1->PRN[localB->i] <= 37)) {
          if (rtu_3 && rtu_4) {
            localB->sigma_noise = std::sqrt(5.11 *
              DDRTCM_P->table_sigma_noise_GNSSReceiver[0] + 1.59 *
              DDRTCM_P->table_sigma_noise_GNSSReceiver[1]);
          } else {
            localB->sigma_noise = DDRTCM_P->table_sigma_noise_GNSSReceiver[0];
          }
        } else if (rtu_1->PRN[localB->i] >= 71) {
          if (rtu_1->PRN[localB->i] <= 102) {
            if (rtu_6 && (rtu_7 || rtu_8 || rtu_9)) {
              localB->sigma_noise = std::sqrt(5.11 *
                DDRTCM_P->table_sigma_noise_GNSSReceiver[2] + 1.59 *
                DDRTCM_P->table_sigma_noise_GNSSReceiver[3]);
            } else {
              localB->sigma_noise = DDRTCM_P->table_sigma_noise_GNSSReceiver[2];
            }
          } else {
            localB->sigma_noise = 1.0E+20;
          }
        } else {
          localB->sigma_noise = 1.0E+20;
        }

        localB->numIdentifiedFaults = std::exp(-localB->numIdentifiedFaults *
          180.0 / 31.415926535897931) * 0.53 + 0.3;
        localB->variance_pseudorange[localB->i] = (((localB->threshold *
          localB->threshold + localB->sigma_mp * localB->sigma_mp) +
          localB->trop_factor * localB->trop_factor) + localB->sigma_noise *
          localB->sigma_noise) + localB->numIdentifiedFaults *
          localB->numIdentifiedFaults;
      }
      break;

     case 3:
      {
        localB->b = rtu_1_DIMS1->pseudorange;
        if (rtu_1_DIMS1->pseudorange - 1 >= 0) {
          localB->rtu_1_DIMS1_idx_0 = rtu_1_DIMS1->satellite_position[0];
          localB->c = rtu_1_DIMS1->satellite_position[1];
        }

        for (localB->i = 0; localB->i < localB->b; localB->i++) {
          if ((rtu_1->PRN[localB->i] >= 1) && (rtu_1->PRN[localB->i] <= 37)) {
            localB->threshold = 0.75;
          } else if ((rtu_1->PRN[localB->i] >= 71) && (rtu_1->PRN[localB->i] <=
                      102)) {
            localB->threshold = 0.96;
          } else if (rtu_1->PRN[localB->i] >= 120) {
            if (rtu_1->PRN[localB->i] <= 140) {
              localB->threshold = 0.3;
            } else {
              localB->threshold = 1.0;
            }
          } else {
            localB->threshold = 1.0;
          }

          localB->rtu_1_size[0] = 1;
          localB->rtu_1_size[1] = localB->c;
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->rtu_1_data[localB->idx] = rtu_1->satellite_position
              [localB->rtu_1_DIMS1_idx_0 * localB->idx + localB->i];
          }

          calculate_Satellite_Elevation_c(rtu_39, localB->rtu_1_data,
            localB->rtu_1_size, &localB->sigma_mp, &localB->numIdentifiedFaults,
            localB);
          if ((rtu_1->PRN[localB->i] >= 1) && (rtu_1->PRN[localB->i] <= 37)) {
            if (rtu_3 && rtu_4) {
              localB->numIdentifiedFaults = 0.0;
            } else {
              localB->numIdentifiedFaults = (rt_powd_snf(0.53 - localB->sigma_mp
                / 3.1415926535897931, 3.0) * 16.0 + 1.0) * 0.4;
            }
          } else if (rtu_1->PRN[localB->i] >= 71) {
            if (rtu_1->PRN[localB->i] <= 102) {
              if (rtu_6 && (rtu_7 || rtu_8 || rtu_9)) {
                localB->numIdentifiedFaults = 0.0;
              } else {
                localB->numIdentifiedFaults = 2.0;
              }
            } else {
              localB->numIdentifiedFaults = 1.0E+20;
            }
          } else {
            localB->numIdentifiedFaults = 1.0E+20;
          }

          if (localB->sigma_mp >= 0.069813170079773182) {
            localB->trop_factor = std::sin(localB->sigma_mp);
            localB->trop_factor = 1.001 / std::sqrt(localB->trop_factor *
              localB->trop_factor + 0.002001);
          } else if ((localB->sigma_mp < 0.069813170079773182) &&
                     (localB->sigma_mp >= 0.034906585039886591)) {
            localB->trop_factor = std::sin(localB->sigma_mp);
            localB->trop_factor = ((4.0 - (localB->sigma_mp + 57.295779513082323))
              * (4.0 - (localB->sigma_mp + 57.295779513082323)) * 0.015 + 1.0) *
              (1.001 / std::sqrt(localB->trop_factor * localB->trop_factor +
                                 0.002001));
          } else {
            localB->trop_factor = std::sin(localB->sigma_mp);
            localB->trop_factor = ((4.0 - (localB->sigma_mp + 57.295779513082323))
              * (4.0 - (localB->sigma_mp + 57.295779513082323)) * 0.015 + 1.0) *
              (1.001 / std::sqrt(localB->trop_factor * localB->trop_factor +
                                 0.002001));
          }

          localB->trop_factor *= 0.12;
          if ((rtu_1->PRN[localB->i] >= 1) && (rtu_1->PRN[localB->i] <= 37)) {
            localB->sigma_noise = -localB->sigma_mp * 180.0;
            localB->sigma_mp = std::exp(localB->sigma_noise / 31.415926535897931)
              * 0.53 + 0.13;
            localB->sigma_noise = std::exp(localB->sigma_noise /
              21.676989309769574) * 0.43 + 0.15;
            if (rtu_3 && rtu_4) {
              localB->sigma_noise = std::sqrt((localB->sigma_mp *
                localB->sigma_mp + localB->sigma_noise * localB->sigma_noise) *
                8.8700043010625738);
              localB->sigma_mp = 0.0;
            }
          } else if ((rtu_1->PRN[localB->i] >= 71) && (rtu_1->PRN[localB->i] <=
                      102)) {
            boolean_T exitg1;
            for (localB->idx = 0; localB->idx < 18; localB->idx++) {
              localB->x[localB->idx] = (5.0 * static_cast<real_T>(localB->idx) +
                5.0 < localB->sigma_mp + 57.295779513082323);
            }

            localB->idx = 0;
            localB->b_numMeas = 0;
            exitg1 = false;
            while ((!exitg1) && (localB->b_numMeas < 18)) {
              if (localB->x[localB->b_numMeas]) {
                localB->idx++;
                localB->ii_data[localB->idx - 1] = static_cast<int8_T>
                  (localB->b_numMeas + 1);
                if (localB->idx >= 18) {
                  exitg1 = true;
                } else {
                  localB->b_numMeas++;
                }
              } else {
                localB->b_numMeas++;
              }
            }

            if (localB->idx < 1) {
              localB->idx = 0;
            }

            if (localB->idx == 0) {
              localB->sigma_noise = 2.0;
              localB->sigma_mp = 0.0;
            } else {
              localB->b_numMeas = localB->ii_data[localB->idx - 1];
              localB->idx = (localB->b_numMeas - 1) << 1;
              localB->b_numMeas <<= 1;
              localB->sigma_noise = h[localB->b_numMeas];
              localB->totalProbability = h[localB->idx];
              localB->sigma_noise = (((localB->sigma_mp + 57.295779513082323) -
                localB->totalProbability) * h[localB->idx + 1] +
                (localB->sigma_noise - (localB->sigma_mp + 57.295779513082323)) *
                h[localB->b_numMeas + 1]) / (localB->sigma_noise -
                localB->totalProbability);
              localB->sigma_mp = 0.0;
            }
          } else {
            localB->sigma_noise = 1.0E+20;
            localB->sigma_mp = 1.0E+20;
          }

          localB->variance_pseudorange[localB->i] = (((localB->threshold *
            localB->threshold + localB->numIdentifiedFaults *
            localB->numIdentifiedFaults) + localB->trop_factor *
            localB->trop_factor) + localB->sigma_noise * localB->sigma_noise) +
            localB->sigma_mp * localB->sigma_mp;
        }
      }
      break;

     case 4:
      if (rtu_1_DIMS1->pseudorange < 1) {
        localB->b = 0;
      } else {
        localB->b = rtu_1_DIMS1->pseudorange;
      }

      for (localB->idx = 0; localB->idx < localB->b; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->
          variance_pseudorange[localB->idx] * 160000.0;
      }
      break;
    }

    if (rtu_1_DIMS1->pseudorange < 1) {
      localB->b = -1;
    } else {
      localB->b = rtu_1_DIMS1->pseudorange - 1;
    }

    localDW->SFunction_DIMS2_c = localB->b + 1;

    // BusAssignment: '<S123>/Bus Assignment' incorporates:
    //   MATLAB Function: '<S123>/Weighted RAIM Parity'
    //   MATLAB Function: '<S123>/calculate Variance'

    localDW->BusAssignment_DIMS1 = localDW->TmpHiddenBufferAtBusAssignmentI;
    localDW->BusAssignment_DIMS1.variance_pseudorange =
      localDW->SFunction_DIMS2_c;
    if (localB->b >= 0) {
      std::memcpy(&localB->GNSS_Measurement_out.variance_pseudorange[0],
                  &localB->variance_pseudorange[0], static_cast<uint32_T>
                  (localB->b + 1) * sizeof(real_T));
    }

    // MATLAB Function: '<S123>/Weighted RAIM Parity' incorporates:
    //   BusAssignment: '<S123>/Bus Assignment'
    //   BusCreator generated from: '<S123>/Weighted RAIM Parity'
    //   SignalConversion generated from: '<S123>/Bus Assignment'

    localDW->SFunction_DIMS6 = localDW->BusAssignment_DIMS1;
    localB->b = 0;
    localB->trop_factor = 0.0;
    localB->sigma_mp = 0.0;
    localB->threshold = 0.0;
    for (localB->i = 0; localB->i < 80; localB->i++) {
      rty_4[localB->i] = (rtNaN);
    }

    localB->c = localDW->SFunction_DIMS6.pseudorange;
    for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
      localB->v_data[localB->idx] = !std::isnan
        (localB->GNSS_Measurement_out.pseudorange[localB->idx]);
    }

    localB->c = localDW->SFunction_DIMS6.pseudorange - 1;
    localB->b_numMeas = 0;
    for (localB->i = 0; localB->i <= localB->c; localB->i++) {
      if (localB->v_data[localB->i]) {
        localB->b_numMeas++;
      }
    }

    localB->idx = localB->b_numMeas;
    localB->doIdentify = true;
    localB->numIdentifiedFaults = 0.0;
    while ((localB->idx > rtu_35) && localB->doIdentify) {
      localB->doIdentify = false;
      localB->i_n = localDW->SFunction_DIMS6.pseudorange;
      DDRTCM_RAIM_detect_Fault(localB->GNSS_Measurement_out.satellite_position,
        localDW->SFunction_DIMS6.satellite_position,
        localB->GNSS_Measurement_out.pseudorange, &localB->i_n,
        localB->GNSS_Measurement_out.variance_pseudorange, rtu_39, rtu_40,
        DDRTCM_P->table_chi_square, rtu_35, &localB->sigma_mp,
        &localB->threshold, &localB->trop_factor, localB->H_data, localB->H_size,
        localB->q_data, localB->q_size, localB->variance_pseudorange,
        &localB->c_size, localB);
      if (localB->trop_factor > rtu_28) {
        localB->b = 0;
      } else if (localB->sigma_mp > localB->threshold) {
        localB->b = 2;
      } else {
        localB->b = 1;
      }

      if ((localB->idx > rtu_35 + 1.0) && (localB->b == 2)) {
        __m128d tmp_0;
        for (localB->idx = 0; localB->idx < 80; localB->idx++) {
          localB->tmp_data_c[localB->idx] = (rtNaN);
        }

        localB->c = localDW->SFunction_DIMS6.pseudorange;
        for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
          localB->v_data[localB->idx] = !std::isnan
            (localB->GNSS_Measurement_out.pseudorange[localB->idx]);
        }

        localB->g = localDW->SFunction_DIMS6.pseudorange - 1;
        localB->i = 0;
        for (localB->idx = 0; localB->idx <= localB->g; localB->idx++) {
          if (localB->v_data[localB->idx]) {
            localB->i++;
          }
        }

        localB->rtu_1_DIMS1_idx_0 = localB->i;
        DDRTCM_sqrt_le(localB->q_data, localB->q_size);
        DDRTCM_mtimes_j(localB->q_data, localB->q_size, localB->H_data,
                        localB->H_size, localB->tmp_data, localB->tmp_size_j);
        DDRTCM_qr(localB->tmp_data, localB->tmp_size_j, localB->s_data,
                  localB->rtu_1_size, localB->H_data, localB->H_size, localB);
        localB->sigma_noise = (static_cast<real_T>(localB->rtu_1_size[1]) + 1.0)
          - (static_cast<real_T>(localB->i) - rtu_35);
        if (localB->sigma_noise > localB->rtu_1_size[1]) {
          localB->b_numMeas = 0;
          localB->g = 0;
        } else {
          localB->b_numMeas = static_cast<int32_T>(localB->sigma_noise) - 1;
          localB->g = localB->rtu_1_size[1];
        }

        localB->c = localB->g - localB->b_numMeas;
        localB->P_size[0] = localB->c;
        localB->P_size[1] = localB->rtu_1_size[0];
        localB->g = localB->rtu_1_size[0];
        for (localB->idx = 0; localB->idx < localB->g; localB->idx++) {
          for (localB->i = 0; localB->i < localB->c; localB->i++) {
            localB->P_data[localB->i + localB->c * localB->idx] = localB->
              s_data[(localB->b_numMeas + localB->i) * localB->rtu_1_size[0] +
              localB->idx];
          }
        }

        DDRTCM_mtimes(localB->q_data, localB->q_size,
                      localB->variance_pseudorange,
                      localB->P_satellite_fault_data, &localB->c_size, localB);
        DDRTCM_mtimes(localB->P_data, localB->P_size,
                      localB->P_satellite_fault_data,
                      localB->variance_pseudorange, &localB->c_size, localB);
        localB->indx_to_exclude_size[0] = 1;
        localB->indx_to_exclude_size[1] = static_cast<int8_T>
          (localB->rtu_1_DIMS1_idx_0);
        localB->q_size[0] = static_cast<int8_T>(localB->c);
        localB->q_size[1] = static_cast<int8_T>(localB->rtu_1_size[0]);
        localB->g = static_cast<int8_T>(localB->c) * static_cast<int8_T>
          (localB->rtu_1_size[0]);
        if (localB->g - 1 >= 0) {
          std::memset(&localB->q_data[0], 0, static_cast<uint32_T>(localB->g) *
                      sizeof(real_T));
        }

        localB->rtu_1_size[0] = static_cast<int8_T>(localB->c);
        localB->rtu_1_size[1] = static_cast<int8_T>(localB->P_size[1]);
        if (localB->g - 1 >= 0) {
          std::memset(&localB->s_data[0], 0, static_cast<uint32_T>(localB->g) *
                      sizeof(real_T));
        }

        for (localB->i = 0; localB->i < localB->rtu_1_DIMS1_idx_0; localB->i++)
        {
          localB->P_size_o = localB->P_size[0];
          localB->c = localB->P_size[0];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->P_satellite_fault_data[localB->idx] = localB->P_data
              [localB->P_size[0] * localB->i + localB->idx];
          }

          localB->sigma_noise = DDRTCM_norm(localB->P_satellite_fault_data,
            &localB->P_size_o);
          localB->c = localB->P_size[0];
          localB->b_numMeas = (localB->P_size[0] / 2) << 1;
          localB->g = localB->b_numMeas - 2;
          for (localB->idx = 0; localB->idx <= localB->g; localB->idx += 2) {
            tmp_0 = _mm_loadu_pd(&localB->P_data[localB->P_size[0] * localB->i +
                                 localB->idx]);
            _mm_storeu_pd(&localB->q_data[localB->idx + localB->q_size[0] *
                          localB->i], _mm_div_pd(tmp_0, _mm_set1_pd
              (localB->sigma_noise)));
          }

          for (localB->idx = localB->b_numMeas; localB->idx < localB->c;
               localB->idx++) {
            localB->q_data[localB->idx + localB->q_size[0] * localB->i] =
              localB->P_data[localB->P_size[0] * localB->i + localB->idx] /
              localB->sigma_noise;
          }

          localB->totalProbability = 0.0;
          localB->c = localB->c_size;
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->totalProbability += localB->q_data[localB->q_size[0] *
              localB->i + localB->idx] * localB->variance_pseudorange
              [localB->idx];
          }

          if (localB->c_size == localB->q_size[0]) {
            localB->c = localB->c_size;
            localB->b_numMeas = (localB->c_size / 2) << 1;
            localB->g = localB->b_numMeas - 2;
            for (localB->idx = 0; localB->idx <= localB->g; localB->idx += 2) {
              __m128d tmp;
              tmp_0 = _mm_loadu_pd(&localB->q_data[localB->q_size[0] * localB->i
                                   + localB->idx]);
              tmp = _mm_loadu_pd(&localB->variance_pseudorange[localB->idx]);
              _mm_storeu_pd(&localB->s_data[localB->idx + localB->rtu_1_size[0] *
                            localB->i], _mm_sub_pd(tmp, _mm_mul_pd(_mm_set1_pd
                (localB->totalProbability), tmp_0)));
            }

            for (localB->idx = localB->b_numMeas; localB->idx < localB->c;
                 localB->idx++) {
              localB->s_data[localB->idx + localB->rtu_1_size[0] * localB->i] =
                localB->variance_pseudorange[localB->idx] - localB->
                q_data[localB->q_size[0] * localB->i + localB->idx] *
                localB->totalProbability;
            }
          } else {
            DDRTCM_binary_expand_op_mz(localB->s_data, localB->rtu_1_size,
              localB->i, localB->variance_pseudorange, &localB->c_size,
              localB->totalProbability, localB->q_data, localB->q_size);
          }

          localB->totalProbability = 0.0;
          localB->c = localB->rtu_1_size[0];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->s = localB->s_data[localB->rtu_1_size[0] * localB->i +
              localB->idx];
            localB->totalProbability += -0.5 * localB->s * localB->s;
          }

          localB->indx_to_exclude_data[localB->i] = 1.0 / localB->sigma_noise *
            std::exp(localB->totalProbability);
        }

        localB->sigma_noise = DDRTCM_sum(localB->indx_to_exclude_data,
          localB->indx_to_exclude_size);
        if (localB->sigma_noise == 0.0) {
          localB->P_satellite_fault_size[0] = 1;
          localB->P_satellite_fault_size[1] = static_cast<int8_T>
            (localB->rtu_1_DIMS1_idx_0);
          if (localB->rtu_1_DIMS1_idx_0 - 1 >= 0) {
            std::memset(&localB->P_satellite_fault_data[0], 0,
                        static_cast<uint32_T>(localB->rtu_1_DIMS1_idx_0) *
                        sizeof(real_T));
          }

          localB->b_doIdentify = false;
        } else {
          localB->P_satellite_fault_size[0] = 1;
          localB->P_satellite_fault_size[1] = static_cast<int8_T>
            (localB->rtu_1_DIMS1_idx_0);
          localB->b_numMeas = (localB->rtu_1_DIMS1_idx_0 / 2) << 1;
          localB->g = localB->b_numMeas - 2;
          for (localB->idx = 0; localB->idx <= localB->g; localB->idx += 2) {
            tmp_0 = _mm_loadu_pd(&localB->indx_to_exclude_data[localB->idx]);
            _mm_storeu_pd(&localB->P_satellite_fault_data[localB->idx],
                          _mm_div_pd(tmp_0, _mm_set1_pd(localB->sigma_noise)));
          }

          for (localB->idx = localB->b_numMeas; localB->idx <
               localB->rtu_1_DIMS1_idx_0; localB->idx++) {
            localB->P_satellite_fault_data[localB->idx] =
              localB->indx_to_exclude_data[localB->idx] / localB->sigma_noise;
          }

          localB->b_doIdentify = true;
        }

        DDRTCM_sort_j(localB->P_satellite_fault_data,
                      localB->P_satellite_fault_size, localB->c_data,
                      localB->H_size, localB);
        localB->indx_to_isolate_size[1] = localB->H_size[1];
        localB->c = localB->H_size[1];
        if (localB->c - 1 >= 0) {
          std::memcpy(&localB->indx_to_isolate_data[0], &localB->c_data[0],
                      static_cast<uint32_T>(localB->c) * sizeof(int32_T));
        }

        localB->i = 1;
        localB->sigma_noise = 0.0;
        localB->totalProbability = 0.0;
        while (localB->b_doIdentify && (static_cast<real_T>
                (localB->rtu_1_DIMS1_idx_0) - localB->sigma_noise > rtu_35 + 1.0)
               && (localB->rtu_1_DIMS1_idx_0 > localB->i - 1) &&
               (localB->totalProbability < rtu_31) && (localB->sigma_noise <
                rtu_36)) {
          localB->g = localB->indx_to_isolate_size[1] - localB->i;
          localB->b_numMeas = localB->indx_to_isolate_data[localB->g];
          localB->c_size = localB->rtu_1_size[0];
          localB->c = localB->rtu_1_size[0];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->variance_pseudorange[localB->idx] = localB->s_data
              [(localB->b_numMeas - 1) * localB->rtu_1_size[0] + localB->idx];
          }

          if (DDRTCM_norm(localB->variance_pseudorange, &localB->c_size) <
              localB->threshold * 5.0) {
            localB->s = localB->P_satellite_fault_data
              [localB->P_satellite_fault_size[1] - localB->i];
            localB->totalProbability += localB->s;
            localB->idx = (static_cast<int32_T>(localB->sigma_noise + 1.0) - 1) <<
              1;
            localB->tmp_data_c[localB->idx] = localB->
              GNSS_Measurement_out.PRN[localB->indx_to_isolate_data[localB->g] -
              1];
            localB->tmp_data_c[localB->idx + 1] = localB->s;
            localB->sigma_noise++;
          }

          localB->i++;
        }

        if (!(localB->totalProbability < rtu_31)) {
          localB->doIdentify = true;
          if (localB->sigma_noise < 40.0) {
            if (localB->sigma_noise < 1.0) {
              localB->c = -1;
            } else {
              localB->c = static_cast<int32_T>(localB->sigma_noise) - 1;
            }

            for (localB->idx = 0; localB->idx <= localB->c; localB->idx++) {
              localB->i = localB->idx << 1;
              localB->b_numMeas = (static_cast<int32_T>((static_cast<real_T>
                (localB->idx) + 1.0) + localB->numIdentifiedFaults) - 1) << 1;
              rty_4[localB->b_numMeas] = localB->tmp_data_c[localB->i];
              rty_4[localB->b_numMeas + 1] = localB->tmp_data_c[localB->i + 1];
            }
          }

          localB->numIdentifiedFaults += localB->sigma_noise;
          localB->b_numMeas = 0;
          for (localB->idx = 0; localB->idx < 40; localB->idx++) {
            localB->b_doIdentify = !std::isnan(localB->tmp_data_c[localB->idx <<
              1]);
            if (localB->b_doIdentify) {
              localB->b_numMeas++;
            }

            localB->v_data[localB->idx] = localB->b_doIdentify;
          }

          localB->rtu_1_DIMS1_idx_0 = localB->b_numMeas;
          localB->c = 0;
          for (localB->idx = 0; localB->idx < 40; localB->idx++) {
            if (localB->v_data[localB->idx]) {
              localB->e_data[localB->c] = localB->idx + 1;
              localB->c++;
            }
          }

          localB->c = localDW->SFunction_DIMS6.pseudorange;
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->v_data[localB->idx] = !std::isnan
              (localB->GNSS_Measurement_out.pseudorange[localB->idx]);
          }

          localB->c = localDW->SFunction_DIMS6.pseudorange - 1;
          localB->b_numMeas = 0;
          for (localB->idx = 0; localB->idx <= localB->c; localB->idx++) {
            if (localB->v_data[localB->idx]) {
              localB->b_numMeas++;
            }
          }

          if (localB->b_numMeas < 1) {
            localB->P_satellite_fault_size[0] = 1;
            localB->P_satellite_fault_size[1] = 0;
          } else {
            localB->P_satellite_fault_size[0] = 1;
            localB->P_satellite_fault_size[1] = localB->b_numMeas;
            localB->c = localB->b_numMeas - 1;
            for (localB->idx = 0; localB->idx <= localB->c; localB->idx++) {
              localB->P_satellite_fault_data[localB->idx] = static_cast<real_T>
                (localB->idx) + 1.0;
            }
          }

          if (localB->rtu_1_DIMS1_idx_0 != 0) {
            localB->b_numMeas = static_cast<int8_T>(localB->rtu_1_DIMS1_idx_0);
            localB->c = localDW->SFunction_DIMS6.PRN;
            for (localB->i = 0; localB->i < localB->b_numMeas; localB->i++) {
              localB->sigma_noise = localB->tmp_data_c[(localB->e_data[localB->i]
                - 1) << 1];
              localB->v_size = localDW->SFunction_DIMS6.PRN;
              for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
                localB->v_data[localB->idx] = (localB->
                  GNSS_Measurement_out.PRN[localB->idx] == localB->sigma_noise);
              }

              DDRTCM_eml_find_c0w(localB->v_data, &localB->v_size,
                                  localB->c_data, &localB->c_size);
              localB->g = localB->c_size;
              for (localB->idx = 0; localB->idx < localB->g; localB->idx++) {
                localB->variance_pseudorange[localB->idx] = localB->
                  c_data[localB->idx];
              }

              if (localB->c_size == 0) {
                localB->indx_to_isolate_data[localB->i] = 0;
              } else {
                localB->indx_to_isolate_data[localB->i] = static_cast<int32_T>
                  (localB->variance_pseudorange[0]);
              }
            }

            localB->H_size[0] = 1;
            localB->H_size[1] = static_cast<int8_T>(localB->rtu_1_DIMS1_idx_0);
            localB->c = static_cast<int8_T>(localB->rtu_1_DIMS1_idx_0);
            std::memcpy(&localB->c_data[0], &localB->indx_to_isolate_data[0],
                        static_cast<uint32_T>(localB->c) * sizeof(int32_T));
            DDRTCM_nullAssignment(localB->P_satellite_fault_data,
                                  localB->P_satellite_fault_size, localB->c_data,
                                  localB->H_size);
          }

          localB->rtu_1_DIMS1_idx_0 =
            localDW->SFunction_DIMS6.satellite_position[0];
          localB->c = localDW->SFunction_DIMS6.satellite_position[1];
          localB->b_numMeas = localB->P_satellite_fault_size[1];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->g = localB->P_satellite_fault_size[1];
            for (localB->i = 0; localB->i < localB->g; localB->i++) {
              localB->tmp_data_k[localB->i + localB->b_numMeas * localB->idx] =
                localB->GNSS_Measurement_out.satellite_position
                [(localB->rtu_1_DIMS1_idx_0 * localB->idx + static_cast<int32_T>
                  (localB->P_satellite_fault_data[localB->i])) - 1];
            }
          }

          localDW->SFunction_DIMS6.satellite_position[0] =
            localB->P_satellite_fault_size[1];
          localB->c = localB->P_satellite_fault_size[1] *
            localDW->SFunction_DIMS6.satellite_position[1];
          if (localB->c - 1 >= 0) {
            std::memcpy(&localB->GNSS_Measurement_out.satellite_position[0],
                        &localB->tmp_data_k[0], static_cast<uint32_T>(localB->c)
                        * sizeof(real_T));
          }

          localDW->SFunction_DIMS6.satellite_velocity[0] =
            localB->P_satellite_fault_size[1];
          localB->b_numMeas = localB->P_satellite_fault_size[1];
          localB->c = localB->P_satellite_fault_size[1];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->tmp_data_g1[localB->idx] = localB->GNSS_Measurement_out.PRN[
              static_cast<int32_T>(localB->P_satellite_fault_data[localB->idx])
              - 1];
          }

          localDW->SFunction_DIMS6.PRN = localB->P_satellite_fault_size[1];
          if (localB->b_numMeas - 1 >= 0) {
            std::memcpy(&localB->GNSS_Measurement_out.PRN[0],
                        &localB->tmp_data_g1[0], static_cast<uint32_T>
                        (localB->b_numMeas) * sizeof(uint16_T));
          }

          localB->c = localB->P_satellite_fault_size[1];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->variance_pseudorange[localB->idx] =
              localB->GNSS_Measurement_out.pseudorange[static_cast<int32_T>
              (localB->P_satellite_fault_data[localB->idx]) - 1];
          }

          localDW->SFunction_DIMS6.pseudorange = localB->P_satellite_fault_size
            [1];
          localB->c = localB->P_satellite_fault_size[1];
          if (localB->c - 1 >= 0) {
            std::memcpy(&localB->GNSS_Measurement_out.pseudorange[0],
                        &localB->variance_pseudorange[0], static_cast<uint32_T>
                        (localB->c) * sizeof(real_T));
          }

          localDW->SFunction_DIMS6.pseudorange_raw =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.pseudorange_satclk_corrected =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.deltarange = localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.deltarange_raw =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.deltarange_satclk_corrected =
            localB->P_satellite_fault_size[1];
          localB->c = localB->P_satellite_fault_size[1];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->variance_pseudorange[localB->idx] =
              localB->GNSS_Measurement_out.variance_pseudorange
              [static_cast<int32_T>(localB->P_satellite_fault_data[localB->idx])
              - 1];
          }

          localDW->SFunction_DIMS6.variance_pseudorange =
            localB->P_satellite_fault_size[1];
          localB->c = localB->P_satellite_fault_size[1];
          if (localB->c - 1 >= 0) {
            std::memcpy(&localB->GNSS_Measurement_out.variance_pseudorange[0],
                        &localB->variance_pseudorange[0], static_cast<uint32_T>
                        (localB->c) * sizeof(real_T));
          }

          localDW->SFunction_DIMS6.variance_pseudorange_measured =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.variance_deltarange =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.carrierphase = localB->
            P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.carrierphase_raw =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.carrierphase_satclk_corrected =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.variance_carrierphase_measured =
            localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.locktime = localB->P_satellite_fault_size[1];
          localDW->SFunction_DIMS6.CN0 = localB->P_satellite_fault_size[1];
        }
      }

      localB->c = localDW->SFunction_DIMS6.pseudorange;
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->v_data[localB->idx] = !std::isnan
          (localB->GNSS_Measurement_out.pseudorange[localB->idx]);
      }

      localB->i = localDW->SFunction_DIMS6.pseudorange - 1;
      localB->idx = 0;
      for (localB->c = 0; localB->c <= localB->i; localB->c++) {
        if (localB->v_data[localB->c]) {
          localB->idx++;
        }
      }
    }

    if (localB->sigma_mp != 0.0) {
      *rty_3 = localB->sigma_mp / localB->threshold;
    } else {
      *rty_3 = 0.0;
    }

    *rty_1 = localB->b;
    *rty_2 = localB->trop_factor;

    // DigitalClock: '<S123>/Digital Clock'
    localB->threshold = (((&DDRTCM_M)->Timing.clockTick0) * 0.1);

    // MATLAB Function: '<S123>/Fault Exclusion'
    localB->b_numMeas = 0;
    for (localB->idx = 0; localB->idx < 40; localB->idx++) {
      localB->b_doIdentify = !std::isnan(rty_4[localB->idx << 1]);
      if (localB->b_doIdentify) {
        localB->b_numMeas++;
      }

      localB->v_data[localB->idx] = localB->b_doIdentify;
    }

    localB->iidx_size[1] = localB->b_numMeas;
    localB->b_numMeas = 0;
    for (localB->idx = 0; localB->idx < 40; localB->idx++) {
      if (localB->v_data[localB->idx]) {
        localB->iidx_data[localB->b_numMeas] = localB->idx + 1;
        localB->b_numMeas++;
      }
    }

    if (!localDW->BUFFER_not_empty) {
      localDW->BUFFER_not_empty = true;
      localDW->sys_clock_last_loop = localB->threshold;
    }

    if (!std::isnan(localDW->BUFFER[0])) {
      for (localB->b = 0; localB->b < 40; localB->b++) {
        localB->v_data[localB->b] = !std::isnan(localDW->BUFFER[localB->b << 1]);
      }

      localB->c = 0;
      localB->b_numMeas = 0;
      for (localB->i = 0; localB->i < 40; localB->i++) {
        if (localB->v_data[localB->i]) {
          localB->k_data[localB->c] = static_cast<int8_T>(localB->i + 1);
          localB->c++;
        }

        localB->b_doIdentify = !std::isnan(localDW->BUFFER[localB->i << 1]);
        if (localB->b_doIdentify) {
          localB->b_numMeas++;
        }

        localB->v_data[localB->i] = localB->b_doIdentify;
      }

      localB->c = 0;
      for (localB->idx = 0; localB->idx < 40; localB->idx++) {
        if (localB->v_data[localB->idx]) {
          localB->l_data[localB->c] = static_cast<int8_T>(localB->idx + 1);
          localB->c++;
        }
      }

      for (localB->idx = 0; localB->idx < localB->b_numMeas; localB->idx++) {
        localB->P_satellite_fault_data[localB->idx] = (localDW->BUFFER
          [((localB->l_data[localB->idx] - 1) << 1) + 1] + localB->threshold) -
          localDW->sys_clock_last_loop;
      }

      for (localB->idx = 0; localB->idx < localB->b_numMeas; localB->idx++) {
        localDW->BUFFER[((localB->k_data[localB->idx] - 1) << 1) + 1] =
          localB->P_satellite_fault_data[localB->idx];
      }
    }

    if (localB->iidx_size[1] != 0) {
      localB->b = localB->iidx_size[1];
      for (localB->i = 0; localB->i < localB->b; localB->i++) {
        localB->numIdentifiedFaults = rty_4[(localB->iidx_data[localB->i] - 1) <<
          1];
        for (localB->idx = 0; localB->idx < 40; localB->idx++) {
          localB->v_data[localB->idx] = (localDW->BUFFER[localB->idx << 1] ==
            localB->numIdentifiedFaults);
        }

        if (!DDRTCM_any_e(localB->v_data)) {
          for (localB->idx = 0; localB->idx < 40; localB->idx++) {
            localB->v_data[localB->idx] = std::isnan(localDW->BUFFER[localB->idx
              << 1]);
          }

          DDRTCM_eml_find_c(localB->v_data, localB->indx_to_isolate_data,
                            localB->indx_to_isolate_size);
          localB->c = localB->indx_to_isolate_size[1];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->idxPRN_data[localB->idx] = localB->
              indx_to_isolate_data[localB->idx];
          }

          if (localB->indx_to_isolate_size[1] != 0) {
            localB->b_numMeas = (static_cast<int32_T>(localB->idxPRN_data[0]) -
                                 1) << 1;
            localDW->BUFFER[localB->b_numMeas] = localB->numIdentifiedFaults;
            localDW->BUFFER[localB->b_numMeas + 1] = 0.0;
          }
        } else {
          for (localB->idx = 0; localB->idx < 40; localB->idx++) {
            localB->v_data[localB->idx] = (localDW->BUFFER[localB->idx << 1] ==
              localB->numIdentifiedFaults);
          }

          DDRTCM_eml_find_c(localB->v_data, localB->indx_to_isolate_data,
                            localB->indx_to_isolate_size);
          localB->c = localB->indx_to_isolate_size[1];
          for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
            localB->idxPRN_data[localB->idx] = localB->
              indx_to_isolate_data[localB->idx];
          }

          if (localB->indx_to_isolate_size[1] != 0) {
            localDW->BUFFER[((static_cast<int32_T>(localB->idxPRN_data[0]) - 1) <<
                             1) + 1] = 0.0;
          }
        }
      }
    }

    if (!std::isnan(localDW->BUFFER[0])) {
      localB->i = 0;
      for (localB->idx = 0; localB->idx < 40; localB->idx++) {
        localB->b_doIdentify = !std::isnan(localDW->BUFFER[localB->idx << 1]);
        if (localB->b_doIdentify) {
          localB->i++;
        }

        localB->v_data[localB->idx] = localB->b_doIdentify;
      }

      localB->c = localB->i;
      localB->i = 0;
      for (localB->idx = 0; localB->idx < 40; localB->idx++) {
        if (localB->v_data[localB->idx]) {
          localB->m_data[localB->i] = static_cast<int8_T>(localB->idx + 1);
          localB->i++;
        }
      }

      localB->tmp_size[0] = 1;
      localB->tmp_size[1] = localB->c;
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->v_data[localB->idx] = (localDW->BUFFER[((localB->m_data
          [localB->idx] - 1) << 1) + 1] <= rtu_33);
      }

      DDRTCM_eml_find_c0(localB->v_data, localB->tmp_size,
                         localB->indx_to_isolate_data,
                         localB->indx_to_isolate_size);
      localB->c = localB->indx_to_isolate_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->idxPRN_data[localB->idx] = localB->indx_to_isolate_data
          [localB->idx];
      }

      if (localB->indx_to_isolate_size[1] != 0) {
        localB->b = localB->indx_to_isolate_size[1];
        localB->c = localB->indx_to_isolate_size[1];
        for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
          localB->i = (static_cast<int32_T>(localB->idxPRN_data[localB->idx]) -
                       1) << 1;
          localB->tmp_data_c[localB->idx << 1] = localDW->BUFFER[localB->i];
          localB->tmp_data_c[1 + (localB->idx << 1)] = localDW->BUFFER[localB->i
            + 1];
        }

        for (localB->idx = 0; localB->idx < localB->b; localB->idx++) {
          localB->b_numMeas = localB->idx << 1;
          localDW->BUFFER[localB->b_numMeas] = localB->tmp_data_c[localB->idx <<
            1];
          localDW->BUFFER[localB->b_numMeas + 1] = localB->tmp_data_c
            [(localB->idx << 1) + 1];
        }

        if (localB->indx_to_isolate_size[1] + 1 > 40) {
          localB->b = 0;
          localB->c = 0;
        } else {
          localB->b = localB->indx_to_isolate_size[1];
          localB->c = 40;
        }

        localB->c -= localB->b;
        for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
          localB->b_numMeas = (localB->b + localB->idx) << 1;
          localDW->BUFFER[localB->b_numMeas] = (rtNaN);
          localDW->BUFFER[localB->b_numMeas + 1] = (rtNaN);
        }
      } else {
        for (localB->i = 0; localB->i < 80; localB->i++) {
          localDW->BUFFER[localB->i] = (rtNaN);
        }
      }
    }

    if (!std::isnan(localDW->BUFFER[0])) {
      localB->b_numMeas = 0;
      for (localB->i = 0; localB->i < 40; localB->i++) {
        localB->b_doIdentify = !std::isnan(localDW->BUFFER[localB->i << 1]);
        if (localB->b_doIdentify) {
          localB->b_numMeas++;
        }

        localB->v_data[localB->i] = localB->b_doIdentify;
      }

      localB->i = 0;
      for (localB->idx = 0; localB->idx < 40; localB->idx++) {
        if (localB->v_data[localB->idx]) {
          localB->n_data[localB->i] = static_cast<int8_T>(localB->idx + 1);
          localB->i++;
        }
      }

      localB->idxPRN_size[0] = 1;
      localB->idxPRN_size[1] = localB->b_numMeas;
      for (localB->idx = 0; localB->idx < localB->b_numMeas; localB->idx++) {
        localB->idxPRN_data[localB->idx] = localDW->BUFFER[((localB->
          n_data[localB->idx] - 1) << 1) + 1];
      }

      DDRTCM_sort_g(localB->idxPRN_data, localB->idxPRN_size, localB->iidx_data,
                    localB->iidx_size, localB);
      localB->c = localB->iidx_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->indx_to_exclude_data[localB->idx] = localB->iidx_data
          [localB->idx];
      }

      localB->c = localB->iidx_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->P_satellite_fault_data[localB->idx] = localDW->BUFFER[(
          static_cast<int32_T>(localB->indx_to_exclude_data[localB->idx]) - 1) <<
          1];
      }

      localB->c = localB->iidx_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localDW->BUFFER[localB->idx << 1] = localB->
          P_satellite_fault_data[localB->idx];
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localDW->BUFFER[(localB->idx << 1) + 1] = localB->idxPRN_data
          [localB->idx];
      }
    }

    localDW->sys_clock_last_loop = localB->threshold;
    for (localB->i = 0; localB->i < 80; localB->i++) {
      rty_6[localB->i] = (rtNaN);
    }

    localB->c = rtu_1_DIMS1->pseudorange;
    for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
      localB->v_data[localB->idx] = !std::isnan(rtu_1->pseudorange[localB->idx]);
    }

    localB->c = rtu_1_DIMS1->pseudorange - 1;
    localB->b = 0;
    for (localB->idx = 0; localB->idx <= localB->c; localB->idx++) {
      if (localB->v_data[localB->idx]) {
        localB->b++;
      }
    }

    localB->b_numMeas = localB->b;
    if (localB->b < 1) {
      localB->idxPRN_size[0] = 1;
      localB->idxPRN_size[1] = 0;
    } else {
      localB->idxPRN_size[0] = 1;
      localB->idxPRN_size[1] = localB->b;
      localB->c = localB->b - 1;
      for (localB->idx = 0; localB->idx <= localB->c; localB->idx++) {
        localB->idxPRN_data[localB->idx] = static_cast<real_T>(localB->idx) +
          1.0;
      }
    }

    if (!rtu_38) {
      localDW->SFunction_DIMS2 = *rtu_1_DIMS1;
      localB->GNSS_measurement_out = *rtu_1;
    } else {
      if (localB->b > 6) {
        localB->idx = 0;
        for (localB->b = 0; localB->b < 40; localB->b++) {
          localB->b_doIdentify = !std::isnan(localDW->BUFFER[localB->b << 1]);
          if (localB->b_doIdentify) {
            localB->idx++;
          }

          localB->v_data[localB->b] = localB->b_doIdentify;
        }

        localB->rtu_1_DIMS1_idx_0 = localB->idx;
        localB->idx = 0;
        for (localB->b = 0; localB->b < 40; localB->b++) {
          if (localB->v_data[localB->b]) {
            localB->p_data[localB->idx] = static_cast<int8_T>(localB->b + 1);
            localB->idx++;
          }
        }

        if (localB->rtu_1_DIMS1_idx_0 != 0) {
          localB->g = static_cast<int8_T>(localB->rtu_1_DIMS1_idx_0);
          localB->indx_to_exclude_size[0] = 1;
          localB->indx_to_exclude_size[1] = static_cast<int8_T>
            (localB->rtu_1_DIMS1_idx_0);
          localB->c = rtu_1_DIMS1->PRN;
          for (localB->i = 0; localB->i < localB->g; localB->i++) {
            localB->totalProbability = localDW->BUFFER[(localB->p_data[localB->i]
              - 1) << 1];
            localB->v_size = rtu_1_DIMS1->PRN;
            for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
              localB->v_data[localB->idx] = (rtu_1->PRN[localB->idx] ==
                localB->totalProbability);
            }

            DDRTCM_eml_find_c0w(localB->v_data, &localB->v_size, localB->c_data,
                                &localB->c_size);
            if (localB->c_size == 0) {
              localB->indx_to_exclude_data[localB->i] = 0.0;
            } else {
              localB->indx_to_exclude_data[localB->i] = localB->c_data[0];
            }
          }

          DDRTCM_eml_find_c0wi(localB->indx_to_exclude_data,
                               localB->indx_to_exclude_size, &localB->v_size,
                               localB->tmp_size);
          if (localB->tmp_size[1] != 0) {
            localB->i = static_cast<int8_T>(localB->rtu_1_DIMS1_idx_0) - 1;
            localB->c = 0;
            for (localB->b = 0; localB->b <= localB->i; localB->b++) {
              if (localB->indx_to_exclude_data[localB->b] != 0.0) {
                localB->c++;
              }
            }

            localB->idx = 0;
            for (localB->b = 0; localB->b <= localB->i; localB->b++) {
              localB->threshold = localB->indx_to_exclude_data[localB->b];
              if (localB->threshold != 0.0) {
                localB->indx_to_exclude_data[localB->idx] = localB->threshold;
                localB->idx++;
              }
            }

            localB->indx_to_exclude_size[1] = localB->c;
            if (localB->b_numMeas - localB->c >= 6) {
              localB->iidx_size[0] = 1;
              localB->iidx_size[1] = localB->c;
              for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
                localB->iidx_data[localB->idx] = static_cast<int32_T>
                  (localB->indx_to_exclude_data[localB->idx]);
              }

              DDRTCM_nullAssignment(localB->idxPRN_data, localB->idxPRN_size,
                                    localB->iidx_data, localB->iidx_size);
            } else {
              localB->indx_to_exclude_size[1] = localB->b_numMeas - 6;
              localB->iidx_size[0] = 1;
              localB->iidx_size[1] = localB->b_numMeas - 6;
              localB->c = localB->b_numMeas - 6;
              for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
                localB->iidx_data[localB->idx] = static_cast<int32_T>
                  (localB->indx_to_exclude_data[localB->idx]);
              }

              DDRTCM_nullAssignment(localB->idxPRN_data, localB->idxPRN_size,
                                    localB->iidx_data, localB->iidx_size);
            }
          }

          localB->b = 0;
          if ((localB->indx_to_exclude_data[localB->b] != 0.0) &&
              (localB->indx_to_exclude_size[1] != 0)) {
            localB->b_numMeas = localB->indx_to_exclude_size[1];
            for (localB->c = 0; localB->c < localB->b_numMeas; localB->c++) {
              localB->idx = localB->c << 1;
              rty_6[localB->idx] = rtu_1->PRN[static_cast<int32_T>
                (localB->indx_to_exclude_data[localB->c]) - 1];
              localB->threshold = rty_6[localB->idx];
              for (localB->i = 0; localB->i < 40; localB->i++) {
                localB->v_data[localB->i] = (localDW->BUFFER[localB->i << 1] ==
                  localB->threshold);
              }

              DDRTCM_eml_find_c(localB->v_data, localB->iidx_data,
                                localB->tmp_size);
              rty_6[localB->idx + 1] = localDW->BUFFER[((localB->
                iidx_data[localB->b] - 1) << 1) + 1];
            }
          }
        }
      }

      localB->GNSS_measurement_out.time_receive = rtu_1->time_receive;
      localB->rtu_1_DIMS1_idx_0 = rtu_1_DIMS1->satellite_position[0];
      localB->c = rtu_1_DIMS1->satellite_position[1];
      localB->b_numMeas = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->g = localB->idxPRN_size[1];
        for (localB->i = 0; localB->i < localB->g; localB->i++) {
          localB->tmp_data_k[localB->i + localB->b_numMeas * localB->idx] =
            rtu_1->satellite_position[(localB->rtu_1_DIMS1_idx_0 * localB->idx +
            static_cast<int32_T>(localB->idxPRN_data[localB->i])) - 1];
        }
      }

      localDW->SFunction_DIMS2.satellite_position[0] = localB->idxPRN_size[1];
      localDW->SFunction_DIMS2.satellite_position[1] =
        rtu_1_DIMS1->satellite_position[1];
      localB->c = localB->idxPRN_size[1] * rtu_1_DIMS1->satellite_position[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.satellite_position[0],
                    &localB->tmp_data_k[0], static_cast<uint32_T>(localB->c) *
                    sizeof(real_T));
      }

      localB->rtu_1_DIMS1_idx_0 = rtu_1_DIMS1->satellite_velocity[0];
      localB->c = rtu_1_DIMS1->satellite_velocity[1];
      localB->b_numMeas = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->g = localB->idxPRN_size[1];
        for (localB->i = 0; localB->i < localB->g; localB->i++) {
          localB->tmp_data_k[localB->i + localB->b_numMeas * localB->idx] =
            rtu_1->satellite_velocity[(localB->rtu_1_DIMS1_idx_0 * localB->idx +
            static_cast<int32_T>(localB->idxPRN_data[localB->i])) - 1];
        }
      }

      localDW->SFunction_DIMS2.satellite_velocity[0] = localB->idxPRN_size[1];
      localDW->SFunction_DIMS2.satellite_velocity[1] =
        rtu_1_DIMS1->satellite_velocity[1];
      localB->c = localB->idxPRN_size[1] * rtu_1_DIMS1->satellite_velocity[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.satellite_velocity[0],
                    &localB->tmp_data_k[0], static_cast<uint32_T>(localB->c) *
                    sizeof(real_T));
      }

      localB->b_numMeas = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->tmp_data_g1[localB->idx] = rtu_1->PRN[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.PRN = localB->idxPRN_size[1];
      if (localB->b_numMeas - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.PRN[0], &localB->tmp_data_g1[0],
                    static_cast<uint32_T>(localB->b_numMeas) * sizeof(uint16_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->pseudorange[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.pseudorange = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.pseudorange[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->pseudorange_raw[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.pseudorange_raw = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.pseudorange_raw[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] =
          rtu_1->pseudorange_satclk_corrected[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.pseudorange_satclk_corrected =
        localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.pseudorange_satclk_corrected[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->deltarange[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.deltarange = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.deltarange[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->deltarange_raw[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.deltarange_raw = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.deltarange_raw[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] =
          rtu_1->deltarange_satclk_corrected[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.deltarange_satclk_corrected = localB->
        idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.deltarange_satclk_corrected[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->variance_pseudorange[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.variance_pseudorange = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.variance_pseudorange[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] =
          rtu_1->variance_pseudorange_measured[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.variance_pseudorange_measured =
        localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.variance_pseudorange_measured
                    [0], &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->variance_deltarange[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.variance_deltarange = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.variance_deltarange[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->carrierphase[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.carrierphase = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.carrierphase[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->carrierphase_raw[
          static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.carrierphase_raw = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.carrierphase_raw[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] =
          rtu_1->carrierphase_satclk_corrected[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.carrierphase_satclk_corrected =
        localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.carrierphase_satclk_corrected
                    [0], &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] =
          rtu_1->variance_carrierphase_measured[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.variance_carrierphase_measured =
        localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->
                    GNSS_measurement_out.variance_carrierphase_measured[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->b_numMeas = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->tmp_data_g[localB->idx] = rtu_1->locktime[static_cast<int32_T>
          (localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.locktime = localB->idxPRN_size[1];
      if (localB->b_numMeas - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.locktime[0],
                    &localB->tmp_data_g[0], static_cast<uint32_T>
                    (localB->b_numMeas) * sizeof(real32_T));
      }

      localB->c = localB->idxPRN_size[1];
      for (localB->idx = 0; localB->idx < localB->c; localB->idx++) {
        localB->variance_pseudorange[localB->idx] = rtu_1->CN0
          [static_cast<int32_T>(localB->idxPRN_data[localB->idx]) - 1];
      }

      localDW->SFunction_DIMS2.CN0 = localB->idxPRN_size[1];
      localB->c = localB->idxPRN_size[1];
      if (localB->c - 1 >= 0) {
        std::memcpy(&localB->GNSS_measurement_out.CN0[0],
                    &localB->variance_pseudorange[0], static_cast<uint32_T>
                    (localB->c) * sizeof(real_T));
      }

      localB->GNSS_measurement_out.base_position[0] = rtu_1->base_position[0];
      localB->GNSS_measurement_out.base_position[1] = rtu_1->base_position[1];
      localB->GNSS_measurement_out.base_position[2] = rtu_1->base_position[2];
    }

    std::memcpy(&rty_5[0], &localDW->BUFFER[0], 80U * sizeof(real_T));

    // End of MATLAB Function: '<S123>/Fault Exclusion'
    // End of Outputs for SubSystem: '<S122>/GNSS Fault Detection Identification Exclusion' 
  } else {
    *rty_useOriginalGNSSmeasurement = true;
  }
}

//
// Output and update for atomic system:
//    '<S122>/switch GNSS Measurements'
//    '<S249>/switch GNSS Measurements'
//
void DDRTCM::DDRTCM_switchGNSSMeasurements(boolean_T
  rtu_useOriginalGNSSmeasurement, const GNSS_Measurement
  *rtu_GNSS_Measurement_orig, const GNSS_Measurement_size
  *rtu_GNSS_Measurement_orig_DIMS1, const GNSS_Measurement
  *rtu_GNSS_Measurement_FDE, const GNSS_Measurement_size
  *rtu_GNSS_Measurement_FDE_DIMS1, B_switchGNSSMeasurements_DDRT_T *localB,
  DW_switchGNSSMeasurements_DDR_T *localDW)
{
  if (rtu_useOriginalGNSSmeasurement) {
    localDW->SFunction_DIMS2 = *rtu_GNSS_Measurement_orig_DIMS1;
    localB->GNSS_Measurement_a = *rtu_GNSS_Measurement_orig;
  } else {
    localDW->SFunction_DIMS2 = *rtu_GNSS_Measurement_FDE_DIMS1;
    localB->GNSS_Measurement_a = *rtu_GNSS_Measurement_FDE;
  }
}

//
// Output and update for atomic system:
//    '<S4>/MATLAB Function'
//    '<S5>/MATLAB Function'
//
void DDRTCM::DDRTCM_MATLABFunction_o(const GNSS_Measurement
  *rtu_GnssMeasurementB, const GNSS_Measurement_size *rtu_GnssMeasurementB_DIMS1,
  B_MATLABFunction_DDRTCM_j_T *localB, DW_MATLABFunction_DDRTCM_h_T *localDW)
{
  int32_T b_size_idx_0_tmp;
  int32_T f_size_idx_0;
  int32_T loop_ub;
  int8_T pb_data[40];
  b_size_idx_0_tmp = rtu_GnssMeasurementB_DIMS1->PRN;
  for (int32_T b_i{0}; b_i < b_size_idx_0_tmp; b_i++) {
    localB->b_data[b_i] = (rtu_GnssMeasurementB->PRN[b_i] >= 1);
  }

  for (int32_T b_i{0}; b_i < b_size_idx_0_tmp; b_i++) {
    localB->c_data[b_i] = (rtu_GnssMeasurementB->PRN[b_i] <= 37);
  }

  for (int32_T b_i{0}; b_i < b_size_idx_0_tmp; b_i++) {
    localB->d_data[b_i] = (rtu_GnssMeasurementB->PRN[b_i] >= 71);
  }

  for (int32_T b_i{0}; b_i < b_size_idx_0_tmp; b_i++) {
    localB->e_data[b_i] = (rtu_GnssMeasurementB->PRN[b_i] <= 106);
  }

  localB->GpsMeasurementB.time_receive = rtu_GnssMeasurementB->time_receive;
  b_size_idx_0_tmp = rtu_GnssMeasurementB_DIMS1->PRN - 1;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->f_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->tmp_data[b_i] = rtu_GnssMeasurementB->satellite_position
      [localB->f_data[b_i] - 1];
  }

  localDW->SFunction_DIMS2.satellite_position[0] = f_size_idx_0;
  localDW->SFunction_DIMS2.satellite_position[1] = 1;
  if (f_size_idx_0 - 1 >= 0) {
    std::memcpy(&localB->GpsMeasurementB.satellite_position[0],
                &localB->tmp_data[0], static_cast<uint32_T>(f_size_idx_0) *
                sizeof(real_T));
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->g_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->tmp_data[b_i] = rtu_GnssMeasurementB->satellite_velocity
      [localB->g_data[b_i] - 1];
  }

  localDW->SFunction_DIMS2.satellite_velocity[0] = f_size_idx_0;
  localDW->SFunction_DIMS2.satellite_velocity[1] = 1;
  if (f_size_idx_0 - 1 >= 0) {
    std::memcpy(&localB->GpsMeasurementB.satellite_velocity[0],
                &localB->tmp_data[0], static_cast<uint32_T>(f_size_idx_0) *
                sizeof(real_T));
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->h_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.PRN = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.PRN[b_i] = rtu_GnssMeasurementB->PRN[localB->
      h_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->i_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.pseudorange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.pseudorange[b_i] = rtu_GnssMeasurementB->
      pseudorange[localB->i_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->j_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.pseudorange_raw = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.pseudorange_raw[b_i] =
      rtu_GnssMeasurementB->pseudorange[localB->j_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->k_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.pseudorange_satclk_corrected = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.pseudorange_satclk_corrected[b_i] =
      rtu_GnssMeasurementB->pseudorange[localB->k_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->l_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.deltarange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.deltarange[b_i] = rtu_GnssMeasurementB->
      deltarange[localB->l_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->m_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.deltarange_raw = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.deltarange_raw[b_i] =
      rtu_GnssMeasurementB->deltarange[localB->m_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->n_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.deltarange_satclk_corrected = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.deltarange_satclk_corrected[b_i] =
      rtu_GnssMeasurementB->deltarange[localB->n_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->o_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.variance_pseudorange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.variance_pseudorange[b_i] =
      rtu_GnssMeasurementB->variance_pseudorange[localB->o_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->p_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.variance_pseudorange_measured = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.variance_pseudorange_measured[b_i] =
      rtu_GnssMeasurementB->variance_pseudorange_measured[localB->p_data[b_i] -
      1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->q_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.variance_deltarange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.variance_deltarange[b_i] =
      rtu_GnssMeasurementB->variance_deltarange[localB->q_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->r_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.carrierphase = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.carrierphase[b_i] =
      rtu_GnssMeasurementB->carrierphase[localB->r_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->s_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.carrierphase_raw = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.carrierphase_raw[b_i] =
      rtu_GnssMeasurementB->carrierphase[localB->s_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->t_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.carrierphase_satclk_corrected = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.carrierphase_satclk_corrected[b_i] =
      rtu_GnssMeasurementB->carrierphase[localB->t_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->u_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.variance_carrierphase_measured = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.variance_carrierphase_measured[b_i] =
      rtu_GnssMeasurementB->variance_carrierphase_measured[localB->u_data[b_i] -
      1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->v_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.locktime = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.locktime[b_i] = rtu_GnssMeasurementB->
      locktime[localB->v_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->b_data[b_i] && localB->c_data[b_i]) {
      localB->w_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS2.CN0 = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GpsMeasurementB.CN0[b_i] = rtu_GnssMeasurementB->CN0[localB->
      w_data[b_i] - 1];
  }

  localB->GpsMeasurementB.base_position[0] = rtu_GnssMeasurementB->
    base_position[0];
  localB->GpsMeasurementB.base_position[1] = rtu_GnssMeasurementB->
    base_position[1];
  localB->GpsMeasurementB.base_position[2] = rtu_GnssMeasurementB->
    base_position[2];
  localB->GalMeasurementB.time_receive = rtu_GnssMeasurementB->time_receive;
  b_size_idx_0_tmp = rtu_GnssMeasurementB_DIMS1->PRN - 1;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->x_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->tmp_data[b_i] = rtu_GnssMeasurementB->satellite_position
      [localB->x_data[b_i] - 1];
  }

  localDW->SFunction_DIMS3.satellite_position[0] = f_size_idx_0;
  localDW->SFunction_DIMS3.satellite_position[1] = 1;
  if (f_size_idx_0 - 1 >= 0) {
    std::memcpy(&localB->GalMeasurementB.satellite_position[0],
                &localB->tmp_data[0], static_cast<uint32_T>(f_size_idx_0) *
                sizeof(real_T));
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->y_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->tmp_data[b_i] = rtu_GnssMeasurementB->satellite_velocity
      [localB->y_data[b_i] - 1];
  }

  localDW->SFunction_DIMS3.satellite_velocity[0] = f_size_idx_0;
  localDW->SFunction_DIMS3.satellite_velocity[1] = 1;
  if (f_size_idx_0 - 1 >= 0) {
    std::memcpy(&localB->GalMeasurementB.satellite_velocity[0],
                &localB->tmp_data[0], static_cast<uint32_T>(f_size_idx_0) *
                sizeof(real_T));
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->ab_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.PRN = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.PRN[b_i] = rtu_GnssMeasurementB->PRN[localB->
      ab_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->bb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.pseudorange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.pseudorange[b_i] = rtu_GnssMeasurementB->
      pseudorange[localB->bb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->cb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.pseudorange_raw = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.pseudorange_raw[b_i] =
      rtu_GnssMeasurementB->pseudorange[localB->cb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->db_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.pseudorange_satclk_corrected = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.pseudorange_satclk_corrected[b_i] =
      rtu_GnssMeasurementB->pseudorange[localB->db_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->eb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.deltarange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.deltarange[b_i] = rtu_GnssMeasurementB->
      deltarange[localB->eb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->fb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.deltarange_raw = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.deltarange_raw[b_i] =
      rtu_GnssMeasurementB->deltarange[localB->fb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->gb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.deltarange_satclk_corrected = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.deltarange_satclk_corrected[b_i] =
      rtu_GnssMeasurementB->deltarange[localB->gb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->hb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.variance_pseudorange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.variance_pseudorange[b_i] =
      rtu_GnssMeasurementB->variance_pseudorange[localB->hb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->ib_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.variance_pseudorange_measured = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.variance_pseudorange_measured[b_i] =
      rtu_GnssMeasurementB->variance_pseudorange_measured[localB->ib_data[b_i] -
      1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->jb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.variance_deltarange = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.variance_deltarange[b_i] =
      rtu_GnssMeasurementB->variance_deltarange[localB->jb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->kb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.carrierphase = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.carrierphase[b_i] =
      rtu_GnssMeasurementB->carrierphase[localB->kb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->lb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.carrierphase_raw = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.carrierphase_raw[b_i] =
      rtu_GnssMeasurementB->carrierphase[localB->lb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->mb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.carrierphase_satclk_corrected = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.carrierphase_satclk_corrected[b_i] =
      rtu_GnssMeasurementB->carrierphase[localB->mb_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->nb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.variance_carrierphase_measured = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.variance_carrierphase_measured[b_i] =
      rtu_GnssMeasurementB->variance_carrierphase_measured[localB->nb_data[b_i]
      - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      localB->ob_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.locktime = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.locktime[b_i] = rtu_GnssMeasurementB->
      locktime[localB->ob_data[b_i] - 1];
  }

  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      loop_ub++;
    }
  }

  f_size_idx_0 = loop_ub;
  loop_ub = 0;
  for (int32_T b_i{0}; b_i <= b_size_idx_0_tmp; b_i++) {
    if (localB->d_data[b_i] && localB->e_data[b_i]) {
      pb_data[loop_ub] = static_cast<int8_T>(b_i + 1);
      loop_ub++;
    }
  }

  localDW->SFunction_DIMS3.CN0 = f_size_idx_0;
  for (int32_T b_i{0}; b_i < f_size_idx_0; b_i++) {
    localB->GalMeasurementB.CN0[b_i] = rtu_GnssMeasurementB->CN0[pb_data[b_i] -
      1];
  }

  localB->GalMeasurementB.base_position[0] = rtu_GnssMeasurementB->
    base_position[0];
  localB->GalMeasurementB.base_position[1] = rtu_GnssMeasurementB->
    base_position[1];
  localB->GalMeasurementB.base_position[2] = rtu_GnssMeasurementB->
    base_position[2];
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
real_T DDRTCM::DDRTCM_GGTO_delta_T_GNSS(real_T GalGstGps_Bus_A_1G, real_T
  GalGstGps_Bus_A_0G, uint32_T GalGstGps_Bus_t_oG, uint8_T GalGstGps_Bus_WN_oG,
  real_T GSTTOW, real_T GSTWNc)
{
  real_T delta_week;
  if (std::isnan(GSTWNc)) {
    delta_week = (rtNaN);
  } else if (std::isinf(GSTWNc)) {
    delta_week = (rtNaN);
  } else if (GSTWNc == 0.0) {
    delta_week = 0.0;
  } else {
    delta_week = std::fmod(GSTWNc, 64.0);
    if (delta_week == 0.0) {
      delta_week = 0.0;
    } else if (GSTWNc < 0.0) {
      delta_week += 64.0;
    }
  }

  delta_week -= static_cast<real_T>(GalGstGps_Bus_WN_oG);
  if (delta_week > 31.0) {
    delta_week -= std::floor(delta_week / 31.0) * 31.0;
  } else if (delta_week < -31.0) {
    delta_week += std::floor(delta_week / 31.0) * 31.0;
  }

  return ((GSTTOW - static_cast<real_T>(GalGstGps_Bus_t_oG)) + 604800.0 *
          delta_week) * GalGstGps_Bus_A_1G + GalGstGps_Bus_A_0G;
}

void DDRTCM::emxConvertDynamicMatrixToEmx_40(emxArray_real_T_40x3_DDRTCM_T *emx,
  const real_T data[120], const int32_T size[2])
{
  std::memcpy(&emx->data, (void *)data, sizeof(real_T) * static_cast<uint32_T>
              (size[0] * size[1]));
  std::memcpy(&emx->size, (void *)size, sizeof(int32_T) << 1U);
}

void DDRTCM::emxConvertDynamicMatrixToEmx__b(emxArray_uint16_T_40_DDRTCM_T *emx,
  const uint16_T data[40], const int32_T *size)
{
  std::memcpy(&emx->data, (void *)data, sizeof(uint16_T) * static_cast<uint32_T>
              (*size));
  std::memcpy(&emx->size, (void *)size, sizeof(int32_T));
}

void DDRTCM::emxConvertDynamicMatrixToEmx_bh(emxArray_real_T_40_DDRTCM_T *emx,
  const real_T data[40], const int32_T *size)
{
  std::memcpy(&emx->data, (void *)data, sizeof(real_T) * static_cast<uint32_T>
              (*size));
  std::memcpy(&emx->size, (void *)size, sizeof(int32_T));
}

void DDRTCM::emxConvertDynamicMatrixToEm_bhl(emxArray_real32_T_40_DDRTCM_T *emx,
  const real32_T data[40], const int32_T *size)
{
  std::memcpy(&emx->data, (void *)data, sizeof(real32_T) * static_cast<uint32_T>
              (*size));
  std::memcpy(&emx->size, (void *)size, sizeof(int32_T));
}

void DDRTCM::emxConvertStructToEmx_GNSS_Meas(emxArray__GNSS_Measurement_DD_T
  *emx, const GNSS_Measurement *data, const GNSS_Measurement_size *size)
{
  std::memcpy(&emx->time_receive, &data->time_receive, static_cast<uint32_T>
              (sizeof(real_T)));
  emxConvertDynamicMatrixToEmx_40(&emx->satellite_position,
    data->satellite_position, size->satellite_position);
  emxConvertDynamicMatrixToEmx_40(&emx->satellite_velocity,
    data->satellite_velocity, size->satellite_velocity);
  emxConvertDynamicMatrixToEmx__b(&emx->PRN, data->PRN, &size->PRN);
  emxConvertDynamicMatrixToEmx_bh(&emx->pseudorange, data->pseudorange,
    &size->pseudorange);
  emxConvertDynamicMatrixToEmx_bh(&emx->pseudorange_raw, data->pseudorange_raw,
    &size->pseudorange_raw);
  emxConvertDynamicMatrixToEmx_bh(&emx->pseudorange_satclk_corrected,
    data->pseudorange_satclk_corrected, &size->pseudorange_satclk_corrected);
  emxConvertDynamicMatrixToEmx_bh(&emx->deltarange, data->deltarange,
    &size->deltarange);
  emxConvertDynamicMatrixToEmx_bh(&emx->deltarange_raw, data->deltarange_raw,
    &size->deltarange_raw);
  emxConvertDynamicMatrixToEmx_bh(&emx->deltarange_satclk_corrected,
    data->deltarange_satclk_corrected, &size->deltarange_satclk_corrected);
  emxConvertDynamicMatrixToEmx_bh(&emx->variance_pseudorange,
    data->variance_pseudorange, &size->variance_pseudorange);
  emxConvertDynamicMatrixToEmx_bh(&emx->variance_pseudorange_measured,
    data->variance_pseudorange_measured, &size->variance_pseudorange_measured);
  emxConvertDynamicMatrixToEmx_bh(&emx->variance_deltarange,
    data->variance_deltarange, &size->variance_deltarange);
  emxConvertDynamicMatrixToEmx_bh(&emx->carrierphase, data->carrierphase,
    &size->carrierphase);
  emxConvertDynamicMatrixToEmx_bh(&emx->carrierphase_raw, data->carrierphase_raw,
    &size->carrierphase_raw);
  emxConvertDynamicMatrixToEmx_bh(&emx->carrierphase_satclk_corrected,
    data->carrierphase_satclk_corrected, &size->carrierphase_satclk_corrected);
  emxConvertDynamicMatrixToEmx_bh(&emx->variance_carrierphase_measured,
    data->variance_carrierphase_measured, &size->variance_carrierphase_measured);
  emxConvertDynamicMatrixToEm_bhl(&emx->locktime, data->locktime,
    &size->locktime);
  emxConvertDynamicMatrixToEmx_bh(&emx->CN0, data->CN0, &size->CN0);
  std::memcpy(&emx->base_position, &data->base_position, static_cast<uint32_T>
              (sizeof(real_T [3])));
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_mergeMyBus_d(const emxArray__GNSS_Measurement_DD_T
  *varargin_1, const emxArray__GNSS_Measurement_DD_T *varargin_2,
  s_p3XDoG4hWh7L3rtSKHmAfC_DDRT_T *outputBus)
{
  int32_T loop_ub;
  int32_T loop_ub_0;
  int8_T empty_non_axis_sizes_0[2];
  int8_T empty_non_axis_sizes_1[2];
  int8_T sizes_idx_1;
  boolean_T empty_non_axis_sizes;
  outputBus->time_receive = varargin_1->time_receive;
  outputBus->base_position[0] = varargin_1->base_position[0];
  outputBus->base_position[1] = varargin_1->base_position[1];
  outputBus->base_position[2] = varargin_1->base_position[2];
  if ((varargin_1->satellite_position.size[0] != 0) &&
      (varargin_1->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_position.size[1]);
  } else if ((varargin_2->satellite_position.size[0] != 0) &&
             (varargin_2->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_position.size[1]);
  } else if (varargin_2->satellite_position.size[1] >
             varargin_1->satellite_position.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_position.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_position.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_position.size[0]);
  } else if ((varargin_1->satellite_position.size[0] != 0) &&
             (varargin_1->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_position.size[0]);
  } else if ((varargin_2->satellite_position.size[0] != 0) &&
             (varargin_2->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus->satellite_position.size[0] = empty_non_axis_sizes_0[0] +
    empty_non_axis_sizes_1[0];
  outputBus->satellite_position.size[1] = sizes_idx_1;
  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_position.data[i + outputBus->satellite_position.size
        [0] * i_0] = varargin_1->satellite_position.data[empty_non_axis_sizes_0
        [0] * i_0 + i];
    }
  }

  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_position.data[(i + empty_non_axis_sizes_0[0]) +
        outputBus->satellite_position.size[0] * i_0] =
        varargin_2->satellite_position.data[empty_non_axis_sizes_1[0] * i_0 + i];
    }
  }

  if ((varargin_1->satellite_velocity.size[0] != 0) &&
      (varargin_1->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_velocity.size[1]);
  } else if ((varargin_2->satellite_velocity.size[0] != 0) &&
             (varargin_2->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_velocity.size[1]);
  } else if (varargin_2->satellite_velocity.size[1] >
             varargin_1->satellite_velocity.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_velocity.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_velocity.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_velocity.size[0]);
  } else if ((varargin_1->satellite_velocity.size[0] != 0) &&
             (varargin_1->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_velocity.size[0]);
  } else if ((varargin_2->satellite_velocity.size[0] != 0) &&
             (varargin_2->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus->satellite_velocity.size[0] = empty_non_axis_sizes_0[0] +
    empty_non_axis_sizes_1[0];
  outputBus->satellite_velocity.size[1] = sizes_idx_1;
  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_velocity.data[i + outputBus->satellite_velocity.size
        [0] * i_0] = varargin_1->satellite_velocity.data[empty_non_axis_sizes_0
        [0] * i_0 + i];
    }
  }

  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_velocity.data[(i + empty_non_axis_sizes_0[0]) +
        outputBus->satellite_velocity.size[0] * i_0] =
        varargin_2->satellite_velocity.data[empty_non_axis_sizes_1[0] * i_0 + i];
    }
  }

  outputBus->PRN.size = varargin_1->PRN.size + varargin_2->PRN.size;
  if (varargin_1->PRN.size - 1 >= 0) {
    std::memcpy(&outputBus->PRN.data[0], &varargin_1->PRN.data[0],
                static_cast<uint32_T>(varargin_1->PRN.size) * sizeof(uint16_T));
  }

  loop_ub = varargin_2->PRN.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->PRN.data[i_0 + varargin_1->PRN.size] = varargin_2->PRN.data[i_0];
  }

  outputBus->pseudorange.size = varargin_1->pseudorange.size +
    varargin_2->pseudorange.size;
  if (varargin_1->pseudorange.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange.data[0], &varargin_1->pseudorange.data[0],
                static_cast<uint32_T>(varargin_1->pseudorange.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->pseudorange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->pseudorange.data[i_0 + varargin_1->pseudorange.size] =
      varargin_2->pseudorange.data[i_0];
  }

  outputBus->pseudorange_raw.size = varargin_1->pseudorange_raw.size +
    varargin_2->pseudorange_raw.size;
  if (varargin_1->pseudorange_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange_raw.data[0],
                &varargin_1->pseudorange_raw.data[0], static_cast<uint32_T>
                (varargin_1->pseudorange_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->pseudorange_raw.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->pseudorange_raw.data[i_0 + varargin_1->pseudorange_raw.size] =
      varargin_2->pseudorange_raw.data[i_0];
  }

  outputBus->pseudorange_satclk_corrected.size =
    varargin_1->pseudorange_satclk_corrected.size +
    varargin_2->pseudorange_satclk_corrected.size;
  if (varargin_1->pseudorange_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange_satclk_corrected.data[0],
                &varargin_1->pseudorange_satclk_corrected.data[0],
                static_cast<uint32_T>
                (varargin_1->pseudorange_satclk_corrected.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->pseudorange_satclk_corrected.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->pseudorange_satclk_corrected.data[i_0 +
      varargin_1->pseudorange_satclk_corrected.size] =
      varargin_2->pseudorange_satclk_corrected.data[i_0];
  }

  outputBus->deltarange.size = varargin_1->deltarange.size +
    varargin_2->deltarange.size;
  if (varargin_1->deltarange.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange.data[0], &varargin_1->deltarange.data[0],
                static_cast<uint32_T>(varargin_1->deltarange.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->deltarange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->deltarange.data[i_0 + varargin_1->deltarange.size] =
      varargin_2->deltarange.data[i_0];
  }

  outputBus->deltarange_raw.size = varargin_1->deltarange_raw.size +
    varargin_2->deltarange_raw.size;
  if (varargin_1->deltarange_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange_raw.data[0],
                &varargin_1->deltarange_raw.data[0], static_cast<uint32_T>
                (varargin_1->deltarange_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->deltarange_raw.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->deltarange_raw.data[i_0 + varargin_1->deltarange_raw.size] =
      varargin_2->deltarange_raw.data[i_0];
  }

  outputBus->deltarange_satclk_corrected.size =
    varargin_1->deltarange_satclk_corrected.size +
    varargin_2->deltarange_satclk_corrected.size;
  if (varargin_1->deltarange_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange_satclk_corrected.data[0],
                &varargin_1->deltarange_satclk_corrected.data[0],
                static_cast<uint32_T>
                (varargin_1->deltarange_satclk_corrected.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->deltarange_satclk_corrected.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->deltarange_satclk_corrected.data[i_0 +
      varargin_1->deltarange_satclk_corrected.size] =
      varargin_2->deltarange_satclk_corrected.data[i_0];
  }

  outputBus->variance_pseudorange.size = varargin_1->variance_pseudorange.size +
    varargin_2->variance_pseudorange.size;
  if (varargin_1->variance_pseudorange.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_pseudorange.data[0],
                &varargin_1->variance_pseudorange.data[0], static_cast<uint32_T>
                (varargin_1->variance_pseudorange.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_pseudorange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_pseudorange.data[i_0 +
      varargin_1->variance_pseudorange.size] =
      varargin_2->variance_pseudorange.data[i_0];
  }

  outputBus->variance_pseudorange_measured.size =
    varargin_1->variance_pseudorange_measured.size +
    varargin_2->variance_pseudorange_measured.size;
  if (varargin_1->variance_pseudorange_measured.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_pseudorange_measured.data[0],
                &varargin_1->variance_pseudorange_measured.data[0],
                static_cast<uint32_T>
                (varargin_1->variance_pseudorange_measured.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_pseudorange_measured.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_pseudorange_measured.data[i_0 +
      varargin_1->variance_pseudorange_measured.size] =
      varargin_2->variance_pseudorange_measured.data[i_0];
  }

  outputBus->variance_deltarange.size = varargin_1->variance_deltarange.size +
    varargin_2->variance_deltarange.size;
  if (varargin_1->variance_deltarange.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_deltarange.data[0],
                &varargin_1->variance_deltarange.data[0], static_cast<uint32_T>
                (varargin_1->variance_deltarange.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_deltarange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_deltarange.data[i_0 +
      varargin_1->variance_deltarange.size] =
      varargin_2->variance_deltarange.data[i_0];
  }

  outputBus->carrierphase.size = varargin_1->carrierphase.size +
    varargin_2->carrierphase.size;
  if (varargin_1->carrierphase.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase.data[0], &varargin_1->
                carrierphase.data[0], static_cast<uint32_T>
                (varargin_1->carrierphase.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->carrierphase.data[i_0 + varargin_1->carrierphase.size] =
      varargin_2->carrierphase.data[i_0];
  }

  outputBus->carrierphase_raw.size = varargin_1->carrierphase_raw.size +
    varargin_2->carrierphase_raw.size;
  if (varargin_1->carrierphase_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase_raw.data[0],
                &varargin_1->carrierphase_raw.data[0], static_cast<uint32_T>
                (varargin_1->carrierphase_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase_raw.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->carrierphase_raw.data[i_0 + varargin_1->carrierphase_raw.size] =
      varargin_2->carrierphase_raw.data[i_0];
  }

  outputBus->carrierphase_satclk_corrected.size =
    varargin_1->carrierphase_satclk_corrected.size +
    varargin_2->carrierphase_satclk_corrected.size;
  if (varargin_1->carrierphase_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase_satclk_corrected.data[0],
                &varargin_1->carrierphase_satclk_corrected.data[0], static_cast<
                uint32_T>(varargin_1->carrierphase_satclk_corrected.size) *
                sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase_satclk_corrected.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->carrierphase_satclk_corrected.data[i_0 +
      varargin_1->carrierphase_satclk_corrected.size] =
      varargin_2->carrierphase_satclk_corrected.data[i_0];
  }

  outputBus->variance_carrierphase_measured.size =
    varargin_1->variance_carrierphase_measured.size +
    varargin_2->variance_carrierphase_measured.size;
  if (varargin_1->variance_carrierphase_measured.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_carrierphase_measured.data[0],
                &varargin_1->variance_carrierphase_measured.data[0],
                static_cast<uint32_T>
                (varargin_1->variance_carrierphase_measured.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->variance_carrierphase_measured.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_carrierphase_measured.data[i_0 +
      varargin_1->variance_carrierphase_measured.size] =
      varargin_2->variance_carrierphase_measured.data[i_0];
  }

  outputBus->locktime.size = varargin_1->locktime.size +
    varargin_2->locktime.size;
  if (varargin_1->locktime.size - 1 >= 0) {
    std::memcpy(&outputBus->locktime.data[0], &varargin_1->locktime.data[0],
                static_cast<uint32_T>(varargin_1->locktime.size) * sizeof
                (real32_T));
  }

  loop_ub = varargin_2->locktime.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->locktime.data[i_0 + varargin_1->locktime.size] =
      varargin_2->locktime.data[i_0];
  }

  outputBus->CN0.size = varargin_1->CN0.size + varargin_2->CN0.size;
  if (varargin_1->CN0.size - 1 >= 0) {
    std::memcpy(&outputBus->CN0.data[0], &varargin_1->CN0.data[0],
                static_cast<uint32_T>(varargin_1->CN0.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->CN0.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->CN0.data[i_0 + varargin_1->CN0.size] = varargin_2->CN0.data[i_0];
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_isMember(const uint16_T a_data[], const int32_T *a_size,
  boolean_T tf_data[], int32_T *tf_size)
{
  int32_T loop_ub;
  *tf_size = static_cast<int8_T>(*a_size);
  if (static_cast<int8_T>(*a_size) - 1 >= 0) {
    std::memset(&tf_data[0], 0, static_cast<uint32_T>(static_cast<int8_T>
      (*a_size)) * sizeof(boolean_T));
  }

  loop_ub = *a_size;
  for (int32_T k{0}; k < loop_ub; k++) {
    int32_T ihi;
    int32_T ilo;
    int32_T n;
    uint16_T x;
    boolean_T exitg1;
    x = a_data[k];
    n = 0;
    ilo = 1;
    ihi = 33;
    exitg1 = false;
    while ((!exitg1) && (ihi >= ilo)) {
      int32_T imid;
      imid = (ilo >> 1) + (ihi >> 1);
      if (((ilo & 1) == 1) && ((ihi & 1) == 1)) {
        imid++;
      }

      if (imid + 69 == x) {
        n = imid;
        exitg1 = true;
      } else if (x < imid + 69) {
        ihi = imid - 1;
      } else {
        ilo = imid + 1;
      }
    }

    if (n > 0) {
      while ((n - 1 > 0) && (n + 68 == x)) {
        n--;
      }
    }

    if (n > 0) {
      tf_data[k] = true;
    }
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
boolean_T DDRTCM::DDRTCM_any_g(const boolean_T x_data[], const int32_T *x_size)
{
  int32_T ix;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  ix = 1;
  exitg1 = false;
  while ((!exitg1) && (ix <= *x_size)) {
    if (x_data[ix - 1]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_isMember_c(const uint16_T a_data[], const int32_T *a_size,
  boolean_T tf_data[], int32_T *tf_size)
{
  int32_T loop_ub;
  *tf_size = static_cast<int8_T>(*a_size);
  if (static_cast<int8_T>(*a_size) - 1 >= 0) {
    std::memset(&tf_data[0], 0, static_cast<uint32_T>(static_cast<int8_T>
      (*a_size)) * sizeof(boolean_T));
  }

  loop_ub = *a_size;
  for (int32_T k{0}; k < loop_ub; k++) {
    int32_T ihi;
    int32_T ilo;
    int32_T n;
    uint16_T x;
    boolean_T exitg1;
    x = a_data[k];
    n = 0;
    ilo = 1;
    ihi = 37;
    exitg1 = false;
    while ((!exitg1) && (ihi >= ilo)) {
      int32_T imid;
      imid = (ilo >> 1) + (ihi >> 1);
      if (((ilo & 1) == 1) && ((ihi & 1) == 1)) {
        imid++;
      }

      if (x == imid) {
        n = imid;
        exitg1 = true;
      } else if (x < imid) {
        ihi = imid - 1;
      } else {
        ilo = imid + 1;
      }
    }

    if (n > 0) {
      while ((n - 1 > 0) && (n - 1 == x)) {
        n--;
      }
    }

    if (n > 0) {
      tf_data[k] = true;
    }
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
real_T DDRTCM::DDRTCM_norm_n(const real_T x[3], B_MergeGNSSMeasurement_DDRTCM_T *
  localB)
{
  real_T y;
  localB->scale_d = 3.3121686421112381E-170;
  localB->absxk_g = std::abs(x[0]);
  if (localB->absxk_g > 3.3121686421112381E-170) {
    y = 1.0;
    localB->scale_d = localB->absxk_g;
  } else {
    localB->t_l = localB->absxk_g / 3.3121686421112381E-170;
    y = localB->t_l * localB->t_l;
  }

  localB->absxk_g = std::abs(x[1]);
  if (localB->absxk_g > localB->scale_d) {
    localB->t_l = localB->scale_d / localB->absxk_g;
    y = y * localB->t_l * localB->t_l + 1.0;
    localB->scale_d = localB->absxk_g;
  } else {
    localB->t_l = localB->absxk_g / localB->scale_d;
    y += localB->t_l * localB->t_l;
  }

  localB->absxk_g = std::abs(x[2]);
  if (localB->absxk_g > localB->scale_d) {
    localB->t_l = localB->scale_d / localB->absxk_g;
    y = y * localB->t_l * localB->t_l + 1.0;
    localB->scale_d = localB->absxk_g;
  } else {
    localB->t_l = localB->absxk_g / localB->scale_d;
    y += localB->t_l * localB->t_l;
  }

  return localB->scale_d * std::sqrt(y);
}

void DDRTCM::DDRTC_binary_expand_op_fcejrcme(real_T in1_data[], int32_T in2,
  const real_T in3_data[], const real_T in4_data[], const int32_T in4_size[2],
  const real_T in5[4], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  real_T in4[3];
  int32_T stride_0_0;
  stride_0_0 = (in4_size[1] != 1);
  in4[0] = in4_data[in2] - in5[0];
  in4[1] = in4_data[in4_size[0] * stride_0_0 + in2] - in5[1];
  in4[2] = in4_data[(stride_0_0 << 1) * in4_size[0] + in2] - in5[2];
  in1_data[in2] = in3_data[in2] - (DDRTCM_norm_n(in4, localB) + in5[3]);
}

void DDRTCM::DDRTCM_binary_expand_op_fcejrcm(real_T in1_data[], const int32_T
  in1_size[2], int32_T in2, const real_T in3_data[], const int32_T in3_size[2],
  const real_T in4[4], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  int32_T stride_0_0;
  stride_0_0 = (in3_size[1] != 1);
  localB->in3_tmp_j = in3_data[in2] - in4[0];
  localB->in3_l[0] = localB->in3_tmp_j;
  localB->in3_l[1] = in3_data[in3_size[0] * stride_0_0 + in2] - in4[1];
  localB->in3_l[2] = in3_data[(stride_0_0 << 1) * in3_size[0] + in2] - in4[2];
  localB->d1 = DDRTCM_norm_n(localB->in3_l, localB);
  stride_0_0 = (in3_size[1] != 1);
  in1_data[in2] = -localB->in3_tmp_j / localB->d1;
  in1_data[in2 + in1_size[0]] = -(in3_data[in3_size[0] * stride_0_0 + in2] -
    in4[1]) / localB->d1;
  in1_data[in2 + (in1_size[0] << 1)] = -(in3_data[(stride_0_0 << 1) * in3_size[0]
    + in2] - in4[2]) / localB->d1;
  in1_data[in2 + in1_size[0] * 3] = 1.0;
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_getJacobi(const real_T satellite_position_data[], const
  int32_T satellite_position_size[2], const real_T pseudorange_data[], const
  int32_T *pseudorange_size, const real_T user_state[4], real_T delta_rho_data[],
  int32_T *delta_rho_size, real_T H_data[], int32_T H_size[2], real_T residuum[4],
  B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  int32_T c;
  int32_T loop_ub;
  *delta_rho_size = *pseudorange_size;
  if (*pseudorange_size - 1 >= 0) {
    std::memset(&delta_rho_data[0], 0, static_cast<uint32_T>(*pseudorange_size) *
                sizeof(real_T));
  }

  H_size[0] = *pseudorange_size;
  H_size[1] = 4;
  loop_ub = *pseudorange_size << 2;
  if (loop_ub - 1 >= 0) {
    std::memset(&H_data[0], 0, static_cast<uint32_T>(loop_ub) * sizeof(real_T));
  }

  loop_ub = *pseudorange_size;
  for (int32_T H{0}; H < loop_ub; H++) {
    if (satellite_position_size[1] == 3) {
      for (c = 0; c < 3; c++) {
        localB->satellite_position_tmp =
          satellite_position_data[satellite_position_size[0] * c + H] -
          user_state[c];
        localB->satellite_position[c] = localB->satellite_position_tmp;
        localB->satellite_position_p[c] = localB->satellite_position_tmp;
      }

      delta_rho_data[H] = pseudorange_data[H] - (DDRTCM_norm_n
        (localB->satellite_position, localB) + user_state[3]);
      localB->satellite_position_tmp = DDRTCM_norm_n
        (localB->satellite_position_p, localB);
      for (c = 0; c < 3; c++) {
        H_data[H + H_size[0] * c] =
          -(satellite_position_data[satellite_position_size[0] * c + H] -
            user_state[c]) / localB->satellite_position_tmp;
      }

      H_data[H + H_size[0] * 3] = 1.0;
    } else {
      DDRTC_binary_expand_op_fcejrcme(delta_rho_data, H, pseudorange_data,
        satellite_position_data, satellite_position_size, user_state, localB);
      DDRTCM_binary_expand_op_fcejrcm(H_data, H_size, H, satellite_position_data,
        satellite_position_size, user_state, localB);
    }
  }

  residuum[0] = 0.0;
  residuum[1] = 0.0;
  residuum[2] = 0.0;
  residuum[3] = 0.0;
  c = H_size[0];
  for (loop_ub = 0; loop_ub < c; loop_ub++) {
    localB->satellite_position_tmp = delta_rho_data[loop_ub];
    residuum[0] += H_data[loop_ub] * localB->satellite_position_tmp;
    residuum[1] += H_data[H_size[0] + loop_ub] * localB->satellite_position_tmp;
    residuum[2] += H_data[(H_size[0] << 1) + loop_ub] *
      localB->satellite_position_tmp;
    residuum[3] += H_data[3 * H_size[0] + loop_ub] *
      localB->satellite_position_tmp;
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
real_T DDRTCM::DDRTCM_xnrm2_hl(int32_T n, const real_T x_data[], int32_T ix0,
  B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  real_T y;
  y = 0.0;
  if (n >= 1) {
    if (n == 1) {
      y = std::abs(x_data[ix0 - 1]);
    } else {
      localB->scale_l = 3.3121686421112381E-170;
      localB->kend = (ix0 + n) - 1;
      for (localB->k = ix0; localB->k <= localB->kend; localB->k++) {
        localB->absxk_o = std::abs(x_data[localB->k - 1]);
        if (localB->absxk_o > localB->scale_l) {
          localB->t_b = localB->scale_l / localB->absxk_o;
          y = y * localB->t_b * localB->t_b + 1.0;
          localB->scale_l = localB->absxk_o;
        } else {
          localB->t_b = localB->absxk_o / localB->scale_l;
          y += localB->t_b * localB->t_b;
        }
      }

      y = localB->scale_l * std::sqrt(y);
    }
  }

  return y;
}

real_T DDRTCM::DDRTCM_rt_hypotd_snf(real_T u0, real_T u1,
  B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  real_T y;
  localB->a = std::abs(u0);
  localB->b = std::abs(u1);
  if (localB->a < localB->b) {
    localB->a /= localB->b;
    y = std::sqrt(localB->a * localB->a + 1.0) * localB->b;
  } else if (localB->a > localB->b) {
    localB->b /= localB->a;
    y = std::sqrt(localB->b * localB->b + 1.0) * localB->a;
  } else if (std::isnan(localB->b)) {
    y = (rtNaN);
  } else {
    y = localB->a * 1.4142135623730951;
  }

  return y;
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_qrsolve_e(const real_T A_data[], const int32_T A_size[2],
  const real_T B_data[], const int32_T *B_size, real_T Y[4],
  B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  __m128d tmp_0;
  localB->rankA = A_size[0];
  localB->b_A_size[0] = A_size[0];
  localB->minmana = A_size[0] << 2;
  if (localB->minmana - 1 >= 0) {
    std::memcpy(&localB->b_A_data_c[0], &A_data[0], static_cast<uint32_T>
                (localB->minmana) * sizeof(real_T));
  }

  if (A_size[0] <= 4) {
    localB->minmana = A_size[0];
  } else {
    localB->minmana = 4;
  }

  if (localB->minmana - 1 >= 0) {
    std::memset(&localB->tau_data_f[0], 0, static_cast<uint32_T>(localB->minmana)
                * sizeof(real_T));
  }

  if (A_size[0] == 0) {
    localB->jpvt_j[0] = 1;
    localB->jpvt_j[1] = 2;
    localB->jpvt_j[2] = 3;
    localB->jpvt_j[3] = 4;
  } else {
    localB->minmana = A_size[0];
    localB->jpvt_j[0] = 1;
    localB->work_g[0] = 0.0;
    localB->smax_d = DDRTCM_xnrm2_hl(A_size[0], A_data, 1, localB);
    localB->vn2_m[0] = localB->smax_d;
    localB->vn1_g[0] = localB->smax_d;
    localB->jpvt_j[1] = 2;
    localB->work_g[1] = 0.0;
    localB->smax_d = DDRTCM_xnrm2_hl(A_size[0], A_data, A_size[0] + 1, localB);
    localB->vn2_m[1] = localB->smax_d;
    localB->vn1_g[1] = localB->smax_d;
    localB->jpvt_j[2] = 3;
    localB->work_g[2] = 0.0;
    localB->smax_d = DDRTCM_xnrm2_hl(A_size[0], A_data, (A_size[0] << 1) + 1,
      localB);
    localB->vn2_m[2] = localB->smax_d;
    localB->vn1_g[2] = localB->smax_d;
    localB->jpvt_j[3] = 4;
    localB->work_g[3] = 0.0;
    localB->smax_d = DDRTCM_xnrm2_hl(A_size[0], A_data, 3 * A_size[0] + 1,
      localB);
    localB->vn2_m[3] = localB->smax_d;
    localB->vn1_g[3] = localB->smax_d;
    if (A_size[0] <= 4) {
      localB->maxmn = A_size[0];
    } else {
      localB->maxmn = 4;
    }

    for (localB->e_i = 0; localB->e_i < localB->maxmn; localB->e_i++) {
      localB->jA_m = localB->e_i * localB->minmana;
      localB->ii = localB->jA_m + localB->e_i;
      localB->mmi = localB->rankA - localB->e_i;
      localB->itemp = 4 - localB->e_i;
      localB->pvt = 0;
      if (4 - localB->e_i > 1) {
        localB->smax_d = std::abs(localB->vn1_g[localB->e_i]);
        for (localB->b_ix = 2; localB->b_ix <= localB->itemp; localB->b_ix++) {
          localB->s_d = std::abs(localB->vn1_g[(localB->e_i + localB->b_ix) - 1]);
          if (localB->s_d > localB->smax_d) {
            localB->pvt = localB->b_ix - 1;
            localB->smax_d = localB->s_d;
          }
        }
      }

      localB->pvt += localB->e_i;
      if (localB->pvt != localB->e_i) {
        localB->b_ix = localB->pvt * localB->minmana;
        for (localB->c_k = 0; localB->c_k < localB->rankA; localB->c_k++) {
          localB->temp_tmp = localB->b_ix + localB->c_k;
          localB->smax_d = localB->b_A_data_c[localB->temp_tmp];
          localB->itemp = localB->jA_m + localB->c_k;
          localB->b_A_data_c[localB->temp_tmp] = localB->b_A_data_c
            [localB->itemp];
          localB->b_A_data_c[localB->itemp] = localB->smax_d;
        }

        localB->itemp = localB->jpvt_j[localB->pvt];
        localB->jpvt_j[localB->pvt] = localB->jpvt_j[localB->e_i];
        localB->jpvt_j[localB->e_i] = static_cast<int8_T>(localB->itemp);
        localB->vn1_g[localB->pvt] = localB->vn1_g[localB->e_i];
        localB->vn2_m[localB->pvt] = localB->vn2_m[localB->e_i];
      }

      if (localB->e_i + 1 < localB->rankA) {
        localB->s_d = localB->b_A_data_c[localB->ii];
        localB->pvt = localB->ii + 2;
        localB->tau_data_f[localB->e_i] = 0.0;
        if (localB->mmi > 0) {
          localB->smax_d = DDRTCM_xnrm2_hl(localB->mmi - 1, localB->b_A_data_c,
            localB->ii + 2, localB);
          if (localB->smax_d != 0.0) {
            localB->smax_d = DDRTCM_rt_hypotd_snf(localB->b_A_data_c[localB->ii],
              localB->smax_d, localB);
            if (localB->b_A_data_c[localB->ii] >= 0.0) {
              localB->smax_d = -localB->smax_d;
            }

            if (std::abs(localB->smax_d) < 1.0020841800044864E-292) {
              localB->b_ix = 0;
              localB->c_k = localB->ii + localB->mmi;
              do {
                localB->b_ix++;
                localB->itemp = (((((localB->c_k - localB->ii) - 1) / 2) << 1) +
                                 localB->ii) + 2;
                localB->jA_m = localB->itemp - 2;
                for (localB->temp_tmp = localB->pvt; localB->temp_tmp <=
                     localB->jA_m; localB->temp_tmp += 2) {
                  tmp_0 = _mm_loadu_pd(&localB->b_A_data_c[localB->temp_tmp - 1]);
                  _mm_storeu_pd(&localB->b_A_data_c[localB->temp_tmp - 1],
                                _mm_mul_pd(tmp_0, _mm_set1_pd
                    (9.9792015476736E+291)));
                }

                for (localB->temp_tmp = localB->itemp; localB->temp_tmp <=
                     localB->c_k; localB->temp_tmp++) {
                  localB->b_A_data_c[localB->temp_tmp - 1] *=
                    9.9792015476736E+291;
                }

                localB->smax_d *= 9.9792015476736E+291;
                localB->s_d *= 9.9792015476736E+291;
              } while ((std::abs(localB->smax_d) < 1.0020841800044864E-292) &&
                       (localB->b_ix < 20));

              localB->smax_d = DDRTCM_rt_hypotd_snf(localB->s_d, DDRTCM_xnrm2_hl
                (localB->mmi - 1, localB->b_A_data_c, localB->ii + 2, localB),
                localB);
              if (localB->s_d >= 0.0) {
                localB->smax_d = -localB->smax_d;
              }

              localB->tau_data_f[localB->e_i] = (localB->smax_d - localB->s_d) /
                localB->smax_d;
              localB->s_d = 1.0 / (localB->s_d - localB->smax_d);
              localB->itemp = (((((localB->c_k - localB->ii) - 1) / 2) << 1) +
                               localB->ii) + 2;
              localB->jA_m = localB->itemp - 2;
              for (localB->temp_tmp = localB->pvt; localB->temp_tmp <=
                   localB->jA_m; localB->temp_tmp += 2) {
                tmp_0 = _mm_loadu_pd(&localB->b_A_data_c[localB->temp_tmp - 1]);
                _mm_storeu_pd(&localB->b_A_data_c[localB->temp_tmp - 1],
                              _mm_mul_pd(tmp_0, _mm_set1_pd(localB->s_d)));
              }

              for (localB->temp_tmp = localB->itemp; localB->temp_tmp <=
                   localB->c_k; localB->temp_tmp++) {
                localB->b_A_data_c[localB->temp_tmp - 1] *= localB->s_d;
              }

              for (localB->itemp = 0; localB->itemp < localB->b_ix;
                   localB->itemp++) {
                localB->smax_d *= 1.0020841800044864E-292;
              }

              localB->s_d = localB->smax_d;
            } else {
              localB->tau_data_f[localB->e_i] = (localB->smax_d -
                localB->b_A_data_c[localB->ii]) / localB->smax_d;
              localB->s_d = 1.0 / (localB->b_A_data_c[localB->ii] -
                                   localB->smax_d);
              localB->b_ix = localB->ii + localB->mmi;
              localB->itemp = (((((localB->b_ix - localB->ii) - 1) / 2) << 1) +
                               localB->ii) + 2;
              localB->jA_m = localB->itemp - 2;
              for (localB->c_k = localB->pvt; localB->c_k <= localB->jA_m;
                   localB->c_k += 2) {
                tmp_0 = _mm_loadu_pd(&localB->b_A_data_c[localB->c_k - 1]);
                _mm_storeu_pd(&localB->b_A_data_c[localB->c_k - 1], _mm_mul_pd
                              (tmp_0, _mm_set1_pd(localB->s_d)));
              }

              for (localB->c_k = localB->itemp; localB->c_k <= localB->b_ix;
                   localB->c_k++) {
                localB->b_A_data_c[localB->c_k - 1] *= localB->s_d;
              }

              localB->s_d = localB->smax_d;
            }
          }
        }

        localB->b_A_data_c[localB->ii] = localB->s_d;
      } else {
        localB->tau_data_f[localB->e_i] = 0.0;
      }

      if (localB->e_i + 1 < 4) {
        localB->smax_d = localB->b_A_data_c[localB->ii];
        localB->b_A_data_c[localB->ii] = 1.0;
        localB->jA_m = (localB->ii + localB->minmana) + 1;
        if (localB->tau_data_f[localB->e_i] != 0.0) {
          boolean_T exitg2;
          localB->itemp = localB->mmi - 1;
          localB->pvt = (localB->ii + localB->mmi) - 1;
          while ((localB->itemp + 1 > 0) && (localB->b_A_data_c[localB->pvt] ==
                  0.0)) {
            localB->itemp--;
            localB->pvt--;
          }

          localB->pvt = 3 - localB->e_i;
          exitg2 = false;
          while ((!exitg2) && (localB->pvt > 0)) {
            int32_T exitg1;
            localB->b_ix = (localB->pvt - 1) * localB->minmana + localB->jA_m;
            localB->c_k = localB->b_ix;
            do {
              exitg1 = 0;
              if (localB->c_k <= localB->b_ix + localB->itemp) {
                if (localB->b_A_data_c[localB->c_k - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  localB->c_k++;
                }
              } else {
                localB->pvt--;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }

          localB->pvt--;
        } else {
          localB->itemp = -1;
          localB->pvt = -1;
        }

        if (localB->itemp + 1 > 0) {
          if (localB->pvt + 1 != 0) {
            std::memset(&localB->work_g[0], 0, static_cast<uint32_T>(localB->pvt
              + 1) * sizeof(real_T));
            localB->b_ix = 0;
            localB->c_k = localB->minmana * localB->pvt + localB->jA_m;
            for (localB->temp_tmp = localB->jA_m; localB->minmana < 0 ?
                 localB->temp_tmp >= localB->c_k : localB->temp_tmp <=
                 localB->c_k; localB->temp_tmp += localB->minmana) {
              localB->s_d = 0.0;
              localB->p = localB->temp_tmp + localB->itemp;
              for (localB->ia = localB->temp_tmp; localB->ia <= localB->p;
                   localB->ia++) {
                localB->s_d += localB->b_A_data_c[(localB->ii + localB->ia) -
                  localB->temp_tmp] * localB->b_A_data_c[localB->ia - 1];
              }

              localB->work_g[localB->b_ix] += localB->s_d;
              localB->b_ix++;
            }
          }

          if (!(-localB->tau_data_f[localB->e_i] == 0.0)) {
            for (localB->b_ix = 0; localB->b_ix <= localB->pvt; localB->b_ix++)
            {
              localB->s_d = localB->work_g[localB->b_ix];
              if (localB->s_d != 0.0) {
                localB->s_d *= -localB->tau_data_f[localB->e_i];
                localB->c_k = localB->itemp + localB->jA_m;
                for (localB->temp_tmp = localB->jA_m; localB->temp_tmp <=
                     localB->c_k; localB->temp_tmp++) {
                  localB->b_A_data_c[localB->temp_tmp - 1] += localB->
                    b_A_data_c[(localB->ii + localB->temp_tmp) - localB->jA_m] *
                    localB->s_d;
                }
              }

              localB->jA_m += localB->minmana;
            }
          }
        }

        localB->b_A_data_c[localB->ii] = localB->smax_d;
      }

      for (localB->ii = localB->e_i + 2; localB->ii < 5; localB->ii++) {
        localB->itemp = (localB->ii - 1) * localB->minmana + localB->e_i;
        localB->smax_d = localB->vn1_g[localB->ii - 1];
        if (localB->smax_d != 0.0) {
          localB->s_d = std::abs(localB->b_A_data_c[localB->itemp]) /
            localB->smax_d;
          localB->s_d = 1.0 - localB->s_d * localB->s_d;
          if (localB->s_d < 0.0) {
            localB->s_d = 0.0;
          }

          localB->temp2 = localB->smax_d / localB->vn2_m[localB->ii - 1];
          localB->temp2 = localB->temp2 * localB->temp2 * localB->s_d;
          if (localB->temp2 <= 1.4901161193847656E-8) {
            if (localB->e_i + 1 < localB->rankA) {
              localB->vn1_g[localB->ii - 1] = DDRTCM_xnrm2_hl(localB->mmi - 1,
                localB->b_A_data_c, localB->itemp + 2, localB);
              localB->vn2_m[localB->ii - 1] = localB->vn1_g[localB->ii - 1];
            } else {
              localB->vn1_g[localB->ii - 1] = 0.0;
              localB->vn2_m[localB->ii - 1] = 0.0;
            }
          } else {
            localB->vn1_g[localB->ii - 1] = localB->smax_d * std::sqrt
              (localB->s_d);
          }
        }
      }
    }
  }

  localB->rankA = 0;
  if (A_size[0] < 4) {
    localB->minmana = A_size[0];
    localB->maxmn = 4;
  } else {
    localB->minmana = 4;
    localB->maxmn = A_size[0];
  }

  if (localB->minmana > 0) {
    while ((localB->rankA < localB->minmana) && (!(std::abs(localB->
              b_A_data_c[localB->b_A_size[0] * localB->rankA + localB->rankA]) <=
             2.2204460492503131E-15 * static_cast<real_T>(localB->maxmn) * std::
             abs(localB->b_A_data_c[0])))) {
      localB->rankA++;
    }
  }

  localB->minmana = *B_size;
  if (localB->minmana - 1 >= 0) {
    std::memcpy(&localB->b_B_data_k[0], &B_data[0], static_cast<uint32_T>
                (localB->minmana) * sizeof(real_T));
  }

  Y[0] = 0.0;
  Y[1] = 0.0;
  Y[2] = 0.0;
  Y[3] = 0.0;
  localB->minmana = A_size[0];
  if (A_size[0] <= 4) {
    localB->maxmn = A_size[0];
  } else {
    localB->maxmn = 4;
  }

  for (localB->e_i = 0; localB->e_i < localB->maxmn; localB->e_i++) {
    localB->smax_d = localB->tau_data_f[localB->e_i];
    if (localB->smax_d != 0.0) {
      localB->s_d = localB->b_B_data_k[localB->e_i];
      for (localB->mmi = localB->e_i + 2; localB->mmi <= localB->minmana;
           localB->mmi++) {
        localB->s_d += localB->b_A_data_c[(localB->b_A_size[0] * localB->e_i +
          localB->mmi) - 1] * localB->b_B_data_k[localB->mmi - 1];
      }

      localB->s_d *= localB->smax_d;
      if (localB->s_d != 0.0) {
        localB->b_B_data_k[localB->e_i] -= localB->s_d;
        localB->itemp = (((((localB->minmana - localB->e_i) - 1) / 2) << 1) +
                         localB->e_i) + 2;
        localB->jA_m = localB->itemp - 2;
        for (localB->mmi = localB->e_i + 2; localB->mmi <= localB->jA_m;
             localB->mmi += 2) {
          __m128d tmp;
          tmp_0 = _mm_loadu_pd(&localB->b_A_data_c[(localB->b_A_size[0] *
            localB->e_i + localB->mmi) - 1]);
          tmp = _mm_loadu_pd(&localB->b_B_data_k[localB->mmi - 1]);
          _mm_storeu_pd(&localB->b_B_data_k[localB->mmi - 1], _mm_sub_pd(tmp,
            _mm_mul_pd(tmp_0, _mm_set1_pd(localB->s_d))));
        }

        for (localB->mmi = localB->itemp; localB->mmi <= localB->minmana;
             localB->mmi++) {
          localB->b_B_data_k[localB->mmi - 1] -= localB->b_A_data_c
            [(localB->b_A_size[0] * localB->e_i + localB->mmi) - 1] *
            localB->s_d;
        }
      }
    }
  }

  for (localB->minmana = 0; localB->minmana < localB->rankA; localB->minmana++)
  {
    Y[localB->jpvt_j[localB->minmana] - 1] = localB->b_B_data_k[localB->minmana];
  }

  for (localB->minmana = localB->rankA; localB->minmana >= 1; localB->minmana--)
  {
    localB->maxmn = localB->jpvt_j[localB->minmana - 1] - 1;
    localB->ii = (localB->minmana - 1) * localB->b_A_size[0];
    Y[localB->maxmn] /= localB->b_A_data_c[(localB->minmana + localB->ii) - 1];
    for (localB->e_i = 0; localB->e_i <= localB->minmana - 2; localB->e_i++) {
      localB->mmi = localB->jpvt_j[localB->e_i] - 1;
      Y[localB->mmi] -= localB->b_A_data_c[localB->e_i + localB->ii] * Y
        [localB->maxmn];
    }
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_mldivide_ldko(const real_T A_data[], const int32_T A_size[2],
  real_T B_data[], int32_T *B_size, B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  if (A_size[0] == 0) {
    *B_size = 4;
    B_data[0] = 0.0;
    B_data[1] = 0.0;
    B_data[2] = 0.0;
    B_data[3] = 0.0;
  } else if (*B_size == 0) {
    *B_size = 4;
    B_data[0] = 0.0;
    B_data[1] = 0.0;
    B_data[2] = 0.0;
    B_data[3] = 0.0;
  } else if (A_size[0] == 4) {
    std::memcpy(&localB->b_A_data_b[0], &A_data[0], sizeof(real_T) << 4U);
    localB->ipiv_j[0] = 1;
    localB->ipiv_j[1] = 2;
    localB->ipiv_j[2] = 3;
    localB->ipiv_j[3] = 4;
    for (localB->j = 0; localB->j < 3; localB->j++) {
      localB->ipiv_l = localB->ipiv_j[localB->j];
      localB->jj = localB->j * 5;
      localB->n = 4 - localB->j;
      localB->jA = 0;
      localB->smax = std::abs(localB->b_A_data_b[localB->jj]);
      for (localB->kAcol = 2; localB->kAcol <= localB->n; localB->kAcol++) {
        localB->s = std::abs(localB->b_A_data_b[(localB->jj + localB->kAcol) - 1]);
        if (localB->s > localB->smax) {
          localB->jA = localB->kAcol - 1;
          localB->smax = localB->s;
        }
      }

      if (localB->b_A_data_b[localB->jj + localB->jA] != 0.0) {
        if (localB->jA != 0) {
          localB->kAcol = localB->j + localB->jA;
          localB->ipiv_l = static_cast<int8_T>(localB->kAcol + 1);
          localB->smax = localB->b_A_data_b[localB->j];
          localB->b_A_data_b[localB->j] = localB->b_A_data_b[localB->kAcol];
          localB->b_A_data_b[localB->kAcol] = localB->smax;
          localB->smax = localB->b_A_data_b[localB->j + 4];
          localB->b_A_data_b[localB->j + 4] = localB->b_A_data_b[localB->kAcol +
            4];
          localB->b_A_data_b[localB->kAcol + 4] = localB->smax;
          localB->smax = localB->b_A_data_b[localB->j + 8];
          localB->b_A_data_b[localB->j + 8] = localB->b_A_data_b[localB->kAcol +
            8];
          localB->b_A_data_b[localB->kAcol + 8] = localB->smax;
          localB->smax = localB->b_A_data_b[localB->j + 12];
          localB->b_A_data_b[localB->j + 12] = localB->b_A_data_b[localB->kAcol
            + 12];
          localB->b_A_data_b[localB->kAcol + 12] = localB->smax;
        }

        localB->n = (localB->jj - localB->j) + 4;
        localB->jA = (((((localB->n - localB->jj) - 1) / 2) << 1) + localB->jj)
          + 2;
        localB->vectorUB = localB->jA - 2;
        for (localB->kAcol = localB->jj + 2; localB->kAcol <= localB->vectorUB;
             localB->kAcol += 2) {
          __m128d tmp;
          tmp = _mm_loadu_pd(&localB->b_A_data_b[localB->kAcol - 1]);
          _mm_storeu_pd(&localB->b_A_data_b[localB->kAcol - 1], _mm_div_pd(tmp,
            _mm_set1_pd(localB->b_A_data_b[localB->jj])));
        }

        for (localB->kAcol = localB->jA; localB->kAcol <= localB->n;
             localB->kAcol++) {
          localB->b_A_data_b[localB->kAcol - 1] /= localB->b_A_data_b[localB->jj];
        }
      }

      localB->jA = localB->jj + 6;
      localB->vectorUB = 2 - localB->j;
      for (localB->kAcol = 0; localB->kAcol <= localB->vectorUB; localB->kAcol++)
      {
        localB->smax = localB->b_A_data_b[((localB->kAcol << 2) + localB->jj) +
          4];
        if (localB->smax != 0.0) {
          localB->e = (localB->jA - localB->j) + 2;
          for (localB->n = localB->jA; localB->n <= localB->e; localB->n++) {
            localB->b_A_data_b[localB->n - 1] += localB->b_A_data_b[((localB->jj
              + localB->n) - localB->jA) + 1] * -localB->smax;
          }
        }

        localB->jA += 4;
      }

      if (localB->j + 1 != localB->ipiv_l) {
        localB->smax = B_data[localB->j];
        B_data[localB->j] = B_data[localB->ipiv_l - 1];
        B_data[localB->ipiv_l - 1] = localB->smax;
      }

      localB->ipiv_j[localB->j] = localB->ipiv_l;
    }

    for (localB->j = 0; localB->j < 4; localB->j++) {
      localB->kAcol = localB->j << 2;
      if (B_data[localB->j] != 0.0) {
        for (localB->jj = localB->j + 2; localB->jj < 5; localB->jj++) {
          B_data[localB->jj - 1] -= localB->b_A_data_b[(localB->jj +
            localB->kAcol) - 1] * B_data[localB->j];
        }
      }
    }

    for (localB->j = 3; localB->j >= 0; localB->j--) {
      localB->kAcol = localB->j << 2;
      if (B_data[localB->j] != 0.0) {
        B_data[localB->j] /= localB->b_A_data_b[localB->j + localB->kAcol];
        for (localB->jj = 0; localB->jj < localB->j; localB->jj++) {
          B_data[localB->jj] -= localB->b_A_data_b[localB->jj + localB->kAcol] *
            B_data[localB->j];
        }
      }
    }
  } else {
    DDRTCM_qrsolve_e(A_data, A_size, B_data, B_size, localB->dv2, localB);
    *B_size = 4;
    B_data[0] = localB->dv2[0];
    B_data[1] = localB->dv2[1];
    B_data[2] = localB->dv2[2];
    B_data[3] = localB->dv2[3];
  }
}

void DDRTCM::DDRTCM_plus_lh(real_T in1[4], const real_T in2_data[], const
  int32_T *in2_size)
{
  int32_T stride_0_0;
  stride_0_0 = (*in2_size != 1);
  in1[0] += in2_data[0];
  in1[1] += in2_data[stride_0_0];
  in1[2] += in2_data[stride_0_0 << 1];
  in1[3] += in2_data[3 * stride_0_0];
}

void DDRTCM::DDRTCM_binary_expand_op_fcej(real_T in1_data[], int32_T in2, const
  real_T in3_data[], const real_T in4_data[], const int32_T in4_size[2], const
  real_T in5[5], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  real_T in4[3];
  int32_T stride_0_0;
  stride_0_0 = (in4_size[1] != 1);
  in4[0] = in4_data[in2] - in5[0];
  in4[1] = in4_data[in4_size[0] * stride_0_0 + in2] - in5[1];
  in4[2] = in4_data[(stride_0_0 << 1) * in4_size[0] + in2] - in5[2];
  in1_data[in2] = in3_data[in2] - (DDRTCM_norm_n(in4, localB) + in5[3]);
}

void DDRTCM::DDRTCM_binary_expand_op_fce(real_T in1_data[], const int32_T
  in1_size[2], int32_T in2, const real_T in3_data[], const int32_T in3_size[2],
  const real_T in4[5], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  int32_T stride_0_0;
  stride_0_0 = (in3_size[1] != 1);
  localB->in3_tmp_f = in3_data[in2] - in4[0];
  localB->in3_j[0] = localB->in3_tmp_f;
  localB->in3_j[1] = in3_data[in3_size[0] * stride_0_0 + in2] - in4[1];
  localB->in3_j[2] = in3_data[(stride_0_0 << 1) * in3_size[0] + in2] - in4[2];
  localB->d2 = DDRTCM_norm_n(localB->in3_j, localB);
  stride_0_0 = (in3_size[1] != 1);
  in1_data[in2] = -localB->in3_tmp_f / localB->d2;
  in1_data[in2 + in1_size[0]] = -(in3_data[in3_size[0] * stride_0_0 + in2] -
    in4[1]) / localB->d2;
  in1_data[in2 + (in1_size[0] << 1)] = -(in3_data[(stride_0_0 << 1) * in3_size[0]
    + in2] - in4[2]) / localB->d2;
  in1_data[in2 + in1_size[0] * 3] = 1.0;
  in1_data[in2 + (in1_size[0] << 2)] = 0.0;
}

void DDRTCM::DDRTCM_binary_expand_op_fcejrc(real_T in1_data[], int32_T in2,
  const real_T in3_data[], const real_T in4_data[], const int32_T in4_size[2],
  const real_T in5[5], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  real_T in4[3];
  int32_T stride_0_0;
  stride_0_0 = (in4_size[1] != 1);
  in4[0] = in4_data[in2] - in5[0];
  in4[1] = in4_data[in4_size[0] * stride_0_0 + in2] - in5[1];
  in4[2] = in4_data[(stride_0_0 << 1) * in4_size[0] + in2] - in5[2];
  in1_data[in2] = in3_data[in2] - (DDRTCM_norm_n(in4, localB) + in5[4]);
}

void DDRTCM::DDRTCM_binary_expand_op_fcejr(real_T in1_data[], const int32_T
  in1_size[2], int32_T in2, const real_T in3_data[], const int32_T in3_size[2],
  const real_T in4[5], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  int32_T stride_0_0;
  stride_0_0 = (in3_size[1] != 1);
  localB->in3_tmp = in3_data[in2] - in4[0];
  localB->in3[0] = localB->in3_tmp;
  localB->in3[1] = in3_data[in3_size[0] * stride_0_0 + in2] - in4[1];
  localB->in3[2] = in3_data[(stride_0_0 << 1) * in3_size[0] + in2] - in4[2];
  localB->d = DDRTCM_norm_n(localB->in3, localB);
  stride_0_0 = (in3_size[1] != 1);
  in1_data[in2] = -localB->in3_tmp / localB->d;
  in1_data[in2 + in1_size[0]] = -(in3_data[in3_size[0] * stride_0_0 + in2] -
    in4[1]) / localB->d;
  in1_data[in2 + (in1_size[0] << 1)] = -(in3_data[(stride_0_0 << 1) * in3_size[0]
    + in2] - in4[2]) / localB->d;
  in1_data[in2 + in1_size[0] * 3] = 0.0;
  in1_data[in2 + (in1_size[0] << 2)] = 1.0;
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_getJacobiMultiKonst(const real_T
  satellite_position_sys1_data[], const int32_T satellite_position_sys1_size[2],
  const real_T satellite_position_sys2_data[], const int32_T
  satellite_position_sys2_size[2], const real_T pseudorange_sys1_data[], const
  int32_T *pseudorange_sys1_size, const real_T pseudorange_sys2_data[], const
  int32_T *pseudorange_sys2_size, const real_T user_state[5], real_T
  delta_rho_data[], int32_T *delta_rho_size, real_T H_data[], int32_T H_size[2],
  real_T residuum[5], B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  localB->loop_ub_c = *pseudorange_sys1_size;
  if (localB->loop_ub_c - 1 >= 0) {
    std::memset(&localB->delta_rho_sys1_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub_c) * sizeof(real_T));
  }

  localB->loop_ub_c = *pseudorange_sys2_size;
  if (localB->loop_ub_c - 1 >= 0) {
    std::memset(&localB->delta_rho_sys2_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub_c) * sizeof(real_T));
  }

  localB->H_sys1_size[0] = *pseudorange_sys1_size;
  localB->H_sys1_size[1] = 5;
  localB->loop_ub_c = *pseudorange_sys1_size * 5;
  if (localB->loop_ub_c - 1 >= 0) {
    std::memset(&localB->H_sys1_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub_c) * sizeof(real_T));
  }

  localB->loop_ub_c = *pseudorange_sys1_size;
  for (localB->H_sys1 = 0; localB->H_sys1 < localB->loop_ub_c; localB->H_sys1++)
  {
    if (satellite_position_sys1_size[1] == 3) {
      for (localB->i_m = 0; localB->i_m < 3; localB->i_m++) {
        localB->satellite_position_sys1_tmp =
          satellite_position_sys1_data[satellite_position_sys1_size[0] *
          localB->i_m + localB->H_sys1] - user_state[localB->i_m];
        localB->satellite_position_sys1[localB->i_m] =
          localB->satellite_position_sys1_tmp;
        localB->satellite_position_sys1_n[localB->i_m] =
          localB->satellite_position_sys1_tmp;
      }

      localB->delta_rho_sys1_data[localB->H_sys1] = pseudorange_sys1_data
        [localB->H_sys1] - (DDRTCM_norm_n(localB->satellite_position_sys1,
        localB) + user_state[3]);
      localB->satellite_position_sys1_tmp = DDRTCM_norm_n
        (localB->satellite_position_sys1_n, localB);
      for (localB->i_m = 0; localB->i_m < 3; localB->i_m++) {
        localB->H_sys1_data[localB->H_sys1 + localB->H_sys1_size[0] *
          localB->i_m] =
          -(satellite_position_sys1_data[satellite_position_sys1_size[0] *
            localB->i_m + localB->H_sys1] - user_state[localB->i_m]) /
          localB->satellite_position_sys1_tmp;
      }

      localB->H_sys1_data[localB->H_sys1 + localB->H_sys1_size[0] * 3] = 1.0;
      localB->H_sys1_data[localB->H_sys1 + (localB->H_sys1_size[0] << 2)] = 0.0;
    } else {
      DDRTCM_binary_expand_op_fcej(localB->delta_rho_sys1_data, localB->H_sys1,
        pseudorange_sys1_data, satellite_position_sys1_data,
        satellite_position_sys1_size, user_state, localB);
      DDRTCM_binary_expand_op_fce(localB->H_sys1_data, localB->H_sys1_size,
        localB->H_sys1, satellite_position_sys1_data,
        satellite_position_sys1_size, user_state, localB);
    }
  }

  localB->H_sys2_size[0] = *pseudorange_sys2_size;
  localB->H_sys2_size[1] = 5;
  localB->loop_ub_c = *pseudorange_sys2_size * 5;
  if (localB->loop_ub_c - 1 >= 0) {
    std::memset(&localB->H_sys2_data[0], 0, static_cast<uint32_T>
                (localB->loop_ub_c) * sizeof(real_T));
  }

  localB->loop_ub_c = *pseudorange_sys2_size;
  for (localB->H_sys1 = 0; localB->H_sys1 < localB->loop_ub_c; localB->H_sys1++)
  {
    if (satellite_position_sys2_size[1] == 3) {
      for (localB->i_m = 0; localB->i_m < 3; localB->i_m++) {
        localB->satellite_position_sys1_tmp =
          satellite_position_sys2_data[satellite_position_sys2_size[0] *
          localB->i_m + localB->H_sys1] - user_state[localB->i_m];
        localB->satellite_position_sys1[localB->i_m] =
          localB->satellite_position_sys1_tmp;
        localB->satellite_position_sys1_n[localB->i_m] =
          localB->satellite_position_sys1_tmp;
      }

      localB->delta_rho_sys2_data[localB->H_sys1] = pseudorange_sys2_data
        [localB->H_sys1] - (DDRTCM_norm_n(localB->satellite_position_sys1,
        localB) + user_state[4]);
      localB->satellite_position_sys1_tmp = DDRTCM_norm_n
        (localB->satellite_position_sys1_n, localB);
      for (localB->i_m = 0; localB->i_m < 3; localB->i_m++) {
        localB->H_sys2_data[localB->H_sys1 + localB->H_sys2_size[0] *
          localB->i_m] =
          -(satellite_position_sys2_data[satellite_position_sys2_size[0] *
            localB->i_m + localB->H_sys1] - user_state[localB->i_m]) /
          localB->satellite_position_sys1_tmp;
      }

      localB->H_sys2_data[localB->H_sys1 + localB->H_sys2_size[0] * 3] = 0.0;
      localB->H_sys2_data[localB->H_sys1 + (localB->H_sys2_size[0] << 2)] = 1.0;
    } else {
      DDRTCM_binary_expand_op_fcejrc(localB->delta_rho_sys2_data, localB->H_sys1,
        pseudorange_sys2_data, satellite_position_sys2_data,
        satellite_position_sys2_size, user_state, localB);
      DDRTCM_binary_expand_op_fcejr(localB->H_sys2_data, localB->H_sys2_size,
        localB->H_sys1, satellite_position_sys2_data,
        satellite_position_sys2_size, user_state, localB);
    }
  }

  H_size[0] = localB->H_sys1_size[0] + localB->H_sys2_size[0];
  H_size[1] = 5;
  localB->loop_ub_c = localB->H_sys1_size[0];
  localB->H_sys1 = localB->H_sys2_size[0];
  for (localB->i_m = 0; localB->i_m < 5; localB->i_m++) {
    for (localB->i1 = 0; localB->i1 < localB->loop_ub_c; localB->i1++) {
      H_data[localB->i1 + H_size[0] * localB->i_m] = localB->H_sys1_data
        [localB->H_sys1_size[0] * localB->i_m + localB->i1];
    }

    for (localB->i1 = 0; localB->i1 < localB->H_sys1; localB->i1++) {
      H_data[(localB->i1 + localB->H_sys1_size[0]) + H_size[0] * localB->i_m] =
        localB->H_sys2_data[localB->H_sys2_size[0] * localB->i_m + localB->i1];
    }
  }

  *delta_rho_size = *pseudorange_sys1_size + *pseudorange_sys2_size;
  localB->loop_ub_c = *pseudorange_sys1_size;
  if (localB->loop_ub_c - 1 >= 0) {
    std::memcpy(&delta_rho_data[0], &localB->delta_rho_sys1_data[0],
                static_cast<uint32_T>(localB->loop_ub_c) * sizeof(real_T));
  }

  localB->loop_ub_c = *pseudorange_sys2_size;
  for (localB->i_m = 0; localB->i_m < localB->loop_ub_c; localB->i_m++) {
    delta_rho_data[localB->i_m + *pseudorange_sys1_size] =
      localB->delta_rho_sys2_data[localB->i_m];
  }

  for (localB->i_m = 0; localB->i_m < 5; localB->i_m++) {
    residuum[localB->i_m] = 0.0;
  }

  localB->i_m = H_size[0];
  for (localB->loop_ub_c = 0; localB->loop_ub_c < localB->i_m; localB->loop_ub_c
       ++) {
    for (localB->H_sys1 = 0; localB->H_sys1 < 5; localB->H_sys1++) {
      residuum[localB->H_sys1] += H_data[localB->H_sys1 * H_size[0] +
        localB->loop_ub_c] * delta_rho_data[localB->loop_ub_c];
    }
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
real_T DDRTCM::DDRTCM_xnrm2_h(int32_T n, const real_T x_data[], int32_T ix0,
  B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  real_T y;
  y = 0.0;
  if (n >= 1) {
    if (n == 1) {
      y = std::abs(x_data[ix0 - 1]);
    } else {
      localB->scale_da = 3.3121686421112381E-170;
      localB->kend_c = (ix0 + n) - 1;
      for (localB->k_o = ix0; localB->k_o <= localB->kend_c; localB->k_o++) {
        localB->absxk_e = std::abs(x_data[localB->k_o - 1]);
        if (localB->absxk_e > localB->scale_da) {
          localB->t_bj = localB->scale_da / localB->absxk_e;
          y = y * localB->t_bj * localB->t_bj + 1.0;
          localB->scale_da = localB->absxk_e;
        } else {
          localB->t_bj = localB->absxk_e / localB->scale_da;
          y += localB->t_bj * localB->t_bj;
        }
      }

      y = localB->scale_da * std::sqrt(y);
    }
  }

  return y;
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_qrsolve(const real_T A_data[], const int32_T A_size[2],
  const real_T B_data[], const int32_T *B_size, real_T Y[5],
  B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  __m128d tmp_0;
  localB->rankA_p = A_size[0];
  localB->b_A_size_a[0] = A_size[0];
  localB->minmana_e = A_size[0] * 5;
  if (localB->minmana_e - 1 >= 0) {
    std::memcpy(&localB->b_A_data[0], &A_data[0], static_cast<uint32_T>
                (localB->minmana_e) * sizeof(real_T));
  }

  if (A_size[0] <= 5) {
    localB->minmana_e = A_size[0];
  } else {
    localB->minmana_e = 5;
  }

  if (localB->minmana_e - 1 >= 0) {
    std::memset(&localB->tau_data[0], 0, static_cast<uint32_T>(localB->minmana_e)
                * sizeof(real_T));
  }

  if (A_size[0] == 0) {
    for (localB->rankA_p = 0; localB->rankA_p < 5; localB->rankA_p++) {
      localB->jpvt[localB->rankA_p] = static_cast<int8_T>(localB->rankA_p + 1);
    }
  } else {
    localB->minmana_e = A_size[0];
    for (localB->maxmn_a = 0; localB->maxmn_a < 5; localB->maxmn_a++) {
      localB->jpvt[localB->maxmn_a] = static_cast<int8_T>(localB->maxmn_a + 1);
      localB->work[localB->maxmn_a] = 0.0;
      localB->smax_h = DDRTCM_xnrm2_h(localB->rankA_p, A_data, localB->maxmn_a *
        localB->minmana_e + 1, localB);
      localB->vn2[localB->maxmn_a] = localB->smax_h;
      localB->vn1[localB->maxmn_a] = localB->smax_h;
    }

    if (A_size[0] <= 5) {
      localB->maxmn_a = A_size[0];
    } else {
      localB->maxmn_a = 5;
    }

    for (localB->e_i_o = 0; localB->e_i_o < localB->maxmn_a; localB->e_i_o++) {
      localB->jA_f = localB->e_i_o * localB->minmana_e;
      localB->ii_a = localB->jA_f + localB->e_i_o;
      localB->mmi_a = localB->rankA_p - localB->e_i_o;
      localB->itemp_l = 5 - localB->e_i_o;
      localB->pvt_i = 0;
      if (5 - localB->e_i_o > 1) {
        localB->smax_h = std::abs(localB->vn1[localB->e_i_o]);
        for (localB->b_ix_o = 2; localB->b_ix_o <= localB->itemp_l;
             localB->b_ix_o++) {
          localB->s_bn = std::abs(localB->vn1[(localB->e_i_o + localB->b_ix_o) -
            1]);
          if (localB->s_bn > localB->smax_h) {
            localB->pvt_i = localB->b_ix_o - 1;
            localB->smax_h = localB->s_bn;
          }
        }
      }

      localB->pvt_i += localB->e_i_o;
      if (localB->pvt_i != localB->e_i_o) {
        localB->b_ix_o = localB->pvt_i * localB->minmana_e;
        for (localB->c_k_i = 0; localB->c_k_i < localB->rankA_p; localB->c_k_i++)
        {
          localB->temp_tmp_g = localB->b_ix_o + localB->c_k_i;
          localB->smax_h = localB->b_A_data[localB->temp_tmp_g];
          localB->itemp_l = localB->jA_f + localB->c_k_i;
          localB->b_A_data[localB->temp_tmp_g] = localB->b_A_data
            [localB->itemp_l];
          localB->b_A_data[localB->itemp_l] = localB->smax_h;
        }

        localB->itemp_l = localB->jpvt[localB->pvt_i];
        localB->jpvt[localB->pvt_i] = localB->jpvt[localB->e_i_o];
        localB->jpvt[localB->e_i_o] = static_cast<int8_T>(localB->itemp_l);
        localB->vn1[localB->pvt_i] = localB->vn1[localB->e_i_o];
        localB->vn2[localB->pvt_i] = localB->vn2[localB->e_i_o];
      }

      if (localB->e_i_o + 1 < localB->rankA_p) {
        localB->s_bn = localB->b_A_data[localB->ii_a];
        localB->pvt_i = localB->ii_a + 2;
        localB->tau_data[localB->e_i_o] = 0.0;
        if (localB->mmi_a > 0) {
          localB->smax_h = DDRTCM_xnrm2_h(localB->mmi_a - 1, localB->b_A_data,
            localB->ii_a + 2, localB);
          if (localB->smax_h != 0.0) {
            localB->smax_h = DDRTCM_rt_hypotd_snf(localB->b_A_data[localB->ii_a],
              localB->smax_h, localB);
            if (localB->b_A_data[localB->ii_a] >= 0.0) {
              localB->smax_h = -localB->smax_h;
            }

            if (std::abs(localB->smax_h) < 1.0020841800044864E-292) {
              localB->b_ix_o = 0;
              localB->c_k_i = localB->ii_a + localB->mmi_a;
              do {
                localB->b_ix_o++;
                localB->itemp_l = (((((localB->c_k_i - localB->ii_a) - 1) / 2) <<
                                    1) + localB->ii_a) + 2;
                localB->jA_f = localB->itemp_l - 2;
                for (localB->temp_tmp_g = localB->pvt_i; localB->temp_tmp_g <=
                     localB->jA_f; localB->temp_tmp_g += 2) {
                  tmp_0 = _mm_loadu_pd(&localB->b_A_data[localB->temp_tmp_g - 1]);
                  _mm_storeu_pd(&localB->b_A_data[localB->temp_tmp_g - 1],
                                _mm_mul_pd(tmp_0, _mm_set1_pd
                    (9.9792015476736E+291)));
                }

                for (localB->temp_tmp_g = localB->itemp_l; localB->temp_tmp_g <=
                     localB->c_k_i; localB->temp_tmp_g++) {
                  localB->b_A_data[localB->temp_tmp_g - 1] *=
                    9.9792015476736E+291;
                }

                localB->smax_h *= 9.9792015476736E+291;
                localB->s_bn *= 9.9792015476736E+291;
              } while ((std::abs(localB->smax_h) < 1.0020841800044864E-292) &&
                       (localB->b_ix_o < 20));

              localB->smax_h = DDRTCM_rt_hypotd_snf(localB->s_bn, DDRTCM_xnrm2_h
                (localB->mmi_a - 1, localB->b_A_data, localB->ii_a + 2, localB),
                localB);
              if (localB->s_bn >= 0.0) {
                localB->smax_h = -localB->smax_h;
              }

              localB->tau_data[localB->e_i_o] = (localB->smax_h - localB->s_bn) /
                localB->smax_h;
              localB->s_bn = 1.0 / (localB->s_bn - localB->smax_h);
              localB->itemp_l = (((((localB->c_k_i - localB->ii_a) - 1) / 2) <<
                                  1) + localB->ii_a) + 2;
              localB->jA_f = localB->itemp_l - 2;
              for (localB->temp_tmp_g = localB->pvt_i; localB->temp_tmp_g <=
                   localB->jA_f; localB->temp_tmp_g += 2) {
                tmp_0 = _mm_loadu_pd(&localB->b_A_data[localB->temp_tmp_g - 1]);
                _mm_storeu_pd(&localB->b_A_data[localB->temp_tmp_g - 1],
                              _mm_mul_pd(tmp_0, _mm_set1_pd(localB->s_bn)));
              }

              for (localB->temp_tmp_g = localB->itemp_l; localB->temp_tmp_g <=
                   localB->c_k_i; localB->temp_tmp_g++) {
                localB->b_A_data[localB->temp_tmp_g - 1] *= localB->s_bn;
              }

              for (localB->itemp_l = 0; localB->itemp_l < localB->b_ix_o;
                   localB->itemp_l++) {
                localB->smax_h *= 1.0020841800044864E-292;
              }

              localB->s_bn = localB->smax_h;
            } else {
              localB->tau_data[localB->e_i_o] = (localB->smax_h -
                localB->b_A_data[localB->ii_a]) / localB->smax_h;
              localB->s_bn = 1.0 / (localB->b_A_data[localB->ii_a] -
                                    localB->smax_h);
              localB->b_ix_o = localB->ii_a + localB->mmi_a;
              localB->itemp_l = (((((localB->b_ix_o - localB->ii_a) - 1) / 2) <<
                                  1) + localB->ii_a) + 2;
              localB->jA_f = localB->itemp_l - 2;
              for (localB->c_k_i = localB->pvt_i; localB->c_k_i <= localB->jA_f;
                   localB->c_k_i += 2) {
                tmp_0 = _mm_loadu_pd(&localB->b_A_data[localB->c_k_i - 1]);
                _mm_storeu_pd(&localB->b_A_data[localB->c_k_i - 1], _mm_mul_pd
                              (tmp_0, _mm_set1_pd(localB->s_bn)));
              }

              for (localB->c_k_i = localB->itemp_l; localB->c_k_i <=
                   localB->b_ix_o; localB->c_k_i++) {
                localB->b_A_data[localB->c_k_i - 1] *= localB->s_bn;
              }

              localB->s_bn = localB->smax_h;
            }
          }
        }

        localB->b_A_data[localB->ii_a] = localB->s_bn;
      } else {
        localB->tau_data[localB->e_i_o] = 0.0;
      }

      if (localB->e_i_o + 1 < 5) {
        localB->smax_h = localB->b_A_data[localB->ii_a];
        localB->b_A_data[localB->ii_a] = 1.0;
        localB->jA_f = (localB->ii_a + localB->minmana_e) + 1;
        if (localB->tau_data[localB->e_i_o] != 0.0) {
          boolean_T exitg2;
          localB->itemp_l = localB->mmi_a - 1;
          localB->pvt_i = (localB->ii_a + localB->mmi_a) - 1;
          while ((localB->itemp_l + 1 > 0) && (localB->b_A_data[localB->pvt_i] ==
                  0.0)) {
            localB->itemp_l--;
            localB->pvt_i--;
          }

          localB->pvt_i = 4 - localB->e_i_o;
          exitg2 = false;
          while ((!exitg2) && (localB->pvt_i > 0)) {
            int32_T exitg1;
            localB->b_ix_o = (localB->pvt_i - 1) * localB->minmana_e +
              localB->jA_f;
            localB->c_k_i = localB->b_ix_o;
            do {
              exitg1 = 0;
              if (localB->c_k_i <= localB->b_ix_o + localB->itemp_l) {
                if (localB->b_A_data[localB->c_k_i - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  localB->c_k_i++;
                }
              } else {
                localB->pvt_i--;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }

          localB->pvt_i--;
        } else {
          localB->itemp_l = -1;
          localB->pvt_i = -1;
        }

        if (localB->itemp_l + 1 > 0) {
          if (localB->pvt_i + 1 != 0) {
            std::memset(&localB->work[0], 0, static_cast<uint32_T>(localB->pvt_i
              + 1) * sizeof(real_T));
            localB->b_ix_o = 0;
            localB->c_k_i = localB->minmana_e * localB->pvt_i + localB->jA_f;
            for (localB->temp_tmp_g = localB->jA_f; localB->minmana_e < 0 ?
                 localB->temp_tmp_g >= localB->c_k_i : localB->temp_tmp_g <=
                 localB->c_k_i; localB->temp_tmp_g += localB->minmana_e) {
              localB->s_bn = 0.0;
              localB->p_f = localB->temp_tmp_g + localB->itemp_l;
              for (localB->ia_i = localB->temp_tmp_g; localB->ia_i <=
                   localB->p_f; localB->ia_i++) {
                localB->s_bn += localB->b_A_data[(localB->ii_a + localB->ia_i) -
                  localB->temp_tmp_g] * localB->b_A_data[localB->ia_i - 1];
              }

              localB->work[localB->b_ix_o] += localB->s_bn;
              localB->b_ix_o++;
            }
          }

          if (!(-localB->tau_data[localB->e_i_o] == 0.0)) {
            for (localB->b_ix_o = 0; localB->b_ix_o <= localB->pvt_i;
                 localB->b_ix_o++) {
              localB->s_bn = localB->work[localB->b_ix_o];
              if (localB->s_bn != 0.0) {
                localB->s_bn *= -localB->tau_data[localB->e_i_o];
                localB->c_k_i = localB->itemp_l + localB->jA_f;
                for (localB->temp_tmp_g = localB->jA_f; localB->temp_tmp_g <=
                     localB->c_k_i; localB->temp_tmp_g++) {
                  localB->b_A_data[localB->temp_tmp_g - 1] += localB->b_A_data
                    [(localB->ii_a + localB->temp_tmp_g) - localB->jA_f] *
                    localB->s_bn;
                }
              }

              localB->jA_f += localB->minmana_e;
            }
          }
        }

        localB->b_A_data[localB->ii_a] = localB->smax_h;
      }

      for (localB->ii_a = localB->e_i_o + 2; localB->ii_a < 6; localB->ii_a++) {
        localB->itemp_l = (localB->ii_a - 1) * localB->minmana_e + localB->e_i_o;
        localB->smax_h = localB->vn1[localB->ii_a - 1];
        if (localB->smax_h != 0.0) {
          localB->s_bn = std::abs(localB->b_A_data[localB->itemp_l]) /
            localB->smax_h;
          localB->s_bn = 1.0 - localB->s_bn * localB->s_bn;
          if (localB->s_bn < 0.0) {
            localB->s_bn = 0.0;
          }

          localB->temp2_l = localB->smax_h / localB->vn2[localB->ii_a - 1];
          localB->temp2_l = localB->temp2_l * localB->temp2_l * localB->s_bn;
          if (localB->temp2_l <= 1.4901161193847656E-8) {
            if (localB->e_i_o + 1 < localB->rankA_p) {
              localB->vn1[localB->ii_a - 1] = DDRTCM_xnrm2_h(localB->mmi_a - 1,
                localB->b_A_data, localB->itemp_l + 2, localB);
              localB->vn2[localB->ii_a - 1] = localB->vn1[localB->ii_a - 1];
            } else {
              localB->vn1[localB->ii_a - 1] = 0.0;
              localB->vn2[localB->ii_a - 1] = 0.0;
            }
          } else {
            localB->vn1[localB->ii_a - 1] = localB->smax_h * std::sqrt
              (localB->s_bn);
          }
        }
      }
    }
  }

  localB->rankA_p = 0;
  if (A_size[0] < 5) {
    localB->minmana_e = A_size[0];
    localB->maxmn_a = 5;
  } else {
    localB->minmana_e = 5;
    localB->maxmn_a = A_size[0];
  }

  if (localB->minmana_e > 0) {
    while ((localB->rankA_p < localB->minmana_e) && (!(std::abs(localB->
              b_A_data[localB->b_A_size_a[0] * localB->rankA_p + localB->rankA_p])
             <= 2.2204460492503131E-15 * static_cast<real_T>(localB->maxmn_a) *
             std::abs(localB->b_A_data[0])))) {
      localB->rankA_p++;
    }
  }

  localB->minmana_e = *B_size;
  if (localB->minmana_e - 1 >= 0) {
    std::memcpy(&localB->b_B_data[0], &B_data[0], static_cast<uint32_T>
                (localB->minmana_e) * sizeof(real_T));
  }

  for (localB->minmana_e = 0; localB->minmana_e < 5; localB->minmana_e++) {
    Y[localB->minmana_e] = 0.0;
  }

  localB->minmana_e = A_size[0];
  if (A_size[0] <= 5) {
    localB->maxmn_a = A_size[0];
  } else {
    localB->maxmn_a = 5;
  }

  for (localB->e_i_o = 0; localB->e_i_o < localB->maxmn_a; localB->e_i_o++) {
    localB->smax_h = localB->tau_data[localB->e_i_o];
    if (localB->smax_h != 0.0) {
      localB->s_bn = localB->b_B_data[localB->e_i_o];
      for (localB->mmi_a = localB->e_i_o + 2; localB->mmi_a <= localB->minmana_e;
           localB->mmi_a++) {
        localB->s_bn += localB->b_A_data[(localB->b_A_size_a[0] * localB->e_i_o
          + localB->mmi_a) - 1] * localB->b_B_data[localB->mmi_a - 1];
      }

      localB->s_bn *= localB->smax_h;
      if (localB->s_bn != 0.0) {
        localB->b_B_data[localB->e_i_o] -= localB->s_bn;
        localB->itemp_l = (((((localB->minmana_e - localB->e_i_o) - 1) / 2) << 1)
                           + localB->e_i_o) + 2;
        localB->jA_f = localB->itemp_l - 2;
        for (localB->mmi_a = localB->e_i_o + 2; localB->mmi_a <= localB->jA_f;
             localB->mmi_a += 2) {
          __m128d tmp;
          tmp_0 = _mm_loadu_pd(&localB->b_A_data[(localB->b_A_size_a[0] *
            localB->e_i_o + localB->mmi_a) - 1]);
          tmp = _mm_loadu_pd(&localB->b_B_data[localB->mmi_a - 1]);
          _mm_storeu_pd(&localB->b_B_data[localB->mmi_a - 1], _mm_sub_pd(tmp,
            _mm_mul_pd(tmp_0, _mm_set1_pd(localB->s_bn))));
        }

        for (localB->mmi_a = localB->itemp_l; localB->mmi_a <= localB->minmana_e;
             localB->mmi_a++) {
          localB->b_B_data[localB->mmi_a - 1] -= localB->b_A_data
            [(localB->b_A_size_a[0] * localB->e_i_o + localB->mmi_a) - 1] *
            localB->s_bn;
        }
      }
    }
  }

  for (localB->minmana_e = 0; localB->minmana_e < localB->rankA_p;
       localB->minmana_e++) {
    Y[localB->jpvt[localB->minmana_e] - 1] = localB->b_B_data[localB->minmana_e];
  }

  for (localB->minmana_e = localB->rankA_p; localB->minmana_e >= 1;
       localB->minmana_e--) {
    localB->maxmn_a = localB->jpvt[localB->minmana_e - 1] - 1;
    localB->ii_a = (localB->minmana_e - 1) * localB->b_A_size_a[0];
    Y[localB->maxmn_a] /= localB->b_A_data[(localB->minmana_e + localB->ii_a) -
      1];
    for (localB->e_i_o = 0; localB->e_i_o <= localB->minmana_e - 2;
         localB->e_i_o++) {
      localB->mmi_a = localB->jpvt[localB->e_i_o] - 1;
      Y[localB->mmi_a] -= localB->b_A_data[localB->e_i_o + localB->ii_a] *
        Y[localB->maxmn_a];
    }
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_mldivide_ldk(const real_T A_data[], const int32_T A_size[2],
  real_T B_data[], int32_T *B_size, B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  if (A_size[0] == 0) {
    *B_size = 5;
    for (localB->kAcol_h = 0; localB->kAcol_h < 5; localB->kAcol_h++) {
      B_data[localB->kAcol_h] = 0.0;
    }
  } else if (*B_size == 0) {
    *B_size = 5;
    for (localB->kAcol_h = 0; localB->kAcol_h < 5; localB->kAcol_h++) {
      B_data[localB->kAcol_h] = 0.0;
    }
  } else if (A_size[0] == 5) {
    std::memcpy(&localB->b_A_data_cx[0], &A_data[0], 25U * sizeof(real_T));
    for (localB->kAcol_h = 0; localB->kAcol_h < 5; localB->kAcol_h++) {
      localB->ipiv[localB->kAcol_h] = static_cast<int8_T>(localB->kAcol_h + 1);
    }

    for (localB->j_j = 0; localB->j_j < 4; localB->j_j++) {
      localB->ipiv_m = localB->ipiv[localB->j_j];
      localB->jj_m = localB->j_j * 6;
      localB->n_c = 5 - localB->j_j;
      localB->jA_c = 0;
      localB->smax_n = std::abs(localB->b_A_data_cx[localB->jj_m]);
      for (localB->kAcol_h = 2; localB->kAcol_h <= localB->n_c; localB->kAcol_h
           ++) {
        localB->s_b = std::abs(localB->b_A_data_cx[(localB->jj_m +
          localB->kAcol_h) - 1]);
        if (localB->s_b > localB->smax_n) {
          localB->jA_c = localB->kAcol_h - 1;
          localB->smax_n = localB->s_b;
        }
      }

      if (localB->b_A_data_cx[localB->jj_m + localB->jA_c] != 0.0) {
        if (localB->jA_c != 0) {
          localB->jA_c += localB->j_j;
          localB->ipiv_m = static_cast<int8_T>(localB->jA_c + 1);
          for (localB->n_c = 0; localB->n_c < 5; localB->n_c++) {
            localB->b_temp_tmp = localB->n_c * 5 + localB->j_j;
            localB->smax_n = localB->b_A_data_cx[localB->b_temp_tmp];
            localB->kAcol_h = localB->n_c * 5 + localB->jA_c;
            localB->b_A_data_cx[localB->b_temp_tmp] = localB->b_A_data_cx
              [localB->kAcol_h];
            localB->b_A_data_cx[localB->kAcol_h] = localB->smax_n;
          }
        }

        localB->n_c = (localB->jj_m - localB->j_j) + 5;
        localB->jA_c = (((((localB->n_c - localB->jj_m) - 1) / 2) << 1) +
                        localB->jj_m) + 2;
        localB->b_temp_tmp = localB->jA_c - 2;
        for (localB->kAcol_h = localB->jj_m + 2; localB->kAcol_h <=
             localB->b_temp_tmp; localB->kAcol_h += 2) {
          __m128d tmp;
          tmp = _mm_loadu_pd(&localB->b_A_data_cx[localB->kAcol_h - 1]);
          _mm_storeu_pd(&localB->b_A_data_cx[localB->kAcol_h - 1], _mm_div_pd
                        (tmp, _mm_set1_pd(localB->b_A_data_cx[localB->jj_m])));
        }

        for (localB->kAcol_h = localB->jA_c; localB->kAcol_h <= localB->n_c;
             localB->kAcol_h++) {
          localB->b_A_data_cx[localB->kAcol_h - 1] /= localB->b_A_data_cx
            [localB->jj_m];
        }
      }

      localB->jA_c = localB->jj_m + 7;
      localB->b_temp_tmp = 3 - localB->j_j;
      for (localB->kAcol_h = 0; localB->kAcol_h <= localB->b_temp_tmp;
           localB->kAcol_h++) {
        localB->smax_n = localB->b_A_data_cx[(localB->kAcol_h * 5 + localB->jj_m)
          + 5];
        if (localB->smax_n != 0.0) {
          localB->e_p = (localB->jA_c - localB->j_j) + 3;
          for (localB->n_c = localB->jA_c; localB->n_c <= localB->e_p;
               localB->n_c++) {
            localB->b_A_data_cx[localB->n_c - 1] += localB->b_A_data_cx
              [((localB->jj_m + localB->n_c) - localB->jA_c) + 1] *
              -localB->smax_n;
          }
        }

        localB->jA_c += 5;
      }

      if (localB->j_j + 1 != localB->ipiv_m) {
        localB->smax_n = B_data[localB->j_j];
        B_data[localB->j_j] = B_data[localB->ipiv_m - 1];
        B_data[localB->ipiv_m - 1] = localB->smax_n;
      }

      localB->ipiv[localB->j_j] = localB->ipiv_m;
    }

    for (localB->j_j = 0; localB->j_j < 5; localB->j_j++) {
      localB->kAcol_h = 5 * localB->j_j;
      if (B_data[localB->j_j] != 0.0) {
        for (localB->jj_m = localB->j_j + 2; localB->jj_m < 6; localB->jj_m++) {
          B_data[localB->jj_m - 1] -= localB->b_A_data_cx[(localB->jj_m +
            localB->kAcol_h) - 1] * B_data[localB->j_j];
        }
      }
    }

    for (localB->j_j = 4; localB->j_j >= 0; localB->j_j--) {
      localB->kAcol_h = 5 * localB->j_j;
      if (B_data[localB->j_j] != 0.0) {
        B_data[localB->j_j] /= localB->b_A_data_cx[localB->j_j + localB->kAcol_h];
        for (localB->jj_m = 0; localB->jj_m < localB->j_j; localB->jj_m++) {
          B_data[localB->jj_m] -= localB->b_A_data_cx[localB->jj_m +
            localB->kAcol_h] * B_data[localB->j_j];
        }
      }
    }
  } else {
    DDRTCM_qrsolve(A_data, A_size, B_data, B_size, localB->dv, localB);
    *B_size = 5;
    for (localB->kAcol_h = 0; localB->kAcol_h < 5; localB->kAcol_h++) {
      B_data[localB->kAcol_h] = localB->dv[localB->kAcol_h];
    }
  }
}

void DDRTCM::DDRTCM_plus_l(real_T in1[5], const real_T in2_data[], const int32_T
  *in2_size)
{
  int32_T stride_0_0;
  stride_0_0 = (*in2_size != 1);
  for (int32_T i{0}; i < 5; i++) {
    in1[i] += in2_data[i * stride_0_0];
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
real_T DDRTCM::DDRTCM_calc_delta_T_GNSS_system(const real_T
  gnss_measurement_satellite_posi[], const int32_T
  gnss_measurement_satellite_po_0[2], const uint16_T gnss_measurement_PRN_data[],
  const int32_T *gnss_measurement_PRN_size, const real_T
  gnss_measurement_pseudorange_da[], const int32_T
  *gnss_measurement_pseudorange_si, B_MergeGNSSMeasurement_DDRTCM_T *localB,
  DW_MergeGNSSMeasurement_DDRTC_T *localDW)
{
  real_T delta_t;
  if (*gnss_measurement_pseudorange_si > 5) {
    int32_T exitg1;
    boolean_T guard1{ false };

    DDRTCM_isMember(gnss_measurement_PRN_data, gnss_measurement_PRN_size,
                    localB->l_data_p, &localB->l_size_n);
    guard1 = false;
    if (DDRTCM_any_g(localB->l_data_p, &localB->l_size_n)) {
      DDRTCM_isMember_c(gnss_measurement_PRN_data, gnss_measurement_PRN_size,
                        localB->l_data, &localB->l_size);
      if (DDRTCM_any_g(localB->l_data, &localB->l_size)) {
        for (localB->i_i = 0; localB->i_i < 5; localB->i_i++) {
          localB->b_user_state[localB->i_i] = 0.0;
        }

        localB->i_tmp = localB->l_size - 1;
        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data[localB->iter]) {
            localB->loop_ub_o++;
          }
        }

        localB->g_size_idx_0 = localB->loop_ub_o;
        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data[localB->iter]) {
            localB->g_data[localB->loop_ub_o] = static_cast<int8_T>(localB->iter
              + 1);
            localB->loop_ub_o++;
          }
        }

        localB->H_size[0] = localB->g_size_idx_0;
        localB->H_size[1] = gnss_measurement_satellite_po_0[1];
        localB->loop_ub_o = gnss_measurement_satellite_po_0[1];
        for (localB->i_i = 0; localB->i_i < localB->loop_ub_o; localB->i_i++) {
          for (localB->iter = 0; localB->iter < localB->g_size_idx_0;
               localB->iter++) {
            localB->satellite_position_gps_data[localB->iter +
              localB->g_size_idx_0 * localB->i_i] =
              gnss_measurement_satellite_posi[(gnss_measurement_satellite_po_0[0]
              * localB->i_i + localB->g_data[localB->iter]) - 1];
          }
        }

        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data[localB->iter]) {
            localB->loop_ub_o++;
          }
        }

        localB->g_size_idx_0 = localB->loop_ub_o;
        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data[localB->iter]) {
            localB->h_data[localB->loop_ub_o] = static_cast<int8_T>(localB->iter
              + 1);
            localB->loop_ub_o++;
          }
        }

        localB->pseudorange_gps_size = localB->g_size_idx_0;
        for (localB->i_i = 0; localB->i_i < localB->g_size_idx_0; localB->i_i++)
        {
          localB->pseudorange_gps_data[localB->i_i] =
            gnss_measurement_pseudorange_da[localB->h_data[localB->i_i] - 1];
        }

        localB->i_tmp = localB->l_size_n - 1;
        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data_p[localB->iter]) {
            localB->loop_ub_o++;
          }
        }

        localB->g_size_idx_0 = localB->loop_ub_o;
        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data_p[localB->iter]) {
            localB->i_data[localB->loop_ub_o] = static_cast<int8_T>(localB->iter
              + 1);
            localB->loop_ub_o++;
          }
        }

        localB->satellite_position_galileo_size[0] = localB->g_size_idx_0;
        localB->satellite_position_galileo_size[1] =
          gnss_measurement_satellite_po_0[1];
        localB->loop_ub_o = gnss_measurement_satellite_po_0[1];
        for (localB->i_i = 0; localB->i_i < localB->loop_ub_o; localB->i_i++) {
          for (localB->iter = 0; localB->iter < localB->g_size_idx_0;
               localB->iter++) {
            localB->satellite_position_galileo_data[localB->iter +
              localB->g_size_idx_0 * localB->i_i] =
              gnss_measurement_satellite_posi[(gnss_measurement_satellite_po_0[0]
              * localB->i_i + localB->i_data[localB->iter]) - 1];
          }
        }

        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data_p[localB->iter]) {
            localB->loop_ub_o++;
          }
        }

        localB->g_size_idx_0 = localB->loop_ub_o;
        localB->loop_ub_o = 0;
        for (localB->iter = 0; localB->iter <= localB->i_tmp; localB->iter++) {
          if (localB->l_data_p[localB->iter]) {
            localB->j_data[localB->loop_ub_o] = static_cast<int8_T>(localB->iter
              + 1);
            localB->loop_ub_o++;
          }
        }

        localB->pseudorange_galileo_size = localB->g_size_idx_0;
        for (localB->i_i = 0; localB->i_i < localB->g_size_idx_0; localB->i_i++)
        {
          localB->pseudorange_galileo_data[localB->i_i] =
            gnss_measurement_pseudorange_da[localB->j_data[localB->i_i] - 1];
        }

        for (localB->i_i = 0; localB->i_i < 5; localB->i_i++) {
          localB->GPSGalileoPosition_data[localB->i_i] = 0.0;
        }

        DDRTCM_getJacobiMultiKonst(localB->satellite_position_gps_data,
          localB->H_size, localB->satellite_position_galileo_data,
          localB->satellite_position_galileo_size, localB->pseudorange_gps_data,
          &localB->pseudorange_gps_size, localB->pseudorange_galileo_data,
          &localB->pseudorange_galileo_size, localB->GPSGalileoPosition_data,
          localB->delta_rho_data, &localB->delta_rho_size, localB->b_H_data,
          localB->b_H_size, localB->b_residuum, localB);
        localB->iter = 0;
        do {
          exitg1 = 0;
          localB->scale = 0.0;
          localB->absxk = 3.3121686421112381E-170;
          for (localB->i_i = 0; localB->i_i < 5; localB->i_i++) {
            localB->t = std::abs(localB->b_residuum[localB->i_i]);
            if (localB->t > localB->absxk) {
              localB->b_t = localB->absxk / localB->t;
              localB->scale = localB->scale * localB->b_t * localB->b_t + 1.0;
              localB->absxk = localB->t;
            } else {
              localB->b_t = localB->t / localB->absxk;
              localB->scale += localB->b_t * localB->b_t;
            }
          }

          localB->scale = localB->absxk * std::sqrt(localB->scale);
          if ((localB->scale > 0.01) && (localB->iter < 1000)) {
            DDRTCM_mldivide_ldk(localB->b_H_data, localB->b_H_size,
                                localB->delta_rho_data, &localB->delta_rho_size,
                                localB);
            if (localB->delta_rho_size == 5) {
              for (localB->i_i = 0; localB->i_i <= 2; localB->i_i += 2) {
                __m128d tmp;
                __m128d tmp_0;
                tmp = _mm_loadu_pd(&localB->b_user_state[localB->i_i]);
                tmp_0 = _mm_loadu_pd(&localB->delta_rho_data[localB->i_i]);
                _mm_storeu_pd(&localB->b_user_state[localB->i_i], _mm_add_pd(tmp,
                  tmp_0));
              }

              for (localB->i_i = 4; localB->i_i < 5; localB->i_i++) {
                localB->b_user_state[localB->i_i] += localB->
                  delta_rho_data[localB->i_i];
              }
            } else {
              DDRTCM_plus_l(localB->b_user_state, localB->delta_rho_data,
                            &localB->delta_rho_size);
            }

            DDRTCM_getJacobiMultiKonst(localB->satellite_position_gps_data,
              localB->H_size, localB->satellite_position_galileo_data,
              localB->satellite_position_galileo_size,
              localB->pseudorange_gps_data, &localB->pseudorange_gps_size,
              localB->pseudorange_galileo_data,
              &localB->pseudorange_galileo_size, localB->b_user_state,
              localB->delta_rho_data, &localB->delta_rho_size, localB->b_H_data,
              localB->b_H_size, localB->b_residuum, localB);
            localB->iter++;
          } else {
            exitg1 = 1;
          }
        } while (exitg1 == 0);

        localB->loop_ub_o = 5;
        for (localB->i_i = 0; localB->i_i < 5; localB->i_i++) {
          localB->GPSGalileoPosition_data[localB->i_i] = localB->
            b_user_state[localB->i_i];
        }
      } else {
        guard1 = true;
      }
    } else {
      guard1 = true;
    }

    if (guard1) {
      localB->user_state[0] = 0.0;
      localB->dv1[0] = 0.0;
      localB->user_state[1] = 0.0;
      localB->dv1[1] = 0.0;
      localB->user_state[2] = 0.0;
      localB->dv1[2] = 0.0;
      localB->user_state[3] = 0.0;
      localB->dv1[3] = 0.0;
      DDRTCM_getJacobi(gnss_measurement_satellite_posi,
                       gnss_measurement_satellite_po_0,
                       gnss_measurement_pseudorange_da,
                       gnss_measurement_pseudorange_si, localB->dv1,
                       localB->pseudorange_gps_data,
                       &localB->pseudorange_gps_size, localB->H_data,
                       localB->H_size, localB->residuum, localB);
      localB->delta_rho_size = localB->pseudorange_gps_size;
      localB->loop_ub_o = localB->pseudorange_gps_size;
      if (localB->loop_ub_o - 1 >= 0) {
        std::memcpy(&localB->delta_rho_data[0], &localB->pseudorange_gps_data[0],
                    static_cast<uint32_T>(localB->loop_ub_o) * sizeof(real_T));
      }

      localB->iter = 0;
      do {
        exitg1 = 0;
        localB->scale = 3.3121686421112381E-170;
        localB->absxk = std::abs(localB->residuum[0]);
        if (localB->absxk > 3.3121686421112381E-170) {
          localB->b_t = 1.0;
          localB->scale = localB->absxk;
        } else {
          localB->t = localB->absxk / 3.3121686421112381E-170;
          localB->b_t = localB->t * localB->t;
        }

        localB->absxk = std::abs(localB->residuum[1]);
        if (localB->absxk > localB->scale) {
          localB->t = localB->scale / localB->absxk;
          localB->b_t = localB->b_t * localB->t * localB->t + 1.0;
          localB->scale = localB->absxk;
        } else {
          localB->t = localB->absxk / localB->scale;
          localB->b_t += localB->t * localB->t;
        }

        localB->absxk = std::abs(localB->residuum[2]);
        if (localB->absxk > localB->scale) {
          localB->t = localB->scale / localB->absxk;
          localB->b_t = localB->b_t * localB->t * localB->t + 1.0;
          localB->scale = localB->absxk;
        } else {
          localB->t = localB->absxk / localB->scale;
          localB->b_t += localB->t * localB->t;
        }

        localB->absxk = std::abs(localB->residuum[3]);
        if (localB->absxk > localB->scale) {
          localB->t = localB->scale / localB->absxk;
          localB->b_t = localB->b_t * localB->t * localB->t + 1.0;
          localB->scale = localB->absxk;
        } else {
          localB->t = localB->absxk / localB->scale;
          localB->b_t += localB->t * localB->t;
        }

        localB->b_t = localB->scale * std::sqrt(localB->b_t);
        if ((localB->b_t > 1.0E-15) && (localB->iter < 1000)) {
          localB->pseudorange_gps_size = localB->delta_rho_size;
          localB->loop_ub_o = localB->delta_rho_size;
          if (localB->loop_ub_o - 1 >= 0) {
            std::memcpy(&localB->pseudorange_gps_data[0],
                        &localB->delta_rho_data[0], static_cast<uint32_T>
                        (localB->loop_ub_o) * sizeof(real_T));
          }

          DDRTCM_mldivide_ldko(localB->H_data, localB->H_size,
                               localB->pseudorange_gps_data,
                               &localB->pseudorange_gps_size, localB);
          if (localB->pseudorange_gps_size == 4) {
            localB->user_state[0] += localB->pseudorange_gps_data[0];
            localB->user_state[1] += localB->pseudorange_gps_data[1];
            localB->user_state[2] += localB->pseudorange_gps_data[2];
            localB->user_state[3] += localB->pseudorange_gps_data[3];
          } else {
            DDRTCM_plus_lh(localB->user_state, localB->pseudorange_gps_data,
                           &localB->pseudorange_gps_size);
          }

          DDRTCM_getJacobi(gnss_measurement_satellite_posi,
                           gnss_measurement_satellite_po_0,
                           gnss_measurement_pseudorange_da,
                           gnss_measurement_pseudorange_si, localB->user_state,
                           localB->pseudorange_gps_data,
                           &localB->pseudorange_gps_size, localB->H_data,
                           localB->H_size, localB->residuum, localB);
          localB->delta_rho_size = localB->pseudorange_gps_size;
          localB->loop_ub_o = localB->pseudorange_gps_size;
          if (localB->loop_ub_o - 1 >= 0) {
            std::memcpy(&localB->delta_rho_data[0],
                        &localB->pseudorange_gps_data[0], static_cast<uint32_T>
                        (localB->loop_ub_o) * sizeof(real_T));
          }

          localB->iter++;
        } else {
          exitg1 = 1;
        }
      } while (exitg1 == 0);

      localB->loop_ub_o = 4;
      localB->GPSGalileoPosition_data[0] = localB->user_state[0];
      localB->GPSGalileoPosition_data[1] = localB->user_state[1];
      localB->GPSGalileoPosition_data[2] = localB->user_state[2];
      localB->GPSGalileoPosition_data[3] = localB->user_state[3];
    }

    if (localB->loop_ub_o > 4) {
      localB->GPSGalileoPosition[0] = localB->GPSGalileoPosition_data[0];
      localB->GPSGalileoPosition[200] = localB->GPSGalileoPosition_data[1];
      localB->GPSGalileoPosition[400] = localB->GPSGalileoPosition_data[2];
      localB->GPSGalileoPosition[600] = localB->GPSGalileoPosition_data[3];
      localB->GPSGalileoPosition[800] = localB->GPSGalileoPosition_data[4];
      for (localB->i_i = 0; localB->i_i < 199; localB->i_i++) {
        for (localB->iter = 0; localB->iter < 5; localB->iter++) {
          localB->loop_ub_o = 200 * localB->iter + localB->i_i;
          localB->GPSGalileoPosition[localB->loop_ub_o + 1] =
            localDW->userposBuffer[localB->loop_ub_o];
        }
      }

      std::memcpy(&localDW->userposBuffer[0], &localB->GPSGalileoPosition[0],
                  1000U * sizeof(real_T));
      localDW->writeIdx++;
      if (localDW->writeIdx > 200.0) {
        localDW->writeIdx = 200.0;
      }
    }
  }

  if (localDW->writeIdx == 1.0) {
    delta_t = 0.0;
  } else {
    localB->i_tmp = static_cast<int32_T>(localDW->writeIdx - 1.0);
    localB->scale = localDW->userposBuffer[600];
    localB->absxk = localDW->userposBuffer[800];
    for (localB->loop_ub_o = 2; localB->loop_ub_o <= localB->i_tmp;
         localB->loop_ub_o++) {
      localB->scale += localDW->userposBuffer[localB->loop_ub_o + 599];
      localB->absxk += localDW->userposBuffer[localB->loop_ub_o + 799];
    }

    delta_t = (localB->scale / static_cast<real_T>(static_cast<int32_T>
                (localDW->writeIdx - 1.0)) - localB->absxk / static_cast<real_T>
               (static_cast<int32_T>(localDW->writeIdx - 1.0))) / 2.99792458E+8;
  }

  return delta_t;
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_mergeMyBus(const emxArray__GNSS_Measurement_DD_T *varargin_1,
  const emxArray__GNSS_Measurement_DD_T *varargin_2, const
  emxArray__GNSS_Measurement_DD_T *varargin_3, s_p3XDoG4hWh7L3rtSKHmAfC_DDRT_T
  *outputBus, B_MergeGNSSMeasurement_DDRTCM_T *localB)
{
  int32_T i;
  int32_T loop_ub;
  int32_T loop_ub_0;
  int32_T outputBus_size_idx_0;
  int8_T empty_non_axis_sizes_0[2];
  int8_T empty_non_axis_sizes_1[2];
  int8_T sizes_idx_1;
  boolean_T empty_non_axis_sizes;
  outputBus->time_receive = varargin_1->time_receive;
  outputBus->base_position[0] = varargin_1->base_position[0];
  outputBus->base_position[1] = varargin_1->base_position[1];
  outputBus->base_position[2] = varargin_1->base_position[2];
  if ((varargin_1->satellite_position.size[0] != 0) &&
      (varargin_1->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_position.size[1]);
  } else if ((varargin_2->satellite_position.size[0] != 0) &&
             (varargin_2->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_position.size[1]);
  } else if (varargin_2->satellite_position.size[1] >
             varargin_1->satellite_position.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_position.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_position.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_position.size[0]);
  } else if ((varargin_1->satellite_position.size[0] != 0) &&
             (varargin_1->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_position.size[0]);
  } else if ((varargin_2->satellite_position.size[0] != 0) &&
             (varargin_2->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus->satellite_position.size[0] = empty_non_axis_sizes_0[0] +
    empty_non_axis_sizes_1[0];
  outputBus->satellite_position.size[1] = sizes_idx_1;
  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      outputBus->satellite_position.data[outputBus_0 +
        outputBus->satellite_position.size[0] * i] =
        varargin_1->satellite_position.data[empty_non_axis_sizes_0[0] * i +
        outputBus_0];
    }
  }

  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      outputBus->satellite_position.data[(outputBus_0 + empty_non_axis_sizes_0[0])
        + outputBus->satellite_position.size[0] * i] =
        varargin_2->satellite_position.data[empty_non_axis_sizes_1[0] * i +
        outputBus_0];
    }
  }

  if ((varargin_1->satellite_velocity.size[0] != 0) &&
      (varargin_1->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_velocity.size[1]);
  } else if ((varargin_2->satellite_velocity.size[0] != 0) &&
             (varargin_2->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_velocity.size[1]);
  } else if (varargin_2->satellite_velocity.size[1] >
             varargin_1->satellite_velocity.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_velocity.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_velocity.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_velocity.size[0]);
  } else if ((varargin_1->satellite_velocity.size[0] != 0) &&
             (varargin_1->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_velocity.size[0]);
  } else if ((varargin_2->satellite_velocity.size[0] != 0) &&
             (varargin_2->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus->satellite_velocity.size[0] = empty_non_axis_sizes_0[0] +
    empty_non_axis_sizes_1[0];
  outputBus->satellite_velocity.size[1] = sizes_idx_1;
  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      outputBus->satellite_velocity.data[outputBus_0 +
        outputBus->satellite_velocity.size[0] * i] =
        varargin_1->satellite_velocity.data[empty_non_axis_sizes_0[0] * i +
        outputBus_0];
    }
  }

  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      outputBus->satellite_velocity.data[(outputBus_0 + empty_non_axis_sizes_0[0])
        + outputBus->satellite_velocity.size[0] * i] =
        varargin_2->satellite_velocity.data[empty_non_axis_sizes_1[0] * i +
        outputBus_0];
    }
  }

  outputBus->PRN.size = varargin_1->PRN.size + varargin_2->PRN.size;
  if (varargin_1->PRN.size - 1 >= 0) {
    std::memcpy(&outputBus->PRN.data[0], &varargin_1->PRN.data[0],
                static_cast<uint32_T>(varargin_1->PRN.size) * sizeof(uint16_T));
  }

  loop_ub = varargin_2->PRN.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->PRN.data[i + varargin_1->PRN.size] = varargin_2->PRN.data[i];
  }

  outputBus->pseudorange.size = varargin_1->pseudorange.size +
    varargin_2->pseudorange.size;
  if (varargin_1->pseudorange.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange.data[0], &varargin_1->pseudorange.data[0],
                static_cast<uint32_T>(varargin_1->pseudorange.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->pseudorange.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->pseudorange.data[i + varargin_1->pseudorange.size] =
      varargin_2->pseudorange.data[i];
  }

  outputBus->pseudorange_raw.size = varargin_1->pseudorange_raw.size +
    varargin_2->pseudorange_raw.size;
  if (varargin_1->pseudorange_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange_raw.data[0],
                &varargin_1->pseudorange_raw.data[0], static_cast<uint32_T>
                (varargin_1->pseudorange_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->pseudorange_raw.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->pseudorange_raw.data[i + varargin_1->pseudorange_raw.size] =
      varargin_2->pseudorange_raw.data[i];
  }

  outputBus->pseudorange_satclk_corrected.size =
    varargin_1->pseudorange_satclk_corrected.size +
    varargin_2->pseudorange_satclk_corrected.size;
  if (varargin_1->pseudorange_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange_satclk_corrected.data[0],
                &varargin_1->pseudorange_satclk_corrected.data[0],
                static_cast<uint32_T>
                (varargin_1->pseudorange_satclk_corrected.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->pseudorange_satclk_corrected.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->pseudorange_satclk_corrected.data[i +
      varargin_1->pseudorange_satclk_corrected.size] =
      varargin_2->pseudorange_satclk_corrected.data[i];
  }

  outputBus->deltarange.size = varargin_1->deltarange.size +
    varargin_2->deltarange.size;
  if (varargin_1->deltarange.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange.data[0], &varargin_1->deltarange.data[0],
                static_cast<uint32_T>(varargin_1->deltarange.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->deltarange.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->deltarange.data[i + varargin_1->deltarange.size] =
      varargin_2->deltarange.data[i];
  }

  outputBus->deltarange_raw.size = varargin_1->deltarange_raw.size +
    varargin_2->deltarange_raw.size;
  if (varargin_1->deltarange_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange_raw.data[0],
                &varargin_1->deltarange_raw.data[0], static_cast<uint32_T>
                (varargin_1->deltarange_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->deltarange_raw.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->deltarange_raw.data[i + varargin_1->deltarange_raw.size] =
      varargin_2->deltarange_raw.data[i];
  }

  outputBus->deltarange_satclk_corrected.size =
    varargin_1->deltarange_satclk_corrected.size +
    varargin_2->deltarange_satclk_corrected.size;
  if (varargin_1->deltarange_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange_satclk_corrected.data[0],
                &varargin_1->deltarange_satclk_corrected.data[0],
                static_cast<uint32_T>
                (varargin_1->deltarange_satclk_corrected.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->deltarange_satclk_corrected.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->deltarange_satclk_corrected.data[i +
      varargin_1->deltarange_satclk_corrected.size] =
      varargin_2->deltarange_satclk_corrected.data[i];
  }

  outputBus->variance_pseudorange.size = varargin_1->variance_pseudorange.size +
    varargin_2->variance_pseudorange.size;
  if (varargin_1->variance_pseudorange.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_pseudorange.data[0],
                &varargin_1->variance_pseudorange.data[0], static_cast<uint32_T>
                (varargin_1->variance_pseudorange.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_pseudorange.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->variance_pseudorange.data[i +
      varargin_1->variance_pseudorange.size] =
      varargin_2->variance_pseudorange.data[i];
  }

  outputBus->variance_pseudorange_measured.size =
    varargin_1->variance_pseudorange_measured.size +
    varargin_2->variance_pseudorange_measured.size;
  if (varargin_1->variance_pseudorange_measured.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_pseudorange_measured.data[0],
                &varargin_1->variance_pseudorange_measured.data[0],
                static_cast<uint32_T>
                (varargin_1->variance_pseudorange_measured.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_pseudorange_measured.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->variance_pseudorange_measured.data[i +
      varargin_1->variance_pseudorange_measured.size] =
      varargin_2->variance_pseudorange_measured.data[i];
  }

  outputBus->variance_deltarange.size = varargin_1->variance_deltarange.size +
    varargin_2->variance_deltarange.size;
  if (varargin_1->variance_deltarange.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_deltarange.data[0],
                &varargin_1->variance_deltarange.data[0], static_cast<uint32_T>
                (varargin_1->variance_deltarange.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_deltarange.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->variance_deltarange.data[i + varargin_1->variance_deltarange.size]
      = varargin_2->variance_deltarange.data[i];
  }

  outputBus->carrierphase.size = varargin_1->carrierphase.size +
    varargin_2->carrierphase.size;
  if (varargin_1->carrierphase.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase.data[0], &varargin_1->
                carrierphase.data[0], static_cast<uint32_T>
                (varargin_1->carrierphase.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->carrierphase.data[i + varargin_1->carrierphase.size] =
      varargin_2->carrierphase.data[i];
  }

  outputBus->carrierphase_raw.size = varargin_1->carrierphase_raw.size +
    varargin_2->carrierphase_raw.size;
  if (varargin_1->carrierphase_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase_raw.data[0],
                &varargin_1->carrierphase_raw.data[0], static_cast<uint32_T>
                (varargin_1->carrierphase_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase_raw.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->carrierphase_raw.data[i + varargin_1->carrierphase_raw.size] =
      varargin_2->carrierphase_raw.data[i];
  }

  outputBus->carrierphase_satclk_corrected.size =
    varargin_1->carrierphase_satclk_corrected.size +
    varargin_2->carrierphase_satclk_corrected.size;
  if (varargin_1->carrierphase_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase_satclk_corrected.data[0],
                &varargin_1->carrierphase_satclk_corrected.data[0], static_cast<
                uint32_T>(varargin_1->carrierphase_satclk_corrected.size) *
                sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase_satclk_corrected.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->carrierphase_satclk_corrected.data[i +
      varargin_1->carrierphase_satclk_corrected.size] =
      varargin_2->carrierphase_satclk_corrected.data[i];
  }

  outputBus->variance_carrierphase_measured.size =
    varargin_1->variance_carrierphase_measured.size +
    varargin_2->variance_carrierphase_measured.size;
  if (varargin_1->variance_carrierphase_measured.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_carrierphase_measured.data[0],
                &varargin_1->variance_carrierphase_measured.data[0],
                static_cast<uint32_T>
                (varargin_1->variance_carrierphase_measured.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->variance_carrierphase_measured.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->variance_carrierphase_measured.data[i +
      varargin_1->variance_carrierphase_measured.size] =
      varargin_2->variance_carrierphase_measured.data[i];
  }

  outputBus->locktime.size = varargin_1->locktime.size +
    varargin_2->locktime.size;
  if (varargin_1->locktime.size - 1 >= 0) {
    std::memcpy(&outputBus->locktime.data[0], &varargin_1->locktime.data[0],
                static_cast<uint32_T>(varargin_1->locktime.size) * sizeof
                (real32_T));
  }

  loop_ub = varargin_2->locktime.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->locktime.data[i + varargin_1->locktime.size] =
      varargin_2->locktime.data[i];
  }

  outputBus->CN0.size = varargin_1->CN0.size + varargin_2->CN0.size;
  if (varargin_1->CN0.size - 1 >= 0) {
    std::memcpy(&outputBus->CN0.data[0], &varargin_1->CN0.data[0],
                static_cast<uint32_T>(varargin_1->CN0.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->CN0.size;
  for (i = 0; i < loop_ub; i++) {
    outputBus->CN0.data[i + varargin_1->CN0.size] = varargin_2->CN0.data[i];
  }

  if ((outputBus->satellite_position.size[0] != 0) &&
      (outputBus->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(outputBus->satellite_position.size[1]);
  } else if ((varargin_3->satellite_position.size[0] != 0) &&
             (varargin_3->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_3->satellite_position.size[1]);
  } else if (varargin_3->satellite_position.size[1] >
             outputBus->satellite_position.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_3->satellite_position.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(outputBus->satellite_position.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (outputBus->satellite_position.size[0]);
  } else if ((outputBus->satellite_position.size[0] != 0) &&
             (outputBus->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (outputBus->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_3->satellite_position.size[0]);
  } else if ((varargin_3->satellite_position.size[0] != 0) &&
             (varargin_3->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_3->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus_size_idx_0 = empty_non_axis_sizes_0[0] + empty_non_axis_sizes_1[0];
  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      localB->outputBus_data[outputBus_0 + outputBus_size_idx_0 * i] =
        outputBus->satellite_position.data[empty_non_axis_sizes_0[0] * i +
        outputBus_0];
    }
  }

  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      localB->outputBus_data[(outputBus_0 + empty_non_axis_sizes_0[0]) +
        outputBus_size_idx_0 * i] = varargin_3->
        satellite_position.data[empty_non_axis_sizes_1[0] * i + outputBus_0];
    }
  }

  outputBus->satellite_position.size[0] = outputBus_size_idx_0;
  outputBus->satellite_position.size[1] = sizes_idx_1;
  loop_ub = outputBus_size_idx_0 * sizes_idx_1;
  if (loop_ub - 1 >= 0) {
    std::memcpy(&outputBus->satellite_position.data[0], &localB->outputBus_data
                [0], static_cast<uint32_T>(loop_ub) * sizeof(real_T));
  }

  if ((outputBus->satellite_velocity.size[0] != 0) &&
      (outputBus->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(outputBus->satellite_velocity.size[1]);
  } else if ((varargin_3->satellite_velocity.size[0] != 0) &&
             (varargin_3->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_3->satellite_velocity.size[1]);
  } else if (varargin_3->satellite_velocity.size[1] >
             outputBus->satellite_velocity.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_3->satellite_velocity.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(outputBus->satellite_velocity.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (outputBus->satellite_velocity.size[0]);
  } else if ((outputBus->satellite_velocity.size[0] != 0) &&
             (outputBus->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (outputBus->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_3->satellite_velocity.size[0]);
  } else if ((varargin_3->satellite_velocity.size[0] != 0) &&
             (varargin_3->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_3->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus_size_idx_0 = empty_non_axis_sizes_0[0] + empty_non_axis_sizes_1[0];
  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      localB->outputBus_data[outputBus_0 + outputBus_size_idx_0 * i] =
        outputBus->satellite_velocity.data[empty_non_axis_sizes_0[0] * i +
        outputBus_0];
    }
  }

  loop_ub = sizes_idx_1;
  for (i = 0; i < loop_ub; i++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T outputBus_0{0}; outputBus_0 < loop_ub_0; outputBus_0++) {
      localB->outputBus_data[(outputBus_0 + empty_non_axis_sizes_0[0]) +
        outputBus_size_idx_0 * i] = varargin_3->
        satellite_velocity.data[empty_non_axis_sizes_1[0] * i + outputBus_0];
    }
  }

  outputBus->satellite_velocity.size[0] = outputBus_size_idx_0;
  outputBus->satellite_velocity.size[1] = sizes_idx_1;
  loop_ub = outputBus_size_idx_0 * sizes_idx_1;
  if (loop_ub - 1 >= 0) {
    std::memcpy(&outputBus->satellite_velocity.data[0], &localB->outputBus_data
                [0], static_cast<uint32_T>(loop_ub) * sizeof(real_T));
  }

  i = outputBus->PRN.size;
  outputBus->PRN.size += varargin_3->PRN.size;
  loop_ub = varargin_3->PRN.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->PRN.data[i + outputBus_0] = varargin_3->PRN.data[outputBus_0];
  }

  i = outputBus->pseudorange.size;
  outputBus->pseudorange.size += varargin_3->pseudorange.size;
  loop_ub = varargin_3->pseudorange.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->pseudorange.data[i + outputBus_0] = varargin_3->
      pseudorange.data[outputBus_0];
  }

  i = outputBus->pseudorange_raw.size;
  outputBus->pseudorange_raw.size += varargin_3->pseudorange_raw.size;
  loop_ub = varargin_3->pseudorange_raw.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->pseudorange_raw.data[i + outputBus_0] =
      varargin_3->pseudorange_raw.data[outputBus_0];
  }

  i = outputBus->pseudorange_satclk_corrected.size;
  outputBus->pseudorange_satclk_corrected.size +=
    varargin_3->pseudorange_satclk_corrected.size;
  loop_ub = varargin_3->pseudorange_satclk_corrected.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->pseudorange_satclk_corrected.data[i + outputBus_0] =
      varargin_3->pseudorange_satclk_corrected.data[outputBus_0];
  }

  i = outputBus->deltarange.size;
  outputBus->deltarange.size += varargin_3->deltarange.size;
  loop_ub = varargin_3->deltarange.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->deltarange.data[i + outputBus_0] = varargin_3->
      deltarange.data[outputBus_0];
  }

  i = outputBus->deltarange_raw.size;
  outputBus->deltarange_raw.size += varargin_3->deltarange_raw.size;
  loop_ub = varargin_3->deltarange_raw.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->deltarange_raw.data[i + outputBus_0] =
      varargin_3->deltarange_raw.data[outputBus_0];
  }

  i = outputBus->deltarange_satclk_corrected.size;
  outputBus->deltarange_satclk_corrected.size +=
    varargin_3->deltarange_satclk_corrected.size;
  loop_ub = varargin_3->deltarange_satclk_corrected.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->deltarange_satclk_corrected.data[i + outputBus_0] =
      varargin_3->deltarange_satclk_corrected.data[outputBus_0];
  }

  i = outputBus->variance_pseudorange.size;
  outputBus->variance_pseudorange.size += varargin_3->variance_pseudorange.size;
  loop_ub = varargin_3->variance_pseudorange.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->variance_pseudorange.data[i + outputBus_0] =
      varargin_3->variance_pseudorange.data[outputBus_0];
  }

  i = outputBus->variance_pseudorange_measured.size;
  outputBus->variance_pseudorange_measured.size +=
    varargin_3->variance_pseudorange_measured.size;
  loop_ub = varargin_3->variance_pseudorange_measured.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->variance_pseudorange_measured.data[i + outputBus_0] =
      varargin_3->variance_pseudorange_measured.data[outputBus_0];
  }

  i = outputBus->variance_deltarange.size;
  outputBus->variance_deltarange.size += varargin_3->variance_deltarange.size;
  loop_ub = varargin_3->variance_deltarange.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->variance_deltarange.data[i + outputBus_0] =
      varargin_3->variance_deltarange.data[outputBus_0];
  }

  i = outputBus->carrierphase.size;
  outputBus->carrierphase.size += varargin_3->carrierphase.size;
  loop_ub = varargin_3->carrierphase.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->carrierphase.data[i + outputBus_0] =
      varargin_3->carrierphase.data[outputBus_0];
  }

  i = outputBus->carrierphase_raw.size;
  outputBus->carrierphase_raw.size += varargin_3->carrierphase_raw.size;
  loop_ub = varargin_3->carrierphase_raw.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->carrierphase_raw.data[i + outputBus_0] =
      varargin_3->carrierphase_raw.data[outputBus_0];
  }

  i = outputBus->carrierphase_satclk_corrected.size;
  outputBus->carrierphase_satclk_corrected.size +=
    varargin_3->carrierphase_satclk_corrected.size;
  loop_ub = varargin_3->carrierphase_satclk_corrected.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->carrierphase_satclk_corrected.data[i + outputBus_0] =
      varargin_3->carrierphase_satclk_corrected.data[outputBus_0];
  }

  i = outputBus->variance_carrierphase_measured.size;
  outputBus->variance_carrierphase_measured.size +=
    varargin_3->variance_carrierphase_measured.size;
  loop_ub = varargin_3->variance_carrierphase_measured.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->variance_carrierphase_measured.data[i + outputBus_0] =
      varargin_3->variance_carrierphase_measured.data[outputBus_0];
  }

  i = outputBus->locktime.size;
  outputBus->locktime.size += varargin_3->locktime.size;
  loop_ub = varargin_3->locktime.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->locktime.data[i + outputBus_0] = varargin_3->
      locktime.data[outputBus_0];
  }

  i = outputBus->CN0.size;
  outputBus->CN0.size += varargin_3->CN0.size;
  loop_ub = varargin_3->CN0.size;
  for (int32_T outputBus_0{0}; outputBus_0 < loop_ub; outputBus_0++) {
    outputBus->CN0.data[i + outputBus_0] = varargin_3->CN0.data[outputBus_0];
  }
}

// Function for MATLAB Function: '<S4>/Merge GNSS Measurement'
void DDRTCM::DDRTCM_mergeMyBus_dj(const s_p3XDoG4hWh7L3rtSKHmAfC_DDRT_T
  *varargin_1, const emxArray__GNSS_Measurement_DD_T *varargin_2,
  s_p3XDoG4hWh7L3rtSKHmAfC_DDRT_T *outputBus)
{
  int32_T loop_ub;
  int32_T loop_ub_0;
  int8_T empty_non_axis_sizes_0[2];
  int8_T empty_non_axis_sizes_1[2];
  int8_T sizes_idx_1;
  boolean_T empty_non_axis_sizes;
  outputBus->time_receive = varargin_1->time_receive;
  outputBus->base_position[0] = varargin_1->base_position[0];
  outputBus->base_position[1] = varargin_1->base_position[1];
  outputBus->base_position[2] = varargin_1->base_position[2];
  if ((varargin_1->satellite_position.size[0] != 0) &&
      (varargin_1->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_position.size[1]);
  } else if ((varargin_2->satellite_position.size[0] != 0) &&
             (varargin_2->satellite_position.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_position.size[1]);
  } else if (varargin_2->satellite_position.size[1] >
             varargin_1->satellite_position.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_position.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_position.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_position.size[0]);
  } else if ((varargin_1->satellite_position.size[0] != 0) &&
             (varargin_1->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_position.size[0]);
  } else if ((varargin_2->satellite_position.size[0] != 0) &&
             (varargin_2->satellite_position.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_position.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus->satellite_position.size[0] = empty_non_axis_sizes_0[0] +
    empty_non_axis_sizes_1[0];
  outputBus->satellite_position.size[1] = sizes_idx_1;
  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_position.data[i + outputBus->satellite_position.size
        [0] * i_0] = varargin_1->satellite_position.data[empty_non_axis_sizes_0
        [0] * i_0 + i];
    }
  }

  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_position.data[(i + empty_non_axis_sizes_0[0]) +
        outputBus->satellite_position.size[0] * i_0] =
        varargin_2->satellite_position.data[empty_non_axis_sizes_1[0] * i_0 + i];
    }
  }

  if ((varargin_1->satellite_velocity.size[0] != 0) &&
      (varargin_1->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_velocity.size[1]);
  } else if ((varargin_2->satellite_velocity.size[0] != 0) &&
             (varargin_2->satellite_velocity.size[1] != 0)) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_velocity.size[1]);
  } else if (varargin_2->satellite_velocity.size[1] >
             varargin_1->satellite_velocity.size[1]) {
    sizes_idx_1 = static_cast<int8_T>(varargin_2->satellite_velocity.size[1]);
  } else {
    sizes_idx_1 = static_cast<int8_T>(varargin_1->satellite_velocity.size[1]);
  }

  empty_non_axis_sizes = (sizes_idx_1 == 0);
  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_velocity.size[0]);
  } else if ((varargin_1->satellite_velocity.size[0] != 0) &&
             (varargin_1->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_0[0] = static_cast<int8_T>
      (varargin_1->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_0[0] = 0;
  }

  if (empty_non_axis_sizes) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_velocity.size[0]);
  } else if ((varargin_2->satellite_velocity.size[0] != 0) &&
             (varargin_2->satellite_velocity.size[1] != 0)) {
    empty_non_axis_sizes_1[0] = static_cast<int8_T>
      (varargin_2->satellite_velocity.size[0]);
  } else {
    empty_non_axis_sizes_1[0] = 0;
  }

  outputBus->satellite_velocity.size[0] = empty_non_axis_sizes_0[0] +
    empty_non_axis_sizes_1[0];
  outputBus->satellite_velocity.size[1] = sizes_idx_1;
  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_0[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_velocity.data[i + outputBus->satellite_velocity.size
        [0] * i_0] = varargin_1->satellite_velocity.data[empty_non_axis_sizes_0
        [0] * i_0 + i];
    }
  }

  loop_ub = sizes_idx_1;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    loop_ub_0 = empty_non_axis_sizes_1[0];
    for (int32_T i{0}; i < loop_ub_0; i++) {
      outputBus->satellite_velocity.data[(i + empty_non_axis_sizes_0[0]) +
        outputBus->satellite_velocity.size[0] * i_0] =
        varargin_2->satellite_velocity.data[empty_non_axis_sizes_1[0] * i_0 + i];
    }
  }

  outputBus->PRN.size = varargin_1->PRN.size + varargin_2->PRN.size;
  if (varargin_1->PRN.size - 1 >= 0) {
    std::memcpy(&outputBus->PRN.data[0], &varargin_1->PRN.data[0],
                static_cast<uint32_T>(varargin_1->PRN.size) * sizeof(uint16_T));
  }

  loop_ub = varargin_2->PRN.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->PRN.data[i_0 + varargin_1->PRN.size] = varargin_2->PRN.data[i_0];
  }

  outputBus->pseudorange.size = varargin_1->pseudorange.size +
    varargin_2->pseudorange.size;
  if (varargin_1->pseudorange.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange.data[0], &varargin_1->pseudorange.data[0],
                static_cast<uint32_T>(varargin_1->pseudorange.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->pseudorange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->pseudorange.data[i_0 + varargin_1->pseudorange.size] =
      varargin_2->pseudorange.data[i_0];
  }

  outputBus->pseudorange_raw.size = varargin_1->pseudorange_raw.size +
    varargin_2->pseudorange_raw.size;
  if (varargin_1->pseudorange_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange_raw.data[0],
                &varargin_1->pseudorange_raw.data[0], static_cast<uint32_T>
                (varargin_1->pseudorange_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->pseudorange_raw.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->pseudorange_raw.data[i_0 + varargin_1->pseudorange_raw.size] =
      varargin_2->pseudorange_raw.data[i_0];
  }

  outputBus->pseudorange_satclk_corrected.size =
    varargin_1->pseudorange_satclk_corrected.size +
    varargin_2->pseudorange_satclk_corrected.size;
  if (varargin_1->pseudorange_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->pseudorange_satclk_corrected.data[0],
                &varargin_1->pseudorange_satclk_corrected.data[0],
                static_cast<uint32_T>
                (varargin_1->pseudorange_satclk_corrected.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->pseudorange_satclk_corrected.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->pseudorange_satclk_corrected.data[i_0 +
      varargin_1->pseudorange_satclk_corrected.size] =
      varargin_2->pseudorange_satclk_corrected.data[i_0];
  }

  outputBus->deltarange.size = varargin_1->deltarange.size +
    varargin_2->deltarange.size;
  if (varargin_1->deltarange.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange.data[0], &varargin_1->deltarange.data[0],
                static_cast<uint32_T>(varargin_1->deltarange.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->deltarange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->deltarange.data[i_0 + varargin_1->deltarange.size] =
      varargin_2->deltarange.data[i_0];
  }

  outputBus->deltarange_raw.size = varargin_1->deltarange_raw.size +
    varargin_2->deltarange_raw.size;
  if (varargin_1->deltarange_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange_raw.data[0],
                &varargin_1->deltarange_raw.data[0], static_cast<uint32_T>
                (varargin_1->deltarange_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->deltarange_raw.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->deltarange_raw.data[i_0 + varargin_1->deltarange_raw.size] =
      varargin_2->deltarange_raw.data[i_0];
  }

  outputBus->deltarange_satclk_corrected.size =
    varargin_1->deltarange_satclk_corrected.size +
    varargin_2->deltarange_satclk_corrected.size;
  if (varargin_1->deltarange_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->deltarange_satclk_corrected.data[0],
                &varargin_1->deltarange_satclk_corrected.data[0],
                static_cast<uint32_T>
                (varargin_1->deltarange_satclk_corrected.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->deltarange_satclk_corrected.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->deltarange_satclk_corrected.data[i_0 +
      varargin_1->deltarange_satclk_corrected.size] =
      varargin_2->deltarange_satclk_corrected.data[i_0];
  }

  outputBus->variance_pseudorange.size = varargin_1->variance_pseudorange.size +
    varargin_2->variance_pseudorange.size;
  if (varargin_1->variance_pseudorange.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_pseudorange.data[0],
                &varargin_1->variance_pseudorange.data[0], static_cast<uint32_T>
                (varargin_1->variance_pseudorange.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_pseudorange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_pseudorange.data[i_0 +
      varargin_1->variance_pseudorange.size] =
      varargin_2->variance_pseudorange.data[i_0];
  }

  outputBus->variance_pseudorange_measured.size =
    varargin_1->variance_pseudorange_measured.size +
    varargin_2->variance_pseudorange_measured.size;
  if (varargin_1->variance_pseudorange_measured.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_pseudorange_measured.data[0],
                &varargin_1->variance_pseudorange_measured.data[0],
                static_cast<uint32_T>
                (varargin_1->variance_pseudorange_measured.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_pseudorange_measured.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_pseudorange_measured.data[i_0 +
      varargin_1->variance_pseudorange_measured.size] =
      varargin_2->variance_pseudorange_measured.data[i_0];
  }

  outputBus->variance_deltarange.size = varargin_1->variance_deltarange.size +
    varargin_2->variance_deltarange.size;
  if (varargin_1->variance_deltarange.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_deltarange.data[0],
                &varargin_1->variance_deltarange.data[0], static_cast<uint32_T>
                (varargin_1->variance_deltarange.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->variance_deltarange.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_deltarange.data[i_0 +
      varargin_1->variance_deltarange.size] =
      varargin_2->variance_deltarange.data[i_0];
  }

  outputBus->carrierphase.size = varargin_1->carrierphase.size +
    varargin_2->carrierphase.size;
  if (varargin_1->carrierphase.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase.data[0], &varargin_1->
                carrierphase.data[0], static_cast<uint32_T>
                (varargin_1->carrierphase.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->carrierphase.data[i_0 + varargin_1->carrierphase.size] =
      varargin_2->carrierphase.data[i_0];
  }

  outputBus->carrierphase_raw.size = varargin_1->carrierphase_raw.size +
    varargin_2->carrierphase_raw.size;
  if (varargin_1->carrierphase_raw.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase_raw.data[0],
                &varargin_1->carrierphase_raw.data[0], static_cast<uint32_T>
                (varargin_1->carrierphase_raw.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase_raw.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->carrierphase_raw.data[i_0 + varargin_1->carrierphase_raw.size] =
      varargin_2->carrierphase_raw.data[i_0];
  }

  outputBus->carrierphase_satclk_corrected.size =
    varargin_1->carrierphase_satclk_corrected.size +
    varargin_2->carrierphase_satclk_corrected.size;
  if (varargin_1->carrierphase_satclk_corrected.size - 1 >= 0) {
    std::memcpy(&outputBus->carrierphase_satclk_corrected.data[0],
                &varargin_1->carrierphase_satclk_corrected.data[0], static_cast<
                uint32_T>(varargin_1->carrierphase_satclk_corrected.size) *
                sizeof(real_T));
  }

  loop_ub = varargin_2->carrierphase_satclk_corrected.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->carrierphase_satclk_corrected.data[i_0 +
      varargin_1->carrierphase_satclk_corrected.size] =
      varargin_2->carrierphase_satclk_corrected.data[i_0];
  }

  outputBus->variance_carrierphase_measured.size =
    varargin_1->variance_carrierphase_measured.size +
    varargin_2->variance_carrierphase_measured.size;
  if (varargin_1->variance_carrierphase_measured.size - 1 >= 0) {
    std::memcpy(&outputBus->variance_carrierphase_measured.data[0],
                &varargin_1->variance_carrierphase_measured.data[0],
                static_cast<uint32_T>
                (varargin_1->variance_carrierphase_measured.size) * sizeof
                (real_T));
  }

  loop_ub = varargin_2->variance_carrierphase_measured.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->variance_carrierphase_measured.data[i_0 +
      varargin_1->variance_carrierphase_measured.size] =
      varargin_2->variance_carrierphase_measured.data[i_0];
  }

  outputBus->locktime.size = varargin_1->locktime.size +
    varargin_2->locktime.size;
  if (varargin_1->locktime.size - 1 >= 0) {
    std::memcpy(&outputBus->locktime.data[0], &varargin_1->locktime.data[0],
                static_cast<uint32_T>(varargin_1->locktime.size) * sizeof
                (real32_T));
  }

  loop_ub = varargin_2->locktime.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->locktime.data[i_0 + varargin_1->locktime.size] =
      varargin_2->locktime.data[i_0];
  }

  outputBus->CN0.size = varargin_1->CN0.size + varargin_2->CN0.size;
  if (varargin_1->CN0.size - 1 >= 0) {
    std::memcpy(&outputBus->CN0.data[0], &varargin_1->CN0.data[0],
                static_cast<uint32_T>(varargin_1->CN0.size) * sizeof(real_T));
  }

  loop_ub = varargin_2->CN0.size;
  for (int32_T i_0{0}; i_0 < loop_ub; i_0++) {
    outputBus->CN0.data[i_0 + varargin_1->CN0.size] = varargin_2->CN0.data[i_0];
  }
}

//
// System initialize for atomic system:
//    '<S4>/Merge GNSS Measurement'
//    '<S5>/Merge GNSS Measurement'
//
void DDRTCM::DDRTC_MergeGNSSMeasurement_Init(DW_MergeGNSSMeasurement_DDRTC_T
  *localDW)
{
  localDW->writeIdx = 1.0;
}

//
// Output and update for atomic system:
//    '<S4>/Merge GNSS Measurement'
//    '<S5>/Merge GNSS Measurement'
//
void DDRTCM::DDRTCM_MergeGNSSMeasurement(const GNSS_Measurement
  *rtu_GpsMeasurementBus, const GNSS_Measurement_size
  *rtu_GpsMeasurementBus_DIMS1, const GNSS_Measurement *rtu_GalMeasurementBus,
  const GNSS_Measurement_size *rtu_GalMeasurementBus_DIMS1, const
  GNSS_Measurement *rtu_GateMeasurementBus, const GNSS_Measurement_size
  *rtu_GateMeasurementBus_DIMS1, const gnssraw_ggto_t *rtu_GalGstGpsBus, real_T
  rtu_timeOfWeek, real_T rtu_weekNumberCounter, const parameters_gnss_t
  *rtu_ParametersGnssBus, real_T rtu_enableGGTO, boolean_T rtu_enableMerge,
  real_T *rty_deltaSystemTimesGnss, boolean_T *rty_isValidGgto,
  B_MergeGNSSMeasurement_DDRTCM_T *localB, DW_MergeGNSSMeasurement_DDRTC_T
  *localDW)
{
  *rty_isValidGgto = false;
  localB->deltaSystemTimesGnss = 0.0;
  localB->b_m = (rtu_ParametersGnssBus->gps.enable_gps &&
                 rtu_ParametersGnssBus->galileo.enable_galileo);
  if (localB->b_m && rtu_ParametersGnssBus->gate.enable_gate && rtu_enableMerge)
  {
    localB->r2 = *rtu_GpsMeasurementBus;
    localB->r4 = *rtu_GpsMeasurementBus_DIMS1;
    localB->r3 = *rtu_GalMeasurementBus;
    localB->r5 = *rtu_GalMeasurementBus_DIMS1;
    localB->galileo_measurement_temp_data = *rtu_GateMeasurementBus;
    localB->galileo_measurement_temp_elems_ = *rtu_GateMeasurementBus_DIMS1;
    emxConvertStructToEmx_GNSS_Meas(&localB->r, &localB->r2, &localB->r4);
    emxConvertStructToEmx_GNSS_Meas(&localB->r1, &localB->r3, &localB->r5);
    emxConvertStructToEmx_GNSS_Meas(&localB->galileo_measurement_temp,
      &localB->galileo_measurement_temp_data,
      &localB->galileo_measurement_temp_elems_);
    DDRTCM_mergeMyBus(&localB->r, &localB->r1, &localB->galileo_measurement_temp,
                      &localB->expl_temp_m, localB);
    localB->GnssMeasurementBus.time_receive = localB->expl_temp_m.time_receive;
    localDW->SFunction_DIMS2.satellite_position[0] =
      localB->expl_temp_m.satellite_position.size[0];
    localDW->SFunction_DIMS2.satellite_position[1] =
      localB->expl_temp_m.satellite_position.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_position.size[0] *
      localB->expl_temp_m.satellite_position.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_position[0],
                  &localB->expl_temp_m.satellite_position.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.satellite_velocity[0] =
      localB->expl_temp_m.satellite_velocity.size[0];
    localDW->SFunction_DIMS2.satellite_velocity[1] =
      localB->expl_temp_m.satellite_velocity.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_velocity.size[0] *
      localB->expl_temp_m.satellite_velocity.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_velocity[0],
                  &localB->expl_temp_m.satellite_velocity.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.PRN = localB->expl_temp_m.PRN.size;
    localB->loop_ub = localB->expl_temp_m.PRN.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.PRN[0],
                  &localB->expl_temp_m.PRN.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(uint16_T));
    }

    localDW->SFunction_DIMS2.pseudorange = localB->expl_temp_m.pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange[0],
                  &localB->expl_temp_m.pseudorange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_raw =
      localB->expl_temp_m.pseudorange_raw.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_raw[0],
                  &localB->expl_temp_m.pseudorange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_satclk_corrected =
      localB->expl_temp_m.pseudorange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_satclk_corrected[0],
                  &localB->expl_temp_m.pseudorange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange = localB->expl_temp_m.deltarange.size;
    localB->loop_ub = localB->expl_temp_m.deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange[0],
                  &localB->expl_temp_m.deltarange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_raw =
      localB->expl_temp_m.deltarange_raw.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_raw[0],
                  &localB->expl_temp_m.deltarange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_satclk_corrected =
      localB->expl_temp_m.deltarange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_satclk_corrected[0],
                  &localB->expl_temp_m.deltarange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange =
      localB->expl_temp_m.variance_pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange[0],
                  &localB->expl_temp_m.variance_pseudorange.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange_measured =
      localB->expl_temp_m.variance_pseudorange_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange_measured[0],
                  &localB->expl_temp_m.variance_pseudorange_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_deltarange =
      localB->expl_temp_m.variance_deltarange.size;
    localB->loop_ub = localB->expl_temp_m.variance_deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_deltarange[0],
                  &localB->expl_temp_m.variance_deltarange.data[0], static_cast<
                  uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase =
      localB->expl_temp_m.carrierphase.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase[0],
                  &localB->expl_temp_m.carrierphase.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_raw =
      localB->expl_temp_m.carrierphase_raw.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_raw[0],
                  &localB->expl_temp_m.carrierphase_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_satclk_corrected =
      localB->expl_temp_m.carrierphase_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_satclk_corrected[0],
                  &localB->expl_temp_m.carrierphase_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_carrierphase_measured =
      localB->expl_temp_m.variance_carrierphase_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_carrierphase_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_carrierphase_measured[0],
                  &localB->expl_temp_m.variance_carrierphase_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.locktime = localB->expl_temp_m.locktime.size;
    localB->loop_ub = localB->expl_temp_m.locktime.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.locktime[0],
                  &localB->expl_temp_m.locktime.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real32_T));
    }

    localDW->SFunction_DIMS2.CN0 = localB->expl_temp_m.CN0.size;
    localB->loop_ub = localB->expl_temp_m.CN0.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.CN0[0],
                  &localB->expl_temp_m.CN0.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localB->GnssMeasurementBus.base_position[0] =
      localB->expl_temp_m.base_position[0];
    localB->GnssMeasurementBus.base_position[1] =
      localB->expl_temp_m.base_position[1];
    localB->GnssMeasurementBus.base_position[2] =
      localB->expl_temp_m.base_position[2];
  } else if (localB->b_m && rtu_enableMerge) {
    if (!(rtu_enableGGTO != 0.0)) {
      localB->r2 = *rtu_GpsMeasurementBus;
      localB->r4 = *rtu_GpsMeasurementBus_DIMS1;
      localB->r3 = *rtu_GalMeasurementBus;
      localB->r5 = *rtu_GalMeasurementBus_DIMS1;
      emxConvertStructToEmx_GNSS_Meas(&localB->r, &localB->r2, &localB->r4);
      emxConvertStructToEmx_GNSS_Meas(&localB->r1, &localB->r3, &localB->r5);
      DDRTCM_mergeMyBus_d(&localB->r, &localB->r1, &localB->expl_temp_m);
      localB->deltaSystemTimesGnss = DDRTCM_calc_delta_T_GNSS_system
        (localB->expl_temp_m.satellite_position.data,
         localB->expl_temp_m.satellite_position.size,
         localB->expl_temp_m.PRN.data, &localB->expl_temp_m.PRN.size,
         localB->expl_temp_m.pseudorange.data,
         &localB->expl_temp_m.pseudorange.size, localB, localDW) * 2.99792458E+8;
    } else {
      *rty_isValidGgto = true;
      localB->deltaSystemTimesGnss = DDRTCM_GGTO_delta_T_GNSS
        (rtu_GalGstGpsBus->A_1G, rtu_GalGstGpsBus->A_0G, rtu_GalGstGpsBus->t_oG,
         rtu_GalGstGpsBus->WN_oG, rtu_timeOfWeek, rtu_weekNumberCounter) *
        2.99792458E+8;
    }

    if (rtu_ParametersGnssBus->enable_galileo_timebase) {
      __m128d tmp;
      localB->galileo_measurement_temp_data = *rtu_GalMeasurementBus;
      localB->galileo_measurement_temp_elems_ = *rtu_GalMeasurementBus_DIMS1;
      localB->expl_temp.time_receive = rtu_GpsMeasurementBus->time_receive;
      localB->expl_temp.satellite_position.size[0] =
        rtu_GpsMeasurementBus_DIMS1->satellite_position[0];
      localB->expl_temp.satellite_position.size[1] =
        rtu_GpsMeasurementBus_DIMS1->satellite_position[1];
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->satellite_position[0] *
        rtu_GpsMeasurementBus_DIMS1->satellite_position[1];
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.satellite_position.data[0],
                    &rtu_GpsMeasurementBus->satellite_position[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.satellite_velocity.size[0] =
        rtu_GpsMeasurementBus_DIMS1->satellite_velocity[0];
      localB->expl_temp.satellite_velocity.size[1] =
        rtu_GpsMeasurementBus_DIMS1->satellite_velocity[1];
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->satellite_velocity[0] *
        rtu_GpsMeasurementBus_DIMS1->satellite_velocity[1];
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.satellite_velocity.data[0],
                    &rtu_GpsMeasurementBus->satellite_velocity[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.PRN.size = rtu_GpsMeasurementBus_DIMS1->PRN;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->PRN;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.PRN.data[0], &rtu_GpsMeasurementBus->PRN
                    [0], static_cast<uint32_T>(localB->loop_ub) * sizeof
                    (uint16_T));
      }

      localB->expl_temp.pseudorange.size =
        rtu_GpsMeasurementBus_DIMS1->pseudorange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->pseudorange;
      localB->expl_temp_o = (rtu_GpsMeasurementBus_DIMS1->pseudorange / 2) << 1;
      localB->expl_temp_n = localB->expl_temp_o - 2;
      for (localB->i = 0; localB->i <= localB->expl_temp_n; localB->i += 2) {
        tmp = _mm_loadu_pd(&rtu_GpsMeasurementBus->pseudorange[localB->i]);
        _mm_storeu_pd(&localB->expl_temp.pseudorange.data[localB->i], _mm_sub_pd
                      (tmp, _mm_set1_pd(localB->deltaSystemTimesGnss)));
      }

      for (localB->i = localB->expl_temp_o; localB->i < localB->loop_ub;
           localB->i++) {
        localB->expl_temp.pseudorange.data[localB->i] =
          rtu_GpsMeasurementBus->pseudorange[localB->i] -
          localB->deltaSystemTimesGnss;
      }

      localB->expl_temp.pseudorange_raw.size =
        rtu_GpsMeasurementBus_DIMS1->pseudorange_raw;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->pseudorange_raw;
      localB->expl_temp_o = (rtu_GpsMeasurementBus_DIMS1->pseudorange_raw / 2) <<
        1;
      localB->expl_temp_n = localB->expl_temp_o - 2;
      for (localB->i = 0; localB->i <= localB->expl_temp_n; localB->i += 2) {
        tmp = _mm_loadu_pd(&rtu_GpsMeasurementBus->pseudorange_raw[localB->i]);
        _mm_storeu_pd(&localB->expl_temp.pseudorange_raw.data[localB->i],
                      _mm_sub_pd(tmp, _mm_set1_pd(localB->deltaSystemTimesGnss)));
      }

      for (localB->i = localB->expl_temp_o; localB->i < localB->loop_ub;
           localB->i++) {
        localB->expl_temp.pseudorange_raw.data[localB->i] =
          rtu_GpsMeasurementBus->pseudorange_raw[localB->i] -
          localB->deltaSystemTimesGnss;
      }

      localB->expl_temp.pseudorange_satclk_corrected.size =
        rtu_GpsMeasurementBus_DIMS1->pseudorange_satclk_corrected;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->pseudorange_satclk_corrected;
      localB->expl_temp_o =
        (rtu_GpsMeasurementBus_DIMS1->pseudorange_satclk_corrected / 2) << 1;
      localB->expl_temp_n = localB->expl_temp_o - 2;
      for (localB->i = 0; localB->i <= localB->expl_temp_n; localB->i += 2) {
        tmp = _mm_loadu_pd(&rtu_GpsMeasurementBus->
                           pseudorange_satclk_corrected[localB->i]);
        _mm_storeu_pd(&localB->
                      expl_temp.pseudorange_satclk_corrected.data[localB->i],
                      _mm_sub_pd(tmp, _mm_set1_pd(localB->deltaSystemTimesGnss)));
      }

      for (localB->i = localB->expl_temp_o; localB->i < localB->loop_ub;
           localB->i++) {
        localB->expl_temp.pseudorange_satclk_corrected.data[localB->i] =
          rtu_GpsMeasurementBus->pseudorange_satclk_corrected[localB->i] -
          localB->deltaSystemTimesGnss;
      }

      localB->expl_temp.deltarange.size =
        rtu_GpsMeasurementBus_DIMS1->deltarange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->deltarange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.deltarange.data[0],
                    &rtu_GpsMeasurementBus->deltarange[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.deltarange_raw.size =
        rtu_GpsMeasurementBus_DIMS1->deltarange_raw;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->deltarange_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.deltarange_raw.data[0],
                    &rtu_GpsMeasurementBus->deltarange_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.deltarange_satclk_corrected.size =
        rtu_GpsMeasurementBus_DIMS1->deltarange_satclk_corrected;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->deltarange_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.deltarange_satclk_corrected.data[0],
                    &rtu_GpsMeasurementBus->deltarange_satclk_corrected[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_pseudorange.size =
        rtu_GpsMeasurementBus_DIMS1->variance_pseudorange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->variance_pseudorange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_pseudorange.data[0],
                    &rtu_GpsMeasurementBus->variance_pseudorange[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_pseudorange_measured.size =
        rtu_GpsMeasurementBus_DIMS1->variance_pseudorange_measured;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->variance_pseudorange_measured;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_pseudorange_measured.data[0],
                    &rtu_GpsMeasurementBus->variance_pseudorange_measured[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_deltarange.size =
        rtu_GpsMeasurementBus_DIMS1->variance_deltarange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->variance_deltarange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_deltarange.data[0],
                    &rtu_GpsMeasurementBus->variance_deltarange[0], static_cast<
                    uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.carrierphase.size =
        rtu_GpsMeasurementBus_DIMS1->carrierphase;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->carrierphase;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.carrierphase.data[0],
                    &rtu_GpsMeasurementBus->carrierphase[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.carrierphase_raw.size =
        rtu_GpsMeasurementBus_DIMS1->carrierphase_raw;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->carrierphase_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.carrierphase_raw.data[0],
                    &rtu_GpsMeasurementBus->carrierphase_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.carrierphase_satclk_corrected.size =
        rtu_GpsMeasurementBus_DIMS1->carrierphase_satclk_corrected;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->carrierphase_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.carrierphase_satclk_corrected.data[0],
                    &rtu_GpsMeasurementBus->carrierphase_satclk_corrected[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_carrierphase_measured.size =
        rtu_GpsMeasurementBus_DIMS1->variance_carrierphase_measured;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->variance_carrierphase_measured;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_carrierphase_measured.data[0],
                    &rtu_GpsMeasurementBus->variance_carrierphase_measured[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.locktime.size = rtu_GpsMeasurementBus_DIMS1->locktime;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->locktime;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.locktime.data[0],
                    &rtu_GpsMeasurementBus->locktime[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real32_T));
      }

      localB->expl_temp.CN0.size = rtu_GpsMeasurementBus_DIMS1->CN0;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->CN0;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.CN0.data[0], &rtu_GpsMeasurementBus->CN0
                    [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.base_position[0] = rtu_GpsMeasurementBus->base_position
        [0];
      localB->expl_temp.base_position[1] = rtu_GpsMeasurementBus->base_position
        [1];
      localB->expl_temp.base_position[2] = rtu_GpsMeasurementBus->base_position
        [2];
    } else {
      __m128d tmp;
      localB->expl_temp.time_receive = rtu_GpsMeasurementBus->time_receive;
      localB->expl_temp.satellite_position.size[0] =
        rtu_GpsMeasurementBus_DIMS1->satellite_position[0];
      localB->expl_temp.satellite_position.size[1] =
        rtu_GpsMeasurementBus_DIMS1->satellite_position[1];
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->satellite_position[0] *
        rtu_GpsMeasurementBus_DIMS1->satellite_position[1];
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.satellite_position.data[0],
                    &rtu_GpsMeasurementBus->satellite_position[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.satellite_velocity.size[0] =
        rtu_GpsMeasurementBus_DIMS1->satellite_velocity[0];
      localB->expl_temp.satellite_velocity.size[1] =
        rtu_GpsMeasurementBus_DIMS1->satellite_velocity[1];
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->satellite_velocity[0] *
        rtu_GpsMeasurementBus_DIMS1->satellite_velocity[1];
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.satellite_velocity.data[0],
                    &rtu_GpsMeasurementBus->satellite_velocity[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.PRN.size = rtu_GpsMeasurementBus_DIMS1->PRN;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->PRN;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.PRN.data[0], &rtu_GpsMeasurementBus->PRN
                    [0], static_cast<uint32_T>(localB->loop_ub) * sizeof
                    (uint16_T));
      }

      localB->expl_temp.pseudorange.size =
        rtu_GpsMeasurementBus_DIMS1->pseudorange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->pseudorange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.pseudorange.data[0],
                    &rtu_GpsMeasurementBus->pseudorange[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.pseudorange_raw.size =
        rtu_GpsMeasurementBus_DIMS1->pseudorange_raw;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->pseudorange_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.pseudorange_raw.data[0],
                    &rtu_GpsMeasurementBus->pseudorange_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.pseudorange_satclk_corrected.size =
        rtu_GpsMeasurementBus_DIMS1->pseudorange_satclk_corrected;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->pseudorange_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.pseudorange_satclk_corrected.data[0],
                    &rtu_GpsMeasurementBus->pseudorange_satclk_corrected[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.deltarange.size =
        rtu_GpsMeasurementBus_DIMS1->deltarange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->deltarange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.deltarange.data[0],
                    &rtu_GpsMeasurementBus->deltarange[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.deltarange_raw.size =
        rtu_GpsMeasurementBus_DIMS1->deltarange_raw;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->deltarange_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.deltarange_raw.data[0],
                    &rtu_GpsMeasurementBus->deltarange_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.deltarange_satclk_corrected.size =
        rtu_GpsMeasurementBus_DIMS1->deltarange_satclk_corrected;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->deltarange_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.deltarange_satclk_corrected.data[0],
                    &rtu_GpsMeasurementBus->deltarange_satclk_corrected[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_pseudorange.size =
        rtu_GpsMeasurementBus_DIMS1->variance_pseudorange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->variance_pseudorange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_pseudorange.data[0],
                    &rtu_GpsMeasurementBus->variance_pseudorange[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_pseudorange_measured.size =
        rtu_GpsMeasurementBus_DIMS1->variance_pseudorange_measured;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->variance_pseudorange_measured;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_pseudorange_measured.data[0],
                    &rtu_GpsMeasurementBus->variance_pseudorange_measured[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_deltarange.size =
        rtu_GpsMeasurementBus_DIMS1->variance_deltarange;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->variance_deltarange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_deltarange.data[0],
                    &rtu_GpsMeasurementBus->variance_deltarange[0], static_cast<
                    uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.carrierphase.size =
        rtu_GpsMeasurementBus_DIMS1->carrierphase;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->carrierphase;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.carrierphase.data[0],
                    &rtu_GpsMeasurementBus->carrierphase[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.carrierphase_raw.size =
        rtu_GpsMeasurementBus_DIMS1->carrierphase_raw;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->carrierphase_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.carrierphase_raw.data[0],
                    &rtu_GpsMeasurementBus->carrierphase_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.carrierphase_satclk_corrected.size =
        rtu_GpsMeasurementBus_DIMS1->carrierphase_satclk_corrected;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->carrierphase_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.carrierphase_satclk_corrected.data[0],
                    &rtu_GpsMeasurementBus->carrierphase_satclk_corrected[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.variance_carrierphase_measured.size =
        rtu_GpsMeasurementBus_DIMS1->variance_carrierphase_measured;
      localB->loop_ub =
        rtu_GpsMeasurementBus_DIMS1->variance_carrierphase_measured;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.variance_carrierphase_measured.data[0],
                    &rtu_GpsMeasurementBus->variance_carrierphase_measured[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.locktime.size = rtu_GpsMeasurementBus_DIMS1->locktime;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->locktime;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.locktime.data[0],
                    &rtu_GpsMeasurementBus->locktime[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real32_T));
      }

      localB->expl_temp.CN0.size = rtu_GpsMeasurementBus_DIMS1->CN0;
      localB->loop_ub = rtu_GpsMeasurementBus_DIMS1->CN0;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->expl_temp.CN0.data[0], &rtu_GpsMeasurementBus->CN0
                    [0], static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->expl_temp.base_position[0] = rtu_GpsMeasurementBus->base_position
        [0];
      localB->expl_temp.base_position[1] = rtu_GpsMeasurementBus->base_position
        [1];
      localB->expl_temp.base_position[2] = rtu_GpsMeasurementBus->base_position
        [2];
      localB->galileo_measurement_temp_data.time_receive =
        rtu_GalMeasurementBus->time_receive;
      localB->galileo_measurement_temp_elems_.satellite_position[0] =
        rtu_GalMeasurementBus_DIMS1->satellite_position[0];
      localB->galileo_measurement_temp_elems_.satellite_position[1] =
        rtu_GalMeasurementBus_DIMS1->satellite_position[1];
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->satellite_position[0] *
        rtu_GalMeasurementBus_DIMS1->satellite_position[1];
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.satellite_position[0],
                    &rtu_GalMeasurementBus->satellite_position[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.satellite_velocity[0] =
        rtu_GalMeasurementBus_DIMS1->satellite_velocity[0];
      localB->galileo_measurement_temp_elems_.satellite_velocity[1] =
        rtu_GalMeasurementBus_DIMS1->satellite_velocity[1];
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->satellite_velocity[0] *
        rtu_GalMeasurementBus_DIMS1->satellite_velocity[1];
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.satellite_velocity[0],
                    &rtu_GalMeasurementBus->satellite_velocity[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.PRN =
        rtu_GalMeasurementBus_DIMS1->PRN;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->PRN;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.PRN[0],
                    &rtu_GalMeasurementBus->PRN[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(uint16_T));
      }

      localB->galileo_measurement_temp_elems_.pseudorange =
        rtu_GalMeasurementBus_DIMS1->pseudorange;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->pseudorange;
      localB->expl_temp_o = (rtu_GalMeasurementBus_DIMS1->pseudorange / 2) << 1;
      localB->expl_temp_n = localB->expl_temp_o - 2;
      for (localB->i = 0; localB->i <= localB->expl_temp_n; localB->i += 2) {
        tmp = _mm_loadu_pd(&rtu_GalMeasurementBus->pseudorange[localB->i]);
        _mm_storeu_pd(&localB->galileo_measurement_temp_data.pseudorange
                      [localB->i], _mm_add_pd(tmp, _mm_set1_pd
          (localB->deltaSystemTimesGnss)));
      }

      for (localB->i = localB->expl_temp_o; localB->i < localB->loop_ub;
           localB->i++) {
        localB->galileo_measurement_temp_data.pseudorange[localB->i] =
          rtu_GalMeasurementBus->pseudorange[localB->i] +
          localB->deltaSystemTimesGnss;
      }

      localB->galileo_measurement_temp_elems_.pseudorange_raw =
        rtu_GalMeasurementBus_DIMS1->pseudorange_raw;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->pseudorange_raw;
      localB->expl_temp_o = (rtu_GalMeasurementBus_DIMS1->pseudorange_raw / 2) <<
        1;
      localB->expl_temp_n = localB->expl_temp_o - 2;
      for (localB->i = 0; localB->i <= localB->expl_temp_n; localB->i += 2) {
        tmp = _mm_loadu_pd(&rtu_GalMeasurementBus->pseudorange_raw[localB->i]);
        _mm_storeu_pd(&localB->
                      galileo_measurement_temp_data.pseudorange_raw[localB->i],
                      _mm_add_pd(tmp, _mm_set1_pd(localB->deltaSystemTimesGnss)));
      }

      for (localB->i = localB->expl_temp_o; localB->i < localB->loop_ub;
           localB->i++) {
        localB->galileo_measurement_temp_data.pseudorange_raw[localB->i] =
          rtu_GalMeasurementBus->pseudorange_raw[localB->i] +
          localB->deltaSystemTimesGnss;
      }

      localB->galileo_measurement_temp_elems_.pseudorange_satclk_corrected =
        rtu_GalMeasurementBus_DIMS1->pseudorange_satclk_corrected;
      localB->loop_ub =
        rtu_GalMeasurementBus_DIMS1->pseudorange_satclk_corrected;
      localB->expl_temp_o =
        (rtu_GalMeasurementBus_DIMS1->pseudorange_satclk_corrected / 2) << 1;
      localB->expl_temp_n = localB->expl_temp_o - 2;
      for (localB->i = 0; localB->i <= localB->expl_temp_n; localB->i += 2) {
        tmp = _mm_loadu_pd(&rtu_GalMeasurementBus->
                           pseudorange_satclk_corrected[localB->i]);
        _mm_storeu_pd
          (&localB->
           galileo_measurement_temp_data.pseudorange_satclk_corrected[localB->i],
           _mm_add_pd(tmp, _mm_set1_pd(localB->deltaSystemTimesGnss)));
      }

      for (localB->i = localB->expl_temp_o; localB->i < localB->loop_ub;
           localB->i++) {
        localB->
          galileo_measurement_temp_data.pseudorange_satclk_corrected[localB->i] =
          rtu_GalMeasurementBus->pseudorange_satclk_corrected[localB->i] +
          localB->deltaSystemTimesGnss;
      }

      localB->galileo_measurement_temp_elems_.deltarange =
        rtu_GalMeasurementBus_DIMS1->deltarange;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->deltarange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.deltarange[0],
                    &rtu_GalMeasurementBus->deltarange[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.deltarange_raw =
        rtu_GalMeasurementBus_DIMS1->deltarange_raw;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->deltarange_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.deltarange_raw[0],
                    &rtu_GalMeasurementBus->deltarange_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.deltarange_satclk_corrected =
        rtu_GalMeasurementBus_DIMS1->deltarange_satclk_corrected;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->deltarange_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy
          (&localB->galileo_measurement_temp_data.deltarange_satclk_corrected[0],
           &rtu_GalMeasurementBus->deltarange_satclk_corrected[0],
           static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.variance_pseudorange =
        rtu_GalMeasurementBus_DIMS1->variance_pseudorange;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->variance_pseudorange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.variance_pseudorange
                    [0], &rtu_GalMeasurementBus->variance_pseudorange[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.variance_pseudorange_measured =
        rtu_GalMeasurementBus_DIMS1->variance_pseudorange_measured;
      localB->loop_ub =
        rtu_GalMeasurementBus_DIMS1->variance_pseudorange_measured;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy
          (&localB->galileo_measurement_temp_data.variance_pseudorange_measured
           [0], &rtu_GalMeasurementBus->variance_pseudorange_measured[0],
           static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.variance_deltarange =
        rtu_GalMeasurementBus_DIMS1->variance_deltarange;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->variance_deltarange;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.variance_deltarange[0],
                    &rtu_GalMeasurementBus->variance_deltarange[0], static_cast<
                    uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.carrierphase =
        rtu_GalMeasurementBus_DIMS1->carrierphase;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->carrierphase;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.carrierphase[0],
                    &rtu_GalMeasurementBus->carrierphase[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.carrierphase_raw =
        rtu_GalMeasurementBus_DIMS1->carrierphase_raw;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->carrierphase_raw;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.carrierphase_raw[0],
                    &rtu_GalMeasurementBus->carrierphase_raw[0],
                    static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.carrierphase_satclk_corrected =
        rtu_GalMeasurementBus_DIMS1->carrierphase_satclk_corrected;
      localB->loop_ub =
        rtu_GalMeasurementBus_DIMS1->carrierphase_satclk_corrected;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy
          (&localB->galileo_measurement_temp_data.carrierphase_satclk_corrected
           [0], &rtu_GalMeasurementBus->carrierphase_satclk_corrected[0],
           static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.variance_carrierphase_measured =
        rtu_GalMeasurementBus_DIMS1->variance_carrierphase_measured;
      localB->loop_ub =
        rtu_GalMeasurementBus_DIMS1->variance_carrierphase_measured;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy
          (&localB->
           galileo_measurement_temp_data.variance_carrierphase_measured[0],
           &rtu_GalMeasurementBus->variance_carrierphase_measured[0],
           static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_elems_.locktime =
        rtu_GalMeasurementBus_DIMS1->locktime;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->locktime;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.locktime[0],
                    &rtu_GalMeasurementBus->locktime[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real32_T));
      }

      localB->galileo_measurement_temp_elems_.CN0 =
        rtu_GalMeasurementBus_DIMS1->CN0;
      localB->loop_ub = rtu_GalMeasurementBus_DIMS1->CN0;
      if (localB->loop_ub - 1 >= 0) {
        std::memcpy(&localB->galileo_measurement_temp_data.CN0[0],
                    &rtu_GalMeasurementBus->CN0[0], static_cast<uint32_T>
                    (localB->loop_ub) * sizeof(real_T));
      }

      localB->galileo_measurement_temp_data.base_position[0] =
        rtu_GalMeasurementBus->base_position[0];
      localB->galileo_measurement_temp_data.base_position[1] =
        rtu_GalMeasurementBus->base_position[1];
      localB->galileo_measurement_temp_data.base_position[2] =
        rtu_GalMeasurementBus->base_position[2];
    }

    emxConvertStructToEmx_GNSS_Meas(&localB->galileo_measurement_temp,
      &localB->galileo_measurement_temp_data,
      &localB->galileo_measurement_temp_elems_);
    DDRTCM_mergeMyBus_dj(&localB->expl_temp, &localB->galileo_measurement_temp,
                         &localB->expl_temp_m);
    localB->GnssMeasurementBus.time_receive = localB->expl_temp_m.time_receive;
    localDW->SFunction_DIMS2.satellite_position[0] =
      localB->expl_temp_m.satellite_position.size[0];
    localDW->SFunction_DIMS2.satellite_position[1] =
      localB->expl_temp_m.satellite_position.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_position.size[0] *
      localB->expl_temp_m.satellite_position.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_position[0],
                  &localB->expl_temp_m.satellite_position.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.satellite_velocity[0] =
      localB->expl_temp_m.satellite_velocity.size[0];
    localDW->SFunction_DIMS2.satellite_velocity[1] =
      localB->expl_temp_m.satellite_velocity.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_velocity.size[0] *
      localB->expl_temp_m.satellite_velocity.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_velocity[0],
                  &localB->expl_temp_m.satellite_velocity.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.PRN = localB->expl_temp_m.PRN.size;
    localB->loop_ub = localB->expl_temp_m.PRN.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.PRN[0],
                  &localB->expl_temp_m.PRN.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(uint16_T));
    }

    localDW->SFunction_DIMS2.pseudorange = localB->expl_temp_m.pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange[0],
                  &localB->expl_temp_m.pseudorange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_raw =
      localB->expl_temp_m.pseudorange_raw.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_raw[0],
                  &localB->expl_temp_m.pseudorange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_satclk_corrected =
      localB->expl_temp_m.pseudorange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_satclk_corrected[0],
                  &localB->expl_temp_m.pseudorange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange = localB->expl_temp_m.deltarange.size;
    localB->loop_ub = localB->expl_temp_m.deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange[0],
                  &localB->expl_temp_m.deltarange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_raw =
      localB->expl_temp_m.deltarange_raw.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_raw[0],
                  &localB->expl_temp_m.deltarange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_satclk_corrected =
      localB->expl_temp_m.deltarange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_satclk_corrected[0],
                  &localB->expl_temp_m.deltarange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange =
      localB->expl_temp_m.variance_pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange[0],
                  &localB->expl_temp_m.variance_pseudorange.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange_measured =
      localB->expl_temp_m.variance_pseudorange_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange_measured[0],
                  &localB->expl_temp_m.variance_pseudorange_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_deltarange =
      localB->expl_temp_m.variance_deltarange.size;
    localB->loop_ub = localB->expl_temp_m.variance_deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_deltarange[0],
                  &localB->expl_temp_m.variance_deltarange.data[0], static_cast<
                  uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase =
      localB->expl_temp_m.carrierphase.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase[0],
                  &localB->expl_temp_m.carrierphase.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_raw =
      localB->expl_temp_m.carrierphase_raw.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_raw[0],
                  &localB->expl_temp_m.carrierphase_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_satclk_corrected =
      localB->expl_temp_m.carrierphase_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_satclk_corrected[0],
                  &localB->expl_temp_m.carrierphase_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_carrierphase_measured =
      localB->expl_temp_m.variance_carrierphase_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_carrierphase_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_carrierphase_measured[0],
                  &localB->expl_temp_m.variance_carrierphase_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.locktime = localB->expl_temp_m.locktime.size;
    localB->loop_ub = localB->expl_temp_m.locktime.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.locktime[0],
                  &localB->expl_temp_m.locktime.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real32_T));
    }

    localDW->SFunction_DIMS2.CN0 = localB->expl_temp_m.CN0.size;
    localB->loop_ub = localB->expl_temp_m.CN0.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.CN0[0],
                  &localB->expl_temp_m.CN0.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localB->GnssMeasurementBus.base_position[0] =
      localB->expl_temp_m.base_position[0];
    localB->GnssMeasurementBus.base_position[1] =
      localB->expl_temp_m.base_position[1];
    localB->GnssMeasurementBus.base_position[2] =
      localB->expl_temp_m.base_position[2];
  } else if (rtu_ParametersGnssBus->gps.enable_gps &&
             rtu_ParametersGnssBus->gate.enable_gate && rtu_enableMerge) {
    localB->r2 = *rtu_GpsMeasurementBus;
    localB->r4 = *rtu_GpsMeasurementBus_DIMS1;
    localB->r3 = *rtu_GateMeasurementBus;
    localB->r5 = *rtu_GateMeasurementBus_DIMS1;
    emxConvertStructToEmx_GNSS_Meas(&localB->r, &localB->r2, &localB->r4);
    emxConvertStructToEmx_GNSS_Meas(&localB->r1, &localB->r3, &localB->r5);
    DDRTCM_mergeMyBus_d(&localB->r, &localB->r1, &localB->expl_temp_m);
    localB->GnssMeasurementBus.time_receive = localB->expl_temp_m.time_receive;
    localDW->SFunction_DIMS2.satellite_position[0] =
      localB->expl_temp_m.satellite_position.size[0];
    localDW->SFunction_DIMS2.satellite_position[1] =
      localB->expl_temp_m.satellite_position.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_position.size[0] *
      localB->expl_temp_m.satellite_position.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_position[0],
                  &localB->expl_temp_m.satellite_position.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.satellite_velocity[0] =
      localB->expl_temp_m.satellite_velocity.size[0];
    localDW->SFunction_DIMS2.satellite_velocity[1] =
      localB->expl_temp_m.satellite_velocity.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_velocity.size[0] *
      localB->expl_temp_m.satellite_velocity.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_velocity[0],
                  &localB->expl_temp_m.satellite_velocity.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.PRN = localB->expl_temp_m.PRN.size;
    localB->loop_ub = localB->expl_temp_m.PRN.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.PRN[0],
                  &localB->expl_temp_m.PRN.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(uint16_T));
    }

    localDW->SFunction_DIMS2.pseudorange = localB->expl_temp_m.pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange[0],
                  &localB->expl_temp_m.pseudorange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_raw =
      localB->expl_temp_m.pseudorange_raw.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_raw[0],
                  &localB->expl_temp_m.pseudorange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_satclk_corrected =
      localB->expl_temp_m.pseudorange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_satclk_corrected[0],
                  &localB->expl_temp_m.pseudorange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange = localB->expl_temp_m.deltarange.size;
    localB->loop_ub = localB->expl_temp_m.deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange[0],
                  &localB->expl_temp_m.deltarange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_raw =
      localB->expl_temp_m.deltarange_raw.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_raw[0],
                  &localB->expl_temp_m.deltarange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_satclk_corrected =
      localB->expl_temp_m.deltarange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_satclk_corrected[0],
                  &localB->expl_temp_m.deltarange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange =
      localB->expl_temp_m.variance_pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange[0],
                  &localB->expl_temp_m.variance_pseudorange.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange_measured =
      localB->expl_temp_m.variance_pseudorange_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange_measured[0],
                  &localB->expl_temp_m.variance_pseudorange_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_deltarange =
      localB->expl_temp_m.variance_deltarange.size;
    localB->loop_ub = localB->expl_temp_m.variance_deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_deltarange[0],
                  &localB->expl_temp_m.variance_deltarange.data[0], static_cast<
                  uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase =
      localB->expl_temp_m.carrierphase.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase[0],
                  &localB->expl_temp_m.carrierphase.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_raw =
      localB->expl_temp_m.carrierphase_raw.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_raw[0],
                  &localB->expl_temp_m.carrierphase_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_satclk_corrected =
      localB->expl_temp_m.carrierphase_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_satclk_corrected[0],
                  &localB->expl_temp_m.carrierphase_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_carrierphase_measured =
      localB->expl_temp_m.variance_carrierphase_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_carrierphase_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_carrierphase_measured[0],
                  &localB->expl_temp_m.variance_carrierphase_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.locktime = localB->expl_temp_m.locktime.size;
    localB->loop_ub = localB->expl_temp_m.locktime.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.locktime[0],
                  &localB->expl_temp_m.locktime.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real32_T));
    }

    localDW->SFunction_DIMS2.CN0 = localB->expl_temp_m.CN0.size;
    localB->loop_ub = localB->expl_temp_m.CN0.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.CN0[0],
                  &localB->expl_temp_m.CN0.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localB->GnssMeasurementBus.base_position[0] =
      localB->expl_temp_m.base_position[0];
    localB->GnssMeasurementBus.base_position[1] =
      localB->expl_temp_m.base_position[1];
    localB->GnssMeasurementBus.base_position[2] =
      localB->expl_temp_m.base_position[2];
  } else if (rtu_ParametersGnssBus->galileo.enable_galileo &&
             rtu_ParametersGnssBus->gate.enable_gate && rtu_enableMerge) {
    localB->r2 = *rtu_GalMeasurementBus;
    localB->r4 = *rtu_GalMeasurementBus_DIMS1;
    localB->r3 = *rtu_GateMeasurementBus;
    localB->r5 = *rtu_GateMeasurementBus_DIMS1;
    emxConvertStructToEmx_GNSS_Meas(&localB->r, &localB->r2, &localB->r4);
    emxConvertStructToEmx_GNSS_Meas(&localB->r1, &localB->r3, &localB->r5);
    DDRTCM_mergeMyBus_d(&localB->r, &localB->r1, &localB->expl_temp_m);
    localB->GnssMeasurementBus.time_receive = localB->expl_temp_m.time_receive;
    localDW->SFunction_DIMS2.satellite_position[0] =
      localB->expl_temp_m.satellite_position.size[0];
    localDW->SFunction_DIMS2.satellite_position[1] =
      localB->expl_temp_m.satellite_position.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_position.size[0] *
      localB->expl_temp_m.satellite_position.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_position[0],
                  &localB->expl_temp_m.satellite_position.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.satellite_velocity[0] =
      localB->expl_temp_m.satellite_velocity.size[0];
    localDW->SFunction_DIMS2.satellite_velocity[1] =
      localB->expl_temp_m.satellite_velocity.size[1];
    localB->loop_ub = localB->expl_temp_m.satellite_velocity.size[0] *
      localB->expl_temp_m.satellite_velocity.size[1];
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.satellite_velocity[0],
                  &localB->expl_temp_m.satellite_velocity.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.PRN = localB->expl_temp_m.PRN.size;
    localB->loop_ub = localB->expl_temp_m.PRN.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.PRN[0],
                  &localB->expl_temp_m.PRN.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(uint16_T));
    }

    localDW->SFunction_DIMS2.pseudorange = localB->expl_temp_m.pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange[0],
                  &localB->expl_temp_m.pseudorange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_raw =
      localB->expl_temp_m.pseudorange_raw.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_raw[0],
                  &localB->expl_temp_m.pseudorange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.pseudorange_satclk_corrected =
      localB->expl_temp_m.pseudorange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.pseudorange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.pseudorange_satclk_corrected[0],
                  &localB->expl_temp_m.pseudorange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange = localB->expl_temp_m.deltarange.size;
    localB->loop_ub = localB->expl_temp_m.deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange[0],
                  &localB->expl_temp_m.deltarange.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_raw =
      localB->expl_temp_m.deltarange_raw.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_raw[0],
                  &localB->expl_temp_m.deltarange_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.deltarange_satclk_corrected =
      localB->expl_temp_m.deltarange_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.deltarange_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.deltarange_satclk_corrected[0],
                  &localB->expl_temp_m.deltarange_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange =
      localB->expl_temp_m.variance_pseudorange.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange[0],
                  &localB->expl_temp_m.variance_pseudorange.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_pseudorange_measured =
      localB->expl_temp_m.variance_pseudorange_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_pseudorange_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_pseudorange_measured[0],
                  &localB->expl_temp_m.variance_pseudorange_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_deltarange =
      localB->expl_temp_m.variance_deltarange.size;
    localB->loop_ub = localB->expl_temp_m.variance_deltarange.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_deltarange[0],
                  &localB->expl_temp_m.variance_deltarange.data[0], static_cast<
                  uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase =
      localB->expl_temp_m.carrierphase.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase[0],
                  &localB->expl_temp_m.carrierphase.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_raw =
      localB->expl_temp_m.carrierphase_raw.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_raw.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_raw[0],
                  &localB->expl_temp_m.carrierphase_raw.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.carrierphase_satclk_corrected =
      localB->expl_temp_m.carrierphase_satclk_corrected.size;
    localB->loop_ub = localB->expl_temp_m.carrierphase_satclk_corrected.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.carrierphase_satclk_corrected[0],
                  &localB->expl_temp_m.carrierphase_satclk_corrected.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.variance_carrierphase_measured =
      localB->expl_temp_m.variance_carrierphase_measured.size;
    localB->loop_ub = localB->expl_temp_m.variance_carrierphase_measured.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.variance_carrierphase_measured[0],
                  &localB->expl_temp_m.variance_carrierphase_measured.data[0],
                  static_cast<uint32_T>(localB->loop_ub) * sizeof(real_T));
    }

    localDW->SFunction_DIMS2.locktime = localB->expl_temp_m.locktime.size;
    localB->loop_ub = localB->expl_temp_m.locktime.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.locktime[0],
                  &localB->expl_temp_m.locktime.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real32_T));
    }

    localDW->SFunction_DIMS2.CN0 = localB->expl_temp_m.CN0.size;
    localB->loop_ub = localB->expl_temp_m.CN0.size;
    if (localB->loop_ub - 1 >= 0) {
      std::memcpy(&localB->GnssMeasurementBus.CN0[0],
                  &localB->expl_temp_m.CN0.data[0], static_cast<uint32_T>
                  (localB->loop_ub) * sizeof(real_T));
    }

    localB->GnssMeasurementBus.base_position[0] =
      localB->expl_temp_m.base_position[0];
    localB->GnssMeasurementBus.base_position[1] =
      localB->expl_temp_m.base_position[1];
    localB->GnssMeasurementBus.base_position[2] =
      localB->expl_temp_m.base_position[2];
  } else if (rtu_ParametersGnssBus->gps.enable_gps) {
    localDW->SFunction_DIMS2 = *rtu_GpsMeasurementBus_DIMS1;
    localB->GnssMeasurementBus = *rtu_GpsMeasurementBus;
  } else if (rtu_ParametersGnssBus->galileo.enable_galileo) {
    localDW->SFunction_DIMS2 = *rtu_GalMeasurementBus_DIMS1;
    localB->GnssMeasurementBus = *rtu_GalMeasurementBus;
  } else if (rtu_ParametersGnssBus->gate.enable_gate) {
    localDW->SFunction_DIMS2 = *rtu_GateMeasurementBus_DIMS1;
    localB->GnssMeasurementBus = *rtu_GateMeasurementBus;
  } else {
    localDW->SFunction_DIMS2 = *rtu_GpsMeasurementBus_DIMS1;
    localB->GnssMeasurementBus = *rtu_GpsMeasurementBus;
  }

  *rty_deltaSystemTimesGnss = localB->deltaSystemTimesGnss;
}

//
// System initialize for atomic system:
//    '<S130>/choose correction mode'
//    '<S257>/choose correction mode'
//
void DDRTCM::DDRTC_choosecorrectionmode_Init(real_T *rty_state,
  parameters_gnss_t *rty_parameters_gnss)
{
  *rty_state = 0.0;
  rty_parameters_gnss->gps.enable_gps = false;
  rty_parameters_gnss->gps.enable_gps_l1 = false;
  rty_parameters_gnss->gps.enable_gps_l2 = false;
  rty_parameters_gnss->galileo.enable_galileo = false;
  rty_parameters_gnss->galileo.enable_galileo_e1 = false;
  rty_parameters_gnss->galileo.enable_galileo_e5a = false;
  rty_parameters_gnss->galileo.enable_galileo_e5b = false;
  rty_parameters_gnss->galileo.enable_galileo_e5 = false;
  rty_parameters_gnss->gate.enable_gate = false;
  rty_parameters_gnss->gate.prn_psl1 = 0U;
  rty_parameters_gnss->gate.prn_psl2 = 0U;
  rty_parameters_gnss->gate.prn_psl3 = 0U;
  rty_parameters_gnss->gate.prn_psl4 = 0U;
  rty_parameters_gnss->gate.prn_psl5 = 0U;
  rty_parameters_gnss->gate.prn_psl6 = 0U;
  rty_parameters_gnss->gate.prn_psl7 = 0U;
  rty_parameters_gnss->gate.prn_psl8 = 0U;
  rty_parameters_gnss->gate.prn_psl9 = 0U;
  rty_parameters_gnss->elevation_mask = 0.0;
  rty_parameters_gnss->enable_galileo_timebase = false;
  rty_parameters_gnss->enable_differential_correction = false;
  rty_parameters_gnss->enable_tropospheric_correction = false;
  rty_parameters_gnss->enable_ionospheric_correction = false;
  rty_parameters_gnss->enable_SatPosVel_calculation = false;
  rty_parameters_gnss->enable_WL_correction = false;
  rty_parameters_gnss->use_measured_variance = false;
}

//
// Output and update for atomic system:
//    '<S130>/choose correction mode'
//    '<S257>/choose correction mode'
//
void DDRTCM::DDRTCM_choosecorrectionmode(boolean_T rtu_RTCM_valid, real_T
  rtu_Nr_GPS, real_T rtu_Nr_dual, real_T rtu_min_GPS_higher, real_T
  rtu_min_GPS_lower, real_T rtu_min_dual_higher, real_T rtu_min_dual_lower,
  real_T rtu_time_wait, const parameters_gnss_t *rtu_parameters_gnss_in, real_T *
  rty_state, parameters_gnss_t *rty_parameters_gnss,
  DW_choosecorrectionmode_DDRTC_T *localDW)
{
  if (localDW->temporalCounter_i1 < MAX_uint32_T) {
    localDW->temporalCounter_i1++;
  }

  // Chart: '<S130>/choose correction mode'
  if (localDW->is_active_c130_lib_GNSSPreProce == 0U) {
    localDW->is_active_c130_lib_GNSSPreProce = 1U;
    *rty_parameters_gnss = *rtu_parameters_gnss_in;
    localDW->is_c130_lib_GNSSPreProcessing = DDRTCM_IN_GPS_Klobuchar_Galileo;
  } else {
    switch (localDW->is_c130_lib_GNSSPreProcessing) {
     case DDRTCM_IN_DGPS:
      switch (localDW->is_DGPS) {
       case DDRTCM_IN_DGPS_Galileo:
        if (!rtu_RTCM_valid) {
          localDW->is_DGPS = DDRTCM_IN_waiting_for_RTCM;
          localDW->temporalCounter_i1 = 0U;
        } else if (rtu_Nr_GPS >= rtu_min_GPS_higher) {
          localDW->is_DGPS = DDRTCM_IN_DGPS_only;
        } else {
          *rty_state = 2.0;
          rty_parameters_gnss->gps.enable_gps = true;
          rty_parameters_gnss->gps.enable_gps_l1 = true;
          rty_parameters_gnss->gps.enable_gps_l2 = false;
          rty_parameters_gnss->galileo.enable_galileo = true;
          rty_parameters_gnss->enable_differential_correction = true;
          rty_parameters_gnss->enable_ionospheric_correction = false;
          rty_parameters_gnss->enable_tropospheric_correction = false;
          rty_parameters_gnss->galileo.enable_galileo_e1 = true;
          rty_parameters_gnss->galileo.enable_galileo_e5 = true;
          rty_parameters_gnss->galileo.enable_galileo_e5a = true;
          rty_parameters_gnss->galileo.enable_galileo_e5b = true;
        }
        break;

       case DDRTCM_IN_DGPS_only:
        if (!rtu_RTCM_valid) {
          localDW->is_DGPS = DDRTCM_IN_waiting_for_RTCM;
          localDW->temporalCounter_i1 = 0U;
        } else if ((rtu_Nr_GPS < rtu_min_GPS_higher) && (rtu_Nr_GPS >=
                    rtu_min_GPS_lower)) {
          localDW->is_DGPS = DDRTCM_IN_Waiting_for_more_sat;
          localDW->temporalCounter_i1 = 0U;
        } else if (rtu_Nr_GPS < rtu_min_GPS_lower) {
          localDW->is_DGPS = DDRTCM_IN_DGPS_Galileo;
        } else {
          *rty_state = 1.0;
          rty_parameters_gnss->gps.enable_gps = true;
          rty_parameters_gnss->gps.enable_gps_l1 = true;
          rty_parameters_gnss->gps.enable_gps_l2 = false;
          rty_parameters_gnss->galileo.enable_galileo = false;
          rty_parameters_gnss->enable_differential_correction = true;
          rty_parameters_gnss->enable_ionospheric_correction = false;
          rty_parameters_gnss->enable_tropospheric_correction = false;
        }
        break;

       case DDRTCM_IN_Waiting_for_more_sat:
        if (rtu_Nr_GPS < rtu_min_GPS_lower) {
          localDW->is_DGPS = DDRTCM_IN_DGPS_Galileo;
        } else if (rtu_Nr_GPS >= rtu_min_GPS_higher) {
          localDW->is_DGPS = DDRTCM_IN_DGPS_only;
        } else if (localDW->temporalCounter_i1 >= static_cast<uint32_T>(std::
                    ceil(rtu_time_wait * 10.0))) {
          localDW->is_DGPS = DDRTCM_IN_DGPS_Galileo;
        } else if (!rtu_RTCM_valid) {
          localDW->is_DGPS = DDRTCM_IN_waiting_for_RTCM;
          localDW->temporalCounter_i1 = 0U;
        } else {
          *rty_state = 1.5;
        }
        break;

       default:
        // case IN_waiting_for_RTCM:
        if (rtu_RTCM_valid) {
          localDW->is_DGPS = DDRTCM_IN_DGPS_only;
        } else if (localDW->temporalCounter_i1 >= static_cast<uint32_T>(std::
                    ceil(rtu_time_wait * 10.0))) {
          localDW->is_DGPS = DDRTCM_IN_NO_ACTIVE_CHILD;
          localDW->is_c130_lib_GNSSPreProcessing = DDRTCM_IN_Dualfrequency;
          localDW->is_Dualfrequency = DD_IN_GPS_Dualfrequency_Galileo;
        } else {
          *rty_state = 2.5;
        }
        break;
      }
      break;

     case DDRTCM_IN_Dualfrequency:
      if (rtu_RTCM_valid) {
        localDW->is_Dualfrequency = DDRTCM_IN_NO_ACTIVE_CHILD;
        localDW->is_c130_lib_GNSSPreProcessing = DDRTCM_IN_DGPS;
        localDW->is_DGPS = DDRTCM_IN_DGPS_only;
      } else {
        switch (localDW->is_Dualfrequency) {
         case DD_IN_GPS_Dualfrequency_Galileo:
          if (rtu_Nr_dual < rtu_min_dual_lower) {
            localDW->is_Dualfrequency = DDRTCM_IN_NO_ACTIVE_CHILD;
            localDW->is_c130_lib_GNSSPreProcessing =
              DDRTCM_IN_GPS_Klobuchar_Galileo;
          } else if ((rtu_Nr_dual < rtu_min_dual_higher) && (rtu_Nr_dual >=
                      rtu_min_dual_lower)) {
            localDW->is_Dualfrequency = DD_IN_Waiting_for_more_dual_sat;
            localDW->temporalCounter_i1 = 0U;
          } else {
            *rty_state = 3.0;
            rty_parameters_gnss->gps.enable_gps = true;
            rty_parameters_gnss->galileo.enable_galileo = true;
            rty_parameters_gnss->enable_differential_correction = false;
            rty_parameters_gnss->gps.enable_gps_l1 = true;
            rty_parameters_gnss->gps.enable_gps_l2 = true;
            rty_parameters_gnss->enable_ionospheric_correction = true;
            rty_parameters_gnss->enable_tropospheric_correction = true;
            rty_parameters_gnss->galileo.enable_galileo_e1 = true;
            rty_parameters_gnss->galileo.enable_galileo_e5 = true;
            rty_parameters_gnss->galileo.enable_galileo_e5a = true;
            rty_parameters_gnss->galileo.enable_galileo_e5b = true;
          }
          break;

         default:
          // case IN_Waiting_for_more_dual_sat:
          if (rtu_Nr_dual >= rtu_min_dual_higher) {
            localDW->is_Dualfrequency = DD_IN_GPS_Dualfrequency_Galileo;
          } else if ((rtu_Nr_dual < rtu_min_dual_lower) ||
                     (localDW->temporalCounter_i1 >= static_cast<uint32_T>(std::
                       ceil(rtu_time_wait * 10.0)))) {
            localDW->is_Dualfrequency = DDRTCM_IN_NO_ACTIVE_CHILD;
            localDW->is_c130_lib_GNSSPreProcessing =
              DDRTCM_IN_GPS_Klobuchar_Galileo;
          } else {
            *rty_state = 3.5;
          }
          break;
        }
      }
      break;

     default:
      // case IN_GPS_Klobuchar_Galileo:
      if (rtu_Nr_dual >= rtu_min_dual_higher) {
        localDW->is_c130_lib_GNSSPreProcessing = DDRTCM_IN_Dualfrequency;
        localDW->is_Dualfrequency = DD_IN_GPS_Dualfrequency_Galileo;
      } else if (rtu_RTCM_valid) {
        localDW->is_c130_lib_GNSSPreProcessing = DDRTCM_IN_DGPS;
        localDW->is_DGPS = DDRTCM_IN_DGPS_only;
      } else {
        *rty_state = 4.0;
        rty_parameters_gnss->gps.enable_gps = true;
        rty_parameters_gnss->galileo.enable_galileo = true;
        rty_parameters_gnss->gps.enable_gps_l1 = true;
        rty_parameters_gnss->gps.enable_gps_l2 = false;
        rty_parameters_gnss->enable_differential_correction = false;
        rty_parameters_gnss->enable_ionospheric_correction = true;
        rty_parameters_gnss->enable_tropospheric_correction = true;
        rty_parameters_gnss->galileo.enable_galileo_e1 = true;
        rty_parameters_gnss->galileo.enable_galileo_e5 = true;
        rty_parameters_gnss->galileo.enable_galileo_e5a = true;
        rty_parameters_gnss->galileo.enable_galileo_e5b = true;
      }
      break;
    }
  }

  // End of Chart: '<S130>/choose correction mode'
}

//
// Output and update for atomic system:
//    '<S21>/Measurement Epoch Splitter'
//    '<S148>/Measurement Epoch Splitter'
//
void DDRTCM::DDRTCM_MeasurementEpochSplitter(const gnssraw_measurement_t
  *rtu_measurementEpoch_Bus, real_T *rty_Nr_GPS_L1, real_T *rty_Nr_GPS_L2,
  real_T *rty_Nr_Galileo, B_MeasurementEpochSplitter_DD_T *localB)
{
  int32_T i2;
  int32_T nz;
  int32_T vlen;
  int32_T x_size_idx_1_tmp;
  for (int32_T k{0}; k < 40; k++) {
    boolean_T d;
    boolean_T e;
    d = (rtu_measurementEpoch_Bus->SVID[k] >= 1);
    e = (rtu_measurementEpoch_Bus->SVID[k] <= 37);
    localB->b_x[k] = (d && e);
    localB->d[k] = d;
    localB->e[k] = e;
  }

  nz = localB->b_x[0];
  for (int32_T k{0}; k < 39; k++) {
    nz += localB->b_x[k + 1];
  }

  i2 = 0;
  for (int32_T k{0}; k < 40; k++) {
    if (localB->d[k] && localB->e[k]) {
      i2++;
    }
  }

  vlen = i2;
  i2 = 0;
  for (int32_T k{0}; k < 40; k++) {
    if (localB->d[k] && localB->e[k]) {
      localB->f_data[i2] = static_cast<int8_T>(k + 1);
      i2++;
    }
  }

  for (int32_T k{0}; k < vlen; k++) {
    for (i2 = 0; i2 < 5; i2++) {
      localB->c_x_data[i2 + 5 * k] = (rtu_measurementEpoch_Bus->Type
        [(localB->f_data[k] - 1) * 5 + i2] == 3);
    }
  }

  x_size_idx_1_tmp = static_cast<int8_T>(vlen);
  if (static_cast<int8_T>(vlen) - 1 >= 0) {
    std::memset(&localB->d[0], 0, static_cast<uint32_T>(static_cast<int8_T>(vlen))
                * sizeof(boolean_T));
  }

  i2 = 1;
  for (int32_T k{0}; k < vlen; k++) {
    int32_T a;
    int32_T ix;
    boolean_T exitg1;
    a = i2 + 4;
    ix = i2;
    i2 += 5;
    exitg1 = false;
    while ((!exitg1) && (ix <= a)) {
      if (localB->c_x_data[ix - 1]) {
        localB->d[k] = true;
        exitg1 = true;
      } else {
        ix++;
      }
    }
  }

  if (static_cast<int8_T>(vlen) == 0) {
    i2 = 0;
  } else {
    i2 = localB->d[0];
    for (int32_T k{2}; k <= x_size_idx_1_tmp; k++) {
      i2 += localB->d[k - 1];
    }
  }

  for (int32_T k{0}; k < 40; k++) {
    localB->b_x[k] = ((rtu_measurementEpoch_Bus->SVID[k] >= 71) &&
                      (rtu_measurementEpoch_Bus->SVID[k] <= 102));
  }

  vlen = localB->b_x[0];
  for (int32_T k{0}; k < 39; k++) {
    vlen += localB->b_x[k + 1];
  }

  *rty_Nr_GPS_L1 = nz;
  *rty_Nr_GPS_L2 = i2;
  *rty_Nr_Galileo = vlen;
}

//
// Output and update for atomic system:
//    '<S4>/mergeDiffCorrections'
//    '<S5>/mergeDiffCorrections'
//
void DDRTCM::DDRTCM_mergeDiffCorrections(const real_T rtu_gpsDiff[40], const
  uint16_T rtu_gpsSat[40], const int32_T *rtu_gpsSat_DIMS1, const real_T
  rtu_galDiff[40], const uint16_T rtu_galSat[40], const int32_T
  *rtu_galSat_DIMS1, real_T rty_pseudorangeCorrections[40], uint16_T
  rty_SVIDCorrections[40])
{
  int32_T loop_ub;
  int8_T h_data[40];
  for (int32_T i{0}; i < 40; i++) {
    rty_pseudorangeCorrections[i] = 0.0;
    rty_SVIDCorrections[i] = MAX_uint16_T;
  }

  if (*rtu_gpsSat_DIMS1 < 1) {
    loop_ub = -1;
  } else {
    loop_ub = *rtu_gpsSat_DIMS1 - 1;
  }

  if (loop_ub >= 0) {
    std::memcpy(&rty_SVIDCorrections[0], &rtu_gpsSat[0], static_cast<uint32_T>
                (loop_ub + 1) * sizeof(uint16_T));
  }

  loop_ub = static_cast<int8_T>(*rtu_galSat_DIMS1) - 1;
  for (int32_T i{0}; i <= loop_ub; i++) {
    h_data[i] = static_cast<int8_T>(static_cast<int8_T>(i + static_cast<int8_T>(*
      rtu_gpsSat_DIMS1)) + 1);
  }

  if (*rtu_galSat_DIMS1 < 1) {
    loop_ub = -1;
  } else {
    loop_ub = *rtu_galSat_DIMS1 - 1;
  }

  for (int32_T i{0}; i <= loop_ub; i++) {
    rty_SVIDCorrections[h_data[i] - 1] = rtu_galSat[i];
  }

  if (*rtu_gpsSat_DIMS1 < 1) {
    loop_ub = -1;
  } else {
    loop_ub = *rtu_gpsSat_DIMS1 - 1;
  }

  if (loop_ub >= 0) {
    std::memcpy(&rty_pseudorangeCorrections[0], &rtu_gpsDiff[0],
                static_cast<uint32_T>(loop_ub + 1) * sizeof(real_T));
  }

  if (*rtu_galSat_DIMS1 < 1) {
    loop_ub = -1;
  } else {
    loop_ub = *rtu_galSat_DIMS1 - 1;
  }

  for (int32_T i{0}; i <= loop_ub; i++) {
    rty_pseudorangeCorrections[h_data[i] - 1] = rtu_galDiff[i];
  }
}

// Function for MATLAB Function: '<S2>/Intersect'
void DDRTCM::DDRTCM_do_vectors_e3(const uint16_T a_data[], const int32_T *a_size,
  const uint16_T b_data[], const int32_T *b_size, uint16_T c_data[], int32_T
  *c_size, int32_T ia_data[], int32_T *ia_size, int32_T ib_data[], int32_T
  *ib_size)
{
  int32_T iafirst;
  int32_T ialast;
  int32_T ibfirst;
  int32_T iblast;
  int32_T nc;
  int32_T ncmax;
  if (*a_size <= *b_size) {
    ncmax = *a_size;
  } else {
    ncmax = *b_size;
  }

  *c_size = ncmax;
  *ia_size = ncmax;
  *ib_size = ncmax;
  nc = 0;
  iafirst = 0;
  ialast = 1;
  ibfirst = 0;
  iblast = 1;
  while ((ialast <= *a_size) && (iblast <= *b_size)) {
    int32_T b_ialast;
    int32_T b_iblast;
    uint16_T ak;
    uint16_T bk;
    b_ialast = ialast;
    ak = a_data[ialast - 1];
    while ((b_ialast < *a_size) && (a_data[b_ialast] == ak)) {
      b_ialast++;
    }

    ialast = b_ialast;
    b_iblast = iblast;
    bk = b_data[iblast - 1];
    while ((b_iblast < *b_size) && (b_data[b_iblast] == bk)) {
      b_iblast++;
    }

    iblast = b_iblast;
    if (ak == bk) {
      nc++;
      c_data[nc - 1] = ak;
      ia_data[nc - 1] = iafirst + 1;
      ib_data[nc - 1] = ibfirst + 1;
      ialast = b_ialast + 1;
      iafirst = b_ialast;
      iblast = b_iblast + 1;
      ibfirst = b_iblast;
    } else if (ak < bk) {
      ialast = b_ialast + 1;
      iafirst = b_ialast;
    } else {
      iblast = b_iblast + 1;
      ibfirst = b_iblast;
    }
  }

  if (ncmax > 0) {
    if (nc < 1) {
      *ia_size = 0;
      *ib_size = 0;
      *c_size = 0;
    } else {
      *ia_size = nc;
      *ib_size = nc;
      *c_size = nc;
    }
  }
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
boolean_T DDRTCM::DDRTCM_any_jj(const boolean_T x_data[], const int32_T *x_size)
{
  int32_T ix;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  ix = 1;
  exitg1 = false;
  while ((!exitg1) && (ix <= *x_size)) {
    if (x_data[ix - 1]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
int32_T DDRTCM::DDRTCM_combineVectorElements_n(const boolean_T x[40])
{
  int32_T y;
  y = x[0];
  for (int32_T k{0}; k < 39; k++) {
    y += x[k + 1];
  }

  return y;
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_eml_float_colon(real_T b, real_T y_data[], int32_T y_size[2])
{
  real_T apnd;
  real_T cdiff;
  real_T ndbl;
  ndbl = std::floor((b - 0.1) / 0.1 + 0.5);
  apnd = ndbl * 0.1 + 0.1;
  cdiff = apnd - b;
  if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.1, std::abs(b))) {
    ndbl++;
    apnd = b;
  } else if (cdiff > 0.0) {
    apnd = (ndbl - 1.0) * 0.1 + 0.1;
  } else {
    ndbl++;
  }

  y_size[0] = 1;
  y_size[1] = static_cast<int32_T>(ndbl);
  if (static_cast<int32_T>(ndbl) > 0) {
    y_data[0] = 0.1;
    if (static_cast<int32_T>(ndbl) > 1) {
      int32_T nm1d2;
      y_data[static_cast<int32_T>(ndbl) - 1] = apnd;
      nm1d2 = static_cast<uint8_T>(static_cast<int32_T>(ndbl) - 1) >> 1;
      for (int32_T k{0}; k <= nm1d2 - 2; k++) {
        cdiff = (static_cast<real_T>(k) + 1.0) * 0.1;
        y_data[k + 1] = cdiff + 0.1;
        y_data[(static_cast<int32_T>(ndbl) - k) - 2] = apnd - cdiff;
      }

      if (nm1d2 << 1 == static_cast<int32_T>(ndbl) - 1) {
        y_data[nm1d2] = (apnd + 0.1) / 2.0;
      } else {
        cdiff = static_cast<real_T>(nm1d2) * 0.1;
        y_data[nm1d2] = cdiff + 0.1;
        y_data[nm1d2 + 1] = apnd - cdiff;
      }
    }
  }
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
real_T DDRTCM::DDRTCM_xnrm2_d(int32_T n, const real_T x_data[], int32_T ix0)
{
  real_T y;
  y = 0.0;
  if (n >= 1) {
    if (n == 1) {
      y = std::abs(x_data[ix0 - 1]);
    } else {
      DDRTCM_B.scale = 3.3121686421112381E-170;
      DDRTCM_B.kend = (ix0 + n) - 1;
      for (DDRTCM_B.k_m = ix0; DDRTCM_B.k_m <= DDRTCM_B.kend; DDRTCM_B.k_m++) {
        DDRTCM_B.absxk = std::abs(x_data[DDRTCM_B.k_m - 1]);
        if (DDRTCM_B.absxk > DDRTCM_B.scale) {
          DDRTCM_B.t = DDRTCM_B.scale / DDRTCM_B.absxk;
          y = y * DDRTCM_B.t * DDRTCM_B.t + 1.0;
          DDRTCM_B.scale = DDRTCM_B.absxk;
        } else {
          DDRTCM_B.t = DDRTCM_B.absxk / DDRTCM_B.scale;
          y += DDRTCM_B.t * DDRTCM_B.t;
        }
      }

      y = DDRTCM_B.scale * std::sqrt(y);
    }
  }

  return y;
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_qrsolve_b(const real_T A_data[], const int32_T A_size[2],
  const real_T B_data[], const int32_T *B_size, real_T Y[2], int32_T *rankA)
{
  __m128d tmp_0;
  DDRTCM_B.minmn = A_size[0];
  DDRTCM_B.b_A_size[0] = A_size[0];
  DDRTCM_B.minmana = A_size[0] << 1;
  if (DDRTCM_B.minmana - 1 >= 0) {
    std::memcpy(&DDRTCM_B.b_A_data[0], &A_data[0], static_cast<uint32_T>
                (DDRTCM_B.minmana) * sizeof(real_T));
  }

  if (A_size[0] <= 2) {
    DDRTCM_B.minmana = A_size[0];
  } else {
    DDRTCM_B.minmana = 2;
  }

  if (DDRTCM_B.minmana - 1 >= 0) {
    std::memset(&DDRTCM_B.tau_data[0], 0, static_cast<uint32_T>(DDRTCM_B.minmana)
                * sizeof(real_T));
  }

  if (A_size[0] == 0) {
    DDRTCM_B.jpvt[0] = 1;
    DDRTCM_B.jpvt[1] = 2;
  } else {
    DDRTCM_B.jpvt[0] = 1;
    DDRTCM_B.jpvt[1] = 2;
    if (DDRTCM_B.minmana - 1 >= 0) {
      std::memset(&DDRTCM_B.tau_data[0], 0, static_cast<uint32_T>
                  (DDRTCM_B.minmana) * sizeof(real_T));
    }

    DDRTCM_B.minmana = A_size[0];
    DDRTCM_B.work[0] = 0.0;
    DDRTCM_B.b_c = DDRTCM_xnrm2_d(A_size[0], A_data, 1);
    DDRTCM_B.vn2[0] = DDRTCM_B.b_c;
    DDRTCM_B.vn1[0] = DDRTCM_B.b_c;
    DDRTCM_B.work[1] = 0.0;
    DDRTCM_B.b_c = DDRTCM_xnrm2_d(A_size[0], A_data, A_size[0] + 1);
    DDRTCM_B.vn2[1] = DDRTCM_B.b_c;
    DDRTCM_B.vn1[1] = DDRTCM_B.b_c;
    if (A_size[0] <= 2) {
      DDRTCM_B.b_A = A_size[0];
    } else {
      DDRTCM_B.b_A = 2;
    }

    for (DDRTCM_B.e_i = 0; DDRTCM_B.e_i < DDRTCM_B.b_A; DDRTCM_B.e_i++) {
      DDRTCM_B.jA = DDRTCM_B.e_i * DDRTCM_B.minmana;
      DDRTCM_B.ii = DDRTCM_B.jA + DDRTCM_B.e_i;
      DDRTCM_B.mmi = DDRTCM_B.minmn - DDRTCM_B.e_i;
      DDRTCM_B.itemp = 0;
      if ((2 - DDRTCM_B.e_i > 1) && (std::abs(DDRTCM_B.vn1[1]) > std::abs
           (DDRTCM_B.vn1[DDRTCM_B.e_i]))) {
        DDRTCM_B.itemp = 1;
      }

      DDRTCM_B.pvt = DDRTCM_B.e_i + DDRTCM_B.itemp;
      if (DDRTCM_B.pvt != DDRTCM_B.e_i) {
        DDRTCM_B.ix = DDRTCM_B.pvt * DDRTCM_B.minmana;
        for (DDRTCM_B.d_k = 0; DDRTCM_B.d_k < DDRTCM_B.minmn; DDRTCM_B.d_k++) {
          DDRTCM_B.temp_tmp = DDRTCM_B.ix + DDRTCM_B.d_k;
          DDRTCM_B.temp = DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp];
          DDRTCM_B.itemp = DDRTCM_B.jA + DDRTCM_B.d_k;
          DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp] =
            DDRTCM_B.b_A_data[DDRTCM_B.itemp];
          DDRTCM_B.b_A_data[DDRTCM_B.itemp] = DDRTCM_B.temp;
        }

        DDRTCM_B.itemp = DDRTCM_B.jpvt[DDRTCM_B.pvt];
        DDRTCM_B.jpvt[DDRTCM_B.pvt] = DDRTCM_B.jpvt[DDRTCM_B.e_i];
        DDRTCM_B.jpvt[DDRTCM_B.e_i] = static_cast<int8_T>(DDRTCM_B.itemp);
        DDRTCM_B.vn1[DDRTCM_B.pvt] = DDRTCM_B.vn1[DDRTCM_B.e_i];
        DDRTCM_B.vn2[DDRTCM_B.pvt] = DDRTCM_B.vn2[DDRTCM_B.e_i];
      }

      if (DDRTCM_B.e_i + 1 < DDRTCM_B.minmn) {
        DDRTCM_B.b_c = DDRTCM_B.b_A_data[DDRTCM_B.ii];
        DDRTCM_B.pvt = DDRTCM_B.ii + 2;
        DDRTCM_B.tau_data[DDRTCM_B.e_i] = 0.0;
        if (DDRTCM_B.mmi > 0) {
          DDRTCM_B.temp = DDRTCM_xnrm2_d(DDRTCM_B.mmi - 1, DDRTCM_B.b_A_data,
            DDRTCM_B.ii + 2);
          if (DDRTCM_B.temp != 0.0) {
            DDRTCM_B.temp = rt_hypotd_snf(DDRTCM_B.b_A_data[DDRTCM_B.ii],
              DDRTCM_B.temp);
            if (DDRTCM_B.b_A_data[DDRTCM_B.ii] >= 0.0) {
              DDRTCM_B.temp = -DDRTCM_B.temp;
            }

            if (std::abs(DDRTCM_B.temp) < 1.0020841800044864E-292) {
              DDRTCM_B.ix = 0;
              DDRTCM_B.d_k = DDRTCM_B.ii + DDRTCM_B.mmi;
              do {
                DDRTCM_B.ix++;
                DDRTCM_B.itemp = (((((DDRTCM_B.d_k - DDRTCM_B.ii) - 1) / 2) << 1)
                                  + DDRTCM_B.ii) + 2;
                DDRTCM_B.jA = DDRTCM_B.itemp - 2;
                for (DDRTCM_B.temp_tmp = DDRTCM_B.pvt; DDRTCM_B.temp_tmp <=
                     DDRTCM_B.jA; DDRTCM_B.temp_tmp += 2) {
                  tmp_0 = _mm_loadu_pd(&DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1]);
                  _mm_storeu_pd(&DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1],
                                _mm_mul_pd(tmp_0, _mm_set1_pd
                    (9.9792015476736E+291)));
                }

                for (DDRTCM_B.temp_tmp = DDRTCM_B.itemp; DDRTCM_B.temp_tmp <=
                     DDRTCM_B.d_k; DDRTCM_B.temp_tmp++) {
                  DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1] *=
                    9.9792015476736E+291;
                }

                DDRTCM_B.temp *= 9.9792015476736E+291;
                DDRTCM_B.b_c *= 9.9792015476736E+291;
              } while ((std::abs(DDRTCM_B.temp) < 1.0020841800044864E-292) &&
                       (DDRTCM_B.ix < 20));

              DDRTCM_B.temp = rt_hypotd_snf(DDRTCM_B.b_c, DDRTCM_xnrm2_d
                (DDRTCM_B.mmi - 1, DDRTCM_B.b_A_data, DDRTCM_B.ii + 2));
              if (DDRTCM_B.b_c >= 0.0) {
                DDRTCM_B.temp = -DDRTCM_B.temp;
              }

              DDRTCM_B.tau_data[DDRTCM_B.e_i] = (DDRTCM_B.temp - DDRTCM_B.b_c) /
                DDRTCM_B.temp;
              DDRTCM_B.b_c = 1.0 / (DDRTCM_B.b_c - DDRTCM_B.temp);
              DDRTCM_B.itemp = (((((DDRTCM_B.d_k - DDRTCM_B.ii) - 1) / 2) << 1)
                                + DDRTCM_B.ii) + 2;
              DDRTCM_B.jA = DDRTCM_B.itemp - 2;
              for (DDRTCM_B.temp_tmp = DDRTCM_B.pvt; DDRTCM_B.temp_tmp <=
                   DDRTCM_B.jA; DDRTCM_B.temp_tmp += 2) {
                tmp_0 = _mm_loadu_pd(&DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1]);
                _mm_storeu_pd(&DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1],
                              _mm_mul_pd(tmp_0, _mm_set1_pd(DDRTCM_B.b_c)));
              }

              for (DDRTCM_B.temp_tmp = DDRTCM_B.itemp; DDRTCM_B.temp_tmp <=
                   DDRTCM_B.d_k; DDRTCM_B.temp_tmp++) {
                DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1] *= DDRTCM_B.b_c;
              }

              for (DDRTCM_B.itemp = 0; DDRTCM_B.itemp < DDRTCM_B.ix;
                   DDRTCM_B.itemp++) {
                DDRTCM_B.temp *= 1.0020841800044864E-292;
              }

              DDRTCM_B.b_c = DDRTCM_B.temp;
            } else {
              DDRTCM_B.tau_data[DDRTCM_B.e_i] = (DDRTCM_B.temp -
                DDRTCM_B.b_A_data[DDRTCM_B.ii]) / DDRTCM_B.temp;
              DDRTCM_B.b_c = 1.0 / (DDRTCM_B.b_A_data[DDRTCM_B.ii] -
                                    DDRTCM_B.temp);
              DDRTCM_B.ix = DDRTCM_B.ii + DDRTCM_B.mmi;
              DDRTCM_B.itemp = (((((DDRTCM_B.ix - DDRTCM_B.ii) - 1) / 2) << 1) +
                                DDRTCM_B.ii) + 2;
              DDRTCM_B.jA = DDRTCM_B.itemp - 2;
              for (DDRTCM_B.d_k = DDRTCM_B.pvt; DDRTCM_B.d_k <= DDRTCM_B.jA;
                   DDRTCM_B.d_k += 2) {
                tmp_0 = _mm_loadu_pd(&DDRTCM_B.b_A_data[DDRTCM_B.d_k - 1]);
                _mm_storeu_pd(&DDRTCM_B.b_A_data[DDRTCM_B.d_k - 1], _mm_mul_pd
                              (tmp_0, _mm_set1_pd(DDRTCM_B.b_c)));
              }

              for (DDRTCM_B.d_k = DDRTCM_B.itemp; DDRTCM_B.d_k <= DDRTCM_B.ix;
                   DDRTCM_B.d_k++) {
                DDRTCM_B.b_A_data[DDRTCM_B.d_k - 1] *= DDRTCM_B.b_c;
              }

              DDRTCM_B.b_c = DDRTCM_B.temp;
            }
          }
        }

        DDRTCM_B.b_A_data[DDRTCM_B.ii] = DDRTCM_B.b_c;
      } else {
        DDRTCM_B.tau_data[DDRTCM_B.e_i] = 0.0;
      }

      if (DDRTCM_B.e_i + 1 < 2) {
        DDRTCM_B.temp = DDRTCM_B.b_A_data[DDRTCM_B.ii];
        DDRTCM_B.b_A_data[DDRTCM_B.ii] = 1.0;
        DDRTCM_B.jA = (DDRTCM_B.ii + DDRTCM_B.minmana) + 1;
        if (DDRTCM_B.tau_data[0] != 0.0) {
          DDRTCM_B.itemp = DDRTCM_B.mmi - 1;
          DDRTCM_B.pvt = (DDRTCM_B.ii + DDRTCM_B.mmi) - 1;
          while ((DDRTCM_B.itemp + 1 > 0) && (DDRTCM_B.b_A_data[DDRTCM_B.pvt] ==
                  0.0)) {
            DDRTCM_B.itemp--;
            DDRTCM_B.pvt--;
          }

          DDRTCM_B.pvt = 1;
          DDRTCM_B.ix = DDRTCM_B.jA;
          int32_T exitg1;
          do {
            exitg1 = 0;
            if (DDRTCM_B.ix <= DDRTCM_B.jA + DDRTCM_B.itemp) {
              if (DDRTCM_B.b_A_data[DDRTCM_B.ix - 1] != 0.0) {
                exitg1 = 1;
              } else {
                DDRTCM_B.ix++;
              }
            } else {
              DDRTCM_B.pvt = 0;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        } else {
          DDRTCM_B.itemp = -1;
          DDRTCM_B.pvt = 0;
        }

        if (DDRTCM_B.itemp + 1 > 0) {
          if (DDRTCM_B.pvt != 0) {
            DDRTCM_B.work[0] = 0.0;
            DDRTCM_B.ix = 0;
            for (DDRTCM_B.d_k = DDRTCM_B.jA; DDRTCM_B.minmana < 0 ? DDRTCM_B.d_k
                 >= DDRTCM_B.jA : DDRTCM_B.d_k <= DDRTCM_B.jA; DDRTCM_B.d_k +=
                 DDRTCM_B.minmana) {
              DDRTCM_B.b_c = 0.0;
              DDRTCM_B.temp_tmp = DDRTCM_B.d_k + DDRTCM_B.itemp;
              for (DDRTCM_B.ia = DDRTCM_B.d_k; DDRTCM_B.ia <= DDRTCM_B.temp_tmp;
                   DDRTCM_B.ia++) {
                DDRTCM_B.b_c += DDRTCM_B.b_A_data[(DDRTCM_B.ii + DDRTCM_B.ia) -
                  DDRTCM_B.d_k] * DDRTCM_B.b_A_data[DDRTCM_B.ia - 1];
              }

              DDRTCM_B.work[DDRTCM_B.ix] += DDRTCM_B.b_c;
              DDRTCM_B.ix++;
            }
          }

          if (!(-DDRTCM_B.tau_data[0] == 0.0)) {
            for (DDRTCM_B.ix = 0; DDRTCM_B.ix < DDRTCM_B.pvt; DDRTCM_B.ix++) {
              if (DDRTCM_B.work[0] != 0.0) {
                DDRTCM_B.b_c = DDRTCM_B.work[0] * -DDRTCM_B.tau_data[0];
                DDRTCM_B.d_k = DDRTCM_B.itemp + DDRTCM_B.jA;
                for (DDRTCM_B.temp_tmp = DDRTCM_B.jA; DDRTCM_B.temp_tmp <=
                     DDRTCM_B.d_k; DDRTCM_B.temp_tmp++) {
                  DDRTCM_B.b_A_data[DDRTCM_B.temp_tmp - 1] += DDRTCM_B.b_A_data
                    [(DDRTCM_B.ii + DDRTCM_B.temp_tmp) - DDRTCM_B.jA] *
                    DDRTCM_B.b_c;
                }
              }

              DDRTCM_B.jA += DDRTCM_B.minmana;
            }
          }
        }

        DDRTCM_B.b_A_data[DDRTCM_B.ii] = DDRTCM_B.temp;
      }

      for (DDRTCM_B.ii = DDRTCM_B.e_i + 2; DDRTCM_B.ii < 3; DDRTCM_B.ii++) {
        DDRTCM_B.temp = DDRTCM_B.vn2[1];
        DDRTCM_B.b_c = DDRTCM_B.vn1[1];
        DDRTCM_B.itemp = DDRTCM_B.e_i + DDRTCM_B.minmana;
        if (DDRTCM_B.vn1[1] != 0.0) {
          DDRTCM_B.b_c = std::abs(DDRTCM_B.b_A_data[DDRTCM_B.itemp]) /
            DDRTCM_B.vn1[1];
          DDRTCM_B.b_c = 1.0 - DDRTCM_B.b_c * DDRTCM_B.b_c;
          if (DDRTCM_B.b_c < 0.0) {
            DDRTCM_B.b_c = 0.0;
          }

          DDRTCM_B.temp2 = DDRTCM_B.vn1[1] / DDRTCM_B.vn2[1];
          DDRTCM_B.temp2 = DDRTCM_B.temp2 * DDRTCM_B.temp2 * DDRTCM_B.b_c;
          if (DDRTCM_B.temp2 <= 1.4901161193847656E-8) {
            if (DDRTCM_B.e_i + 1 < DDRTCM_B.minmn) {
              DDRTCM_B.b_c = DDRTCM_xnrm2_d(DDRTCM_B.mmi - 1, DDRTCM_B.b_A_data,
                DDRTCM_B.itemp + 2);
              DDRTCM_B.temp = DDRTCM_B.b_c;
            } else {
              DDRTCM_B.b_c = 0.0;
              DDRTCM_B.temp = 0.0;
            }
          } else {
            DDRTCM_B.b_c = DDRTCM_B.vn1[1] * std::sqrt(DDRTCM_B.b_c);
          }
        }

        DDRTCM_B.vn2[1] = DDRTCM_B.temp;
        DDRTCM_B.vn1[1] = DDRTCM_B.b_c;
      }
    }
  }

  *rankA = 0;
  if (A_size[0] < 2) {
    DDRTCM_B.minmn = A_size[0];
    DDRTCM_B.minmana = 2;
  } else {
    DDRTCM_B.minmn = 2;
    DDRTCM_B.minmana = A_size[0];
  }

  if (DDRTCM_B.minmn > 0) {
    DDRTCM_B.temp = 2.2204460492503131E-15 * static_cast<real_T>
      (DDRTCM_B.minmana) * std::abs(DDRTCM_B.b_A_data[0]);
    while ((*rankA < DDRTCM_B.minmn) && (!(std::abs
             (DDRTCM_B.b_A_data[DDRTCM_B.b_A_size[0] * *rankA + *rankA]) <=
             DDRTCM_B.temp))) {
      (*rankA)++;
    }
  }

  DDRTCM_B.minmn = 0;
  if (A_size[0] <= 2) {
    DDRTCM_B.minmana = A_size[0];
  } else {
    DDRTCM_B.minmana = 2;
  }

  if (DDRTCM_B.minmana > 0) {
    for (DDRTCM_B.b_A = 0; DDRTCM_B.b_A < DDRTCM_B.minmana; DDRTCM_B.b_A++) {
      if (DDRTCM_B.b_A_data[DDRTCM_B.b_A_size[0] * DDRTCM_B.b_A + DDRTCM_B.b_A]
          != 0.0) {
        DDRTCM_B.minmn++;
      }
    }
  }

  DDRTCM_B.minmana = *B_size;
  if (DDRTCM_B.minmana - 1 >= 0) {
    std::memcpy(&DDRTCM_B.b_B_data[0], &B_data[0], static_cast<uint32_T>
                (DDRTCM_B.minmana) * sizeof(real_T));
  }

  Y[0] = 0.0;
  Y[1] = 0.0;
  DDRTCM_B.minmana = A_size[0];
  if (A_size[0] <= 2) {
    DDRTCM_B.b_A = A_size[0];
  } else {
    DDRTCM_B.b_A = 2;
  }

  for (DDRTCM_B.e_i = 0; DDRTCM_B.e_i < DDRTCM_B.b_A; DDRTCM_B.e_i++) {
    DDRTCM_B.temp = DDRTCM_B.tau_data[DDRTCM_B.e_i];
    if (DDRTCM_B.temp != 0.0) {
      DDRTCM_B.b_c = DDRTCM_B.b_B_data[DDRTCM_B.e_i];
      for (DDRTCM_B.mmi = DDRTCM_B.e_i + 2; DDRTCM_B.mmi <= DDRTCM_B.minmana;
           DDRTCM_B.mmi++) {
        DDRTCM_B.b_c += DDRTCM_B.b_A_data[(DDRTCM_B.b_A_size[0] * DDRTCM_B.e_i +
          DDRTCM_B.mmi) - 1] * DDRTCM_B.b_B_data[DDRTCM_B.mmi - 1];
      }

      DDRTCM_B.b_c *= DDRTCM_B.temp;
      if (DDRTCM_B.b_c != 0.0) {
        DDRTCM_B.b_B_data[DDRTCM_B.e_i] -= DDRTCM_B.b_c;
        DDRTCM_B.itemp = (((((DDRTCM_B.minmana - DDRTCM_B.e_i) - 1) / 2) << 1) +
                          DDRTCM_B.e_i) + 2;
        DDRTCM_B.jA = DDRTCM_B.itemp - 2;
        for (DDRTCM_B.mmi = DDRTCM_B.e_i + 2; DDRTCM_B.mmi <= DDRTCM_B.jA;
             DDRTCM_B.mmi += 2) {
          __m128d tmp;
          tmp_0 = _mm_loadu_pd(&DDRTCM_B.b_A_data[(DDRTCM_B.b_A_size[0] *
            DDRTCM_B.e_i + DDRTCM_B.mmi) - 1]);
          tmp = _mm_loadu_pd(&DDRTCM_B.b_B_data[DDRTCM_B.mmi - 1]);
          _mm_storeu_pd(&DDRTCM_B.b_B_data[DDRTCM_B.mmi - 1], _mm_sub_pd(tmp,
            _mm_mul_pd(tmp_0, _mm_set1_pd(DDRTCM_B.b_c))));
        }

        for (DDRTCM_B.mmi = DDRTCM_B.itemp; DDRTCM_B.mmi <= DDRTCM_B.minmana;
             DDRTCM_B.mmi++) {
          DDRTCM_B.b_B_data[DDRTCM_B.mmi - 1] -= DDRTCM_B.b_A_data
            [(DDRTCM_B.b_A_size[0] * DDRTCM_B.e_i + DDRTCM_B.mmi) - 1] *
            DDRTCM_B.b_c;
        }
      }
    }
  }

  for (DDRTCM_B.minmana = 0; DDRTCM_B.minmana < DDRTCM_B.minmn; DDRTCM_B.minmana
       ++) {
    Y[DDRTCM_B.jpvt[DDRTCM_B.minmana] - 1] = DDRTCM_B.b_B_data[DDRTCM_B.minmana];
  }

  for (DDRTCM_B.minmana = DDRTCM_B.minmn; DDRTCM_B.minmana >= 1;
       DDRTCM_B.minmana--) {
    DDRTCM_B.b_A = DDRTCM_B.jpvt[DDRTCM_B.minmana - 1] - 1;
    DDRTCM_B.mmi = (DDRTCM_B.minmana - 1) * DDRTCM_B.b_A_size[0];
    Y[DDRTCM_B.b_A] /= DDRTCM_B.b_A_data[(DDRTCM_B.minmana + DDRTCM_B.mmi) - 1];
    for (DDRTCM_B.e_i = 0; DDRTCM_B.e_i <= DDRTCM_B.minmana - 2; DDRTCM_B.e_i++)
    {
      Y[DDRTCM_B.jpvt[0] - 1] -= Y[DDRTCM_B.b_A] *
        DDRTCM_B.b_A_data[DDRTCM_B.mmi];
    }
  }
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_polyfit(const real_T x_data[], const int32_T x_size[2],
  const real_T y_data[], const int32_T y_size[2], real_T p[2])
{
  DDRTCM_B.V_size[0] = x_size[1];
  DDRTCM_B.V_size[1] = 2;
  if (x_size[1] != 0) {
    DDRTCM_B.b_i = x_size[1];
    for (DDRTCM_B.k_o = 0; DDRTCM_B.k_o < DDRTCM_B.b_i; DDRTCM_B.k_o++) {
      DDRTCM_B.V_data[DDRTCM_B.k_o + DDRTCM_B.V_size[0]] = 1.0;
    }

    DDRTCM_B.b_i = x_size[1];
    if (DDRTCM_B.b_i - 1 >= 0) {
      std::memcpy(&DDRTCM_B.V_data[0], &x_data[0], static_cast<uint32_T>
                  (DDRTCM_B.b_i) * sizeof(real_T));
    }
  }

  DDRTCM_B.y_n = y_size[1];
  DDRTCM_qrsolve_b(DDRTCM_B.V_data, DDRTCM_B.V_size, y_data, &DDRTCM_B.y_n, p,
                   &DDRTCM_B.b_i);
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_eml_find_p(const boolean_T x[110], int32_T i_data[], int32_T
  *i_size)
{
  int32_T idx;
  int32_T ii;
  boolean_T exitg1;
  idx = 0;
  ii = 0;
  exitg1 = false;
  while ((!exitg1) && (ii < 110)) {
    if (x[ii]) {
      idx++;
      i_data[idx - 1] = ii + 1;
      if (idx >= 110) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (idx < 1) {
    *i_size = 0;
  } else {
    *i_size = idx;
  }
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
int32_T DDRTCM::DDRTCM_bsearch(uint16_T x, const real_T s_data[], const int32_T *
  s_size)
{
  int32_T idx;
  int32_T ihi;
  int32_T ilo;
  boolean_T exitg1;
  ihi = *s_size;
  idx = 0;
  ilo = 1;
  exitg1 = false;
  while ((!exitg1) && (ihi >= ilo)) {
    int32_T imid;
    imid = ((ilo >> 1) + (ihi >> 1)) - 1;
    if (((ilo & 1) == 1) && ((ihi & 1) == 1)) {
      imid++;
    }

    if (x == s_data[imid]) {
      idx = imid + 1;
      exitg1 = true;
    } else if (x < s_data[imid]) {
      ihi = imid;
    } else {
      ilo = imid + 2;
    }
  }

  if (idx > 0) {
    idx--;
    while ((idx > 0) && (s_data[idx - 1] == x)) {
      idx--;
    }

    idx++;
  }

  return idx;
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_merge_d(int32_T idx_data[], real_T x_data[], int32_T offset,
  int32_T np, int32_T nq, int32_T iwork_data[], real_T xwork_data[])
{
  if (nq != 0) {
    DDRTCM_B.offset1 = np + nq;
    for (DDRTCM_B.q = 0; DDRTCM_B.q < DDRTCM_B.offset1; DDRTCM_B.q++) {
      DDRTCM_B.iout = offset + DDRTCM_B.q;
      iwork_data[DDRTCM_B.q] = idx_data[DDRTCM_B.iout];
      xwork_data[DDRTCM_B.q] = x_data[DDRTCM_B.iout];
    }

    DDRTCM_B.p_n = 0;
    DDRTCM_B.q = np;
    DDRTCM_B.iout = offset - 1;
    int32_T exitg1;
    do {
      exitg1 = 0;
      DDRTCM_B.iout++;
      if (xwork_data[DDRTCM_B.p_n] <= xwork_data[DDRTCM_B.q]) {
        idx_data[DDRTCM_B.iout] = iwork_data[DDRTCM_B.p_n];
        x_data[DDRTCM_B.iout] = xwork_data[DDRTCM_B.p_n];
        if (DDRTCM_B.p_n + 1 < np) {
          DDRTCM_B.p_n++;
        } else {
          exitg1 = 1;
        }
      } else {
        idx_data[DDRTCM_B.iout] = iwork_data[DDRTCM_B.q];
        x_data[DDRTCM_B.iout] = xwork_data[DDRTCM_B.q];
        if (DDRTCM_B.q + 1 < DDRTCM_B.offset1) {
          DDRTCM_B.q++;
        } else {
          DDRTCM_B.offset1 = DDRTCM_B.iout - DDRTCM_B.p_n;
          for (DDRTCM_B.q = DDRTCM_B.p_n + 1; DDRTCM_B.q <= np; DDRTCM_B.q++) {
            DDRTCM_B.iout = DDRTCM_B.offset1 + DDRTCM_B.q;
            idx_data[DDRTCM_B.iout] = iwork_data[DDRTCM_B.q - 1];
            x_data[DDRTCM_B.iout] = xwork_data[DDRTCM_B.q - 1];
          }

          exitg1 = 1;
        }
      }
    } while (exitg1 == 0);
  }
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_sort_i(real_T x_data[], const int32_T *x_size, int32_T
  idx_data[], int32_T *idx_size)
{
  DDRTCM_B.dim = 0;
  if (*x_size != 1) {
    DDRTCM_B.dim = -1;
    DDRTCM_B.n = *x_size;
  } else {
    DDRTCM_B.n = 1;
  }

  DDRTCM_B.b = DDRTCM_B.n - 1;
  DDRTCM_B.vwork_size_idx_0 = DDRTCM_B.n;
  *idx_size = *x_size;
  DDRTCM_B.vstride = 1;
  for (DDRTCM_B.n = 0; DDRTCM_B.n <= DDRTCM_B.dim; DDRTCM_B.n++) {
    DDRTCM_B.vstride *= *x_size;
  }

  for (DDRTCM_B.dim = 0; DDRTCM_B.dim < DDRTCM_B.vstride; DDRTCM_B.dim++) {
    for (DDRTCM_B.n = 0; DDRTCM_B.n <= DDRTCM_B.b; DDRTCM_B.n++) {
      DDRTCM_B.vwork_data[DDRTCM_B.n] = x_data[DDRTCM_B.n * DDRTCM_B.vstride +
        DDRTCM_B.dim];
    }

    DDRTCM_B.b_x_size = DDRTCM_B.vwork_size_idx_0;
    if (DDRTCM_B.vwork_size_idx_0 - 1 >= 0) {
      std::memcpy(&DDRTCM_B.b_x_data[0], &DDRTCM_B.vwork_data[0],
                  static_cast<uint32_T>(DDRTCM_B.vwork_size_idx_0) * sizeof
                  (real_T));
    }

    DDRTCM_B.nPairs = static_cast<int8_T>(DDRTCM_B.vwork_size_idx_0);
    if (DDRTCM_B.nPairs - 1 >= 0) {
      std::memset(&DDRTCM_B.b_idx_data[0], 0, static_cast<uint32_T>
                  (DDRTCM_B.nPairs) * sizeof(int32_T));
    }

    if (DDRTCM_B.vwork_size_idx_0 != 0) {
      DDRTCM_B.nPairs = static_cast<int8_T>(DDRTCM_B.vwork_size_idx_0);
      if (DDRTCM_B.nPairs - 1 >= 0) {
        std::memset(&DDRTCM_B.b_idx_data[0], 0, static_cast<uint32_T>
                    (DDRTCM_B.nPairs) * sizeof(int32_T));
      }

      DDRTCM_B.x4[0] = 0.0;
      DDRTCM_B.idx4[0] = 0;
      DDRTCM_B.x4[1] = 0.0;
      DDRTCM_B.idx4[1] = 0;
      DDRTCM_B.x4[2] = 0.0;
      DDRTCM_B.idx4[2] = 0;
      DDRTCM_B.x4[3] = 0.0;
      DDRTCM_B.idx4[3] = 0;
      DDRTCM_B.ib = 0;
      for (DDRTCM_B.nPairs = 0; DDRTCM_B.nPairs < DDRTCM_B.vwork_size_idx_0;
           DDRTCM_B.nPairs++) {
        DDRTCM_B.ib++;
        DDRTCM_B.idx4[DDRTCM_B.ib - 1] = static_cast<int8_T>(DDRTCM_B.nPairs + 1);
        DDRTCM_B.x4[DDRTCM_B.ib - 1] = DDRTCM_B.b_x_data[DDRTCM_B.nPairs];
        if (DDRTCM_B.ib == 4) {
          if (DDRTCM_B.x4[0] <= DDRTCM_B.x4[1]) {
            DDRTCM_B.ib = 1;
            DDRTCM_B.n = 2;
          } else {
            DDRTCM_B.ib = 2;
            DDRTCM_B.n = 1;
          }

          if (DDRTCM_B.x4[2] <= DDRTCM_B.x4[3]) {
            DDRTCM_B.i3 = 3;
            DDRTCM_B.i4 = 4;
          } else {
            DDRTCM_B.i3 = 4;
            DDRTCM_B.i4 = 3;
          }

          DDRTCM_B.d = DDRTCM_B.x4[DDRTCM_B.ib - 1];
          DDRTCM_B.d1 = DDRTCM_B.x4[DDRTCM_B.i3 - 1];
          if (DDRTCM_B.d <= DDRTCM_B.d1) {
            DDRTCM_B.d = DDRTCM_B.x4[DDRTCM_B.n - 1];
            if (DDRTCM_B.d <= DDRTCM_B.d1) {
              DDRTCM_B.perm[0] = static_cast<int8_T>(DDRTCM_B.ib);
              DDRTCM_B.perm[1] = static_cast<int8_T>(DDRTCM_B.n);
              DDRTCM_B.perm[2] = static_cast<int8_T>(DDRTCM_B.i3);
              DDRTCM_B.perm[3] = static_cast<int8_T>(DDRTCM_B.i4);
            } else if (DDRTCM_B.d <= DDRTCM_B.x4[DDRTCM_B.i4 - 1]) {
              DDRTCM_B.perm[0] = static_cast<int8_T>(DDRTCM_B.ib);
              DDRTCM_B.perm[1] = static_cast<int8_T>(DDRTCM_B.i3);
              DDRTCM_B.perm[2] = static_cast<int8_T>(DDRTCM_B.n);
              DDRTCM_B.perm[3] = static_cast<int8_T>(DDRTCM_B.i4);
            } else {
              DDRTCM_B.perm[0] = static_cast<int8_T>(DDRTCM_B.ib);
              DDRTCM_B.perm[1] = static_cast<int8_T>(DDRTCM_B.i3);
              DDRTCM_B.perm[2] = static_cast<int8_T>(DDRTCM_B.i4);
              DDRTCM_B.perm[3] = static_cast<int8_T>(DDRTCM_B.n);
            }
          } else {
            DDRTCM_B.d1 = DDRTCM_B.x4[DDRTCM_B.i4 - 1];
            if (DDRTCM_B.d <= DDRTCM_B.d1) {
              if (DDRTCM_B.x4[DDRTCM_B.n - 1] <= DDRTCM_B.d1) {
                DDRTCM_B.perm[0] = static_cast<int8_T>(DDRTCM_B.i3);
                DDRTCM_B.perm[1] = static_cast<int8_T>(DDRTCM_B.ib);
                DDRTCM_B.perm[2] = static_cast<int8_T>(DDRTCM_B.n);
                DDRTCM_B.perm[3] = static_cast<int8_T>(DDRTCM_B.i4);
              } else {
                DDRTCM_B.perm[0] = static_cast<int8_T>(DDRTCM_B.i3);
                DDRTCM_B.perm[1] = static_cast<int8_T>(DDRTCM_B.ib);
                DDRTCM_B.perm[2] = static_cast<int8_T>(DDRTCM_B.i4);
                DDRTCM_B.perm[3] = static_cast<int8_T>(DDRTCM_B.n);
              }
            } else {
              DDRTCM_B.perm[0] = static_cast<int8_T>(DDRTCM_B.i3);
              DDRTCM_B.perm[1] = static_cast<int8_T>(DDRTCM_B.i4);
              DDRTCM_B.perm[2] = static_cast<int8_T>(DDRTCM_B.ib);
              DDRTCM_B.perm[3] = static_cast<int8_T>(DDRTCM_B.n);
            }
          }

          DDRTCM_B.b_idx_data[DDRTCM_B.nPairs - 3] =
            DDRTCM_B.idx4[DDRTCM_B.perm[0] - 1];
          DDRTCM_B.b_idx_data[DDRTCM_B.nPairs - 2] =
            DDRTCM_B.idx4[DDRTCM_B.perm[1] - 1];
          DDRTCM_B.b_idx_data[DDRTCM_B.nPairs - 1] =
            DDRTCM_B.idx4[DDRTCM_B.perm[2] - 1];
          DDRTCM_B.b_idx_data[DDRTCM_B.nPairs] = DDRTCM_B.idx4[DDRTCM_B.perm[3]
            - 1];
          DDRTCM_B.b_x_data[DDRTCM_B.nPairs - 3] = DDRTCM_B.x4[DDRTCM_B.perm[0]
            - 1];
          DDRTCM_B.b_x_data[DDRTCM_B.nPairs - 2] = DDRTCM_B.x4[DDRTCM_B.perm[1]
            - 1];
          DDRTCM_B.b_x_data[DDRTCM_B.nPairs - 1] = DDRTCM_B.x4[DDRTCM_B.perm[2]
            - 1];
          DDRTCM_B.b_x_data[DDRTCM_B.nPairs] = DDRTCM_B.x4[DDRTCM_B.perm[3] - 1];
          DDRTCM_B.ib = 0;
        }
      }

      if (DDRTCM_B.ib > 0) {
        DDRTCM_B.perm[1] = 0;
        DDRTCM_B.perm[2] = 0;
        DDRTCM_B.perm[3] = 0;
        switch (DDRTCM_B.ib) {
         case 1:
          DDRTCM_B.perm[0] = 1;
          break;

         case 2:
          if (DDRTCM_B.x4[0] <= DDRTCM_B.x4[1]) {
            DDRTCM_B.perm[0] = 1;
            DDRTCM_B.perm[1] = 2;
          } else {
            DDRTCM_B.perm[0] = 2;
            DDRTCM_B.perm[1] = 1;
          }
          break;

         default:
          if (DDRTCM_B.x4[0] <= DDRTCM_B.x4[1]) {
            if (DDRTCM_B.x4[1] <= DDRTCM_B.x4[2]) {
              DDRTCM_B.perm[0] = 1;
              DDRTCM_B.perm[1] = 2;
              DDRTCM_B.perm[2] = 3;
            } else if (DDRTCM_B.x4[0] <= DDRTCM_B.x4[2]) {
              DDRTCM_B.perm[0] = 1;
              DDRTCM_B.perm[1] = 3;
              DDRTCM_B.perm[2] = 2;
            } else {
              DDRTCM_B.perm[0] = 3;
              DDRTCM_B.perm[1] = 1;
              DDRTCM_B.perm[2] = 2;
            }
          } else if (DDRTCM_B.x4[0] <= DDRTCM_B.x4[2]) {
            DDRTCM_B.perm[0] = 2;
            DDRTCM_B.perm[1] = 1;
            DDRTCM_B.perm[2] = 3;
          } else if (DDRTCM_B.x4[1] <= DDRTCM_B.x4[2]) {
            DDRTCM_B.perm[0] = 2;
            DDRTCM_B.perm[1] = 3;
            DDRTCM_B.perm[2] = 1;
          } else {
            DDRTCM_B.perm[0] = 3;
            DDRTCM_B.perm[1] = 2;
            DDRTCM_B.perm[2] = 1;
          }
          break;
        }

        DDRTCM_B.i3 = static_cast<uint8_T>(DDRTCM_B.ib);
        for (DDRTCM_B.nPairs = 0; DDRTCM_B.nPairs < DDRTCM_B.i3; DDRTCM_B.nPairs
             ++) {
          DDRTCM_B.perm_j = DDRTCM_B.perm[DDRTCM_B.nPairs];
          DDRTCM_B.n = (DDRTCM_B.vwork_size_idx_0 - DDRTCM_B.ib) +
            DDRTCM_B.nPairs;
          DDRTCM_B.b_idx_data[DDRTCM_B.n] = DDRTCM_B.idx4[DDRTCM_B.perm_j - 1];
          DDRTCM_B.b_x_data[DDRTCM_B.n] = DDRTCM_B.x4[DDRTCM_B.perm_j - 1];
        }
      }

      if (DDRTCM_B.vwork_size_idx_0 > 1) {
        DDRTCM_B.nPairs = static_cast<int8_T>(DDRTCM_B.vwork_size_idx_0);
        if (DDRTCM_B.nPairs - 1 >= 0) {
          std::memset(&DDRTCM_B.iwork_data[0], 0, static_cast<uint32_T>
                      (DDRTCM_B.nPairs) * sizeof(int32_T));
        }

        std::memset(&DDRTCM_B.vwork_data[0], 0, static_cast<uint32_T>
                    (DDRTCM_B.vwork_size_idx_0) * sizeof(real_T));
        DDRTCM_B.nPairs = DDRTCM_B.vwork_size_idx_0 >> 2;
        DDRTCM_B.n = 4;
        while (DDRTCM_B.nPairs > 1) {
          if ((static_cast<uint32_T>(DDRTCM_B.nPairs) & 1U) != 0U) {
            DDRTCM_B.nPairs--;
            DDRTCM_B.i3 = DDRTCM_B.n * DDRTCM_B.nPairs;
            DDRTCM_B.ib = DDRTCM_B.vwork_size_idx_0 - DDRTCM_B.i3;
            if (DDRTCM_B.ib > DDRTCM_B.n) {
              DDRTCM_merge_d(DDRTCM_B.b_idx_data, DDRTCM_B.b_x_data, DDRTCM_B.i3,
                             DDRTCM_B.n, DDRTCM_B.ib - DDRTCM_B.n,
                             DDRTCM_B.iwork_data, DDRTCM_B.vwork_data);
            }
          }

          DDRTCM_B.ib = DDRTCM_B.n << 1;
          DDRTCM_B.nPairs >>= 1;
          for (DDRTCM_B.i3 = 0; DDRTCM_B.i3 < DDRTCM_B.nPairs; DDRTCM_B.i3++) {
            DDRTCM_merge_d(DDRTCM_B.b_idx_data, DDRTCM_B.b_x_data, DDRTCM_B.i3 *
                           DDRTCM_B.ib, DDRTCM_B.n, DDRTCM_B.n,
                           DDRTCM_B.iwork_data, DDRTCM_B.vwork_data);
          }

          DDRTCM_B.n = DDRTCM_B.ib;
        }

        if (DDRTCM_B.vwork_size_idx_0 > DDRTCM_B.n) {
          DDRTCM_merge_d(DDRTCM_B.b_idx_data, DDRTCM_B.b_x_data, 0, DDRTCM_B.n,
                         DDRTCM_B.vwork_size_idx_0 - DDRTCM_B.n,
                         DDRTCM_B.iwork_data, DDRTCM_B.vwork_data);
        }
      }
    }

    DDRTCM_B.vwork_size_idx_0 = DDRTCM_B.b_x_size;
    DDRTCM_B.nPairs = DDRTCM_B.b_x_size;
    if (DDRTCM_B.nPairs - 1 >= 0) {
      std::memcpy(&DDRTCM_B.vwork_data[0], &DDRTCM_B.b_x_data[0],
                  static_cast<uint32_T>(DDRTCM_B.nPairs) * sizeof(real_T));
    }

    for (DDRTCM_B.nPairs = 0; DDRTCM_B.nPairs <= DDRTCM_B.b; DDRTCM_B.nPairs++)
    {
      DDRTCM_B.n = DDRTCM_B.nPairs * DDRTCM_B.vstride + DDRTCM_B.dim;
      x_data[DDRTCM_B.n] = DDRTCM_B.b_x_data[DDRTCM_B.nPairs];
      idx_data[DDRTCM_B.n] = DDRTCM_B.b_idx_data[DDRTCM_B.nPairs];
    }
  }
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
void DDRTCM::DDRTCM_isMember_i(const uint16_T a_data[], const int32_T *a_size,
  const real_T s_data[], const int32_T *s_size, boolean_T tf_data[], int32_T
  *tf_size)
{
  boolean_T exitg1;
  boolean_T guard1{ false };

  DDRTCM_B.ns = *s_size;
  *tf_size = *a_size;
  DDRTCM_B.pmax = *a_size;
  if (DDRTCM_B.pmax - 1 >= 0) {
    std::memset(&tf_data[0], 0, static_cast<uint32_T>(DDRTCM_B.pmax) * sizeof
                (boolean_T));
  }

  guard1 = false;
  if (*s_size <= 4) {
    guard1 = true;
  } else {
    DDRTCM_B.pmax = 31;
    DDRTCM_B.pmin = 0;
    exitg1 = false;
    while ((!exitg1) && (DDRTCM_B.pmax - DDRTCM_B.pmin > 1)) {
      DDRTCM_B.p_o = (DDRTCM_B.pmin + DDRTCM_B.pmax) >> 1;
      DDRTCM_B.pow2p = 1 << DDRTCM_B.p_o;
      if (DDRTCM_B.pow2p == DDRTCM_B.ns) {
        DDRTCM_B.pmax = DDRTCM_B.p_o;
        exitg1 = true;
      } else if (DDRTCM_B.pow2p > DDRTCM_B.ns) {
        DDRTCM_B.pmax = DDRTCM_B.p_o;
      } else {
        DDRTCM_B.pmin = DDRTCM_B.p_o;
      }
    }

    if (*a_size <= DDRTCM_B.pmax + 4) {
      guard1 = true;
    } else {
      DDRTCM_B.y_h = true;
      DDRTCM_B.ns = 0;
      exitg1 = false;
      while ((!exitg1) && (DDRTCM_B.ns <= *s_size - 2)) {
        if (!(s_data[DDRTCM_B.ns] <= s_data[DDRTCM_B.ns + 1])) {
          DDRTCM_B.y_h = false;
        }

        if (!DDRTCM_B.y_h) {
          exitg1 = true;
        } else {
          DDRTCM_B.ns++;
        }
      }

      if (!DDRTCM_B.y_h) {
        DDRTCM_B.ss_size = *s_size;
        DDRTCM_B.pmax = *s_size;
        std::memcpy(&DDRTCM_B.ss_data[0], &s_data[0], static_cast<uint32_T>
                    (DDRTCM_B.pmax) * sizeof(real_T));
        DDRTCM_sort_i(DDRTCM_B.ss_data, &DDRTCM_B.ss_size,
                      DDRTCM_B.ss_data_g.data, &DDRTCM_B.ss_data_g.size);
        DDRTCM_B.ns = *a_size;
        for (DDRTCM_B.pmax = 0; DDRTCM_B.pmax < DDRTCM_B.ns; DDRTCM_B.pmax++) {
          if (DDRTCM_bsearch(a_data[DDRTCM_B.pmax], DDRTCM_B.ss_data,
                             &DDRTCM_B.ss_size) > 0) {
            tf_data[DDRTCM_B.pmax] = true;
          }
        }
      } else {
        DDRTCM_B.ns = *a_size;
        for (DDRTCM_B.pmax = 0; DDRTCM_B.pmax < DDRTCM_B.ns; DDRTCM_B.pmax++) {
          if (DDRTCM_bsearch(a_data[DDRTCM_B.pmax], s_data, s_size) > 0) {
            tf_data[DDRTCM_B.pmax] = true;
          }
        }
      }
    }
  }

  if (guard1) {
    DDRTCM_B.pmax = *a_size;
    for (DDRTCM_B.pmin = 0; DDRTCM_B.pmin < DDRTCM_B.pmax; DDRTCM_B.pmin++) {
      DDRTCM_B.p_o = 0;
      exitg1 = false;
      while ((!exitg1) && (DDRTCM_B.p_o <= DDRTCM_B.ns - 1)) {
        if (a_data[DDRTCM_B.pmin] == s_data[DDRTCM_B.p_o]) {
          tf_data[DDRTCM_B.pmin] = true;
          exitg1 = true;
        } else {
          DDRTCM_B.p_o++;
        }
      }
    }
  }
}

void DDRTCM::DDRTC_binary_expand_op_bfmqb0c5(real_T in1[4400], const
  GNSS_Measurement *in2, const GNSS_Measurement_size *in3, real_T in4)
{
  int32_T loop_ub;
  int32_T stride_0_0;
  int32_T stride_1_0;

  // MATLAB Function: '<S2>/Multipath-Detector'
  stride_0_0 = (in3->carrierphase != 1);
  stride_1_0 = (in3->pseudorange != 1);
  loop_ub = in3->pseudorange == 1 ? in3->carrierphase : in3->pseudorange;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1[in2->PRN[i] - 1] = in2->carrierphase[i * stride_0_0] - in2->
      pseudorange[i * stride_1_0] / in4;
  }

  // End of MATLAB Function: '<S2>/Multipath-Detector'
}

// Function for MATLAB Function: '<S2>/Multipath-Detector'
boolean_T DDRTCM::DDRTCM_any_jj3(const boolean_T x[110])
{
  int32_T k;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 110)) {
    if (x[k]) {
      y = true;
      exitg1 = true;
    } else {
      k++;
    }
  }

  return y;
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::DDRTCM_maximum_l(const real_T x[100], real_T ex[2])
{
  for (int32_T j{0}; j < 2; j++) {
    ex[j] = x[50 * j];
    for (int32_T i{0}; i < 49; i++) {
      real_T ex_0;
      real_T tmp;
      ex_0 = ex[j];
      tmp = x[(50 * j + i) + 1];
      if (ex_0 < tmp) {
        ex_0 = tmp;
      }

      ex[j] = ex_0;
    }
  }
}

// Function for MATLAB Function: '<S2>/calculate double diff'
real_T DDRTCM::DDRTCM_minimum(const real_T x[2])
{
  real_T ex;
  if (x[0] > x[1]) {
    ex = x[1];
  } else {
    ex = x[0];
  }

  return ex;
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::DDRTCM_minimum_a(const real_T x[100], real_T ex[2])
{
  for (int32_T j{0}; j < 2; j++) {
    ex[j] = x[50 * j];
    for (int32_T i{0}; i < 49; i++) {
      real_T ex_0;
      real_T tmp;
      ex_0 = ex[j];
      tmp = x[(50 * j + i) + 1];
      if (ex_0 > tmp) {
        ex_0 = tmp;
      }

      ex[j] = ex_0;
    }
  }
}

// Function for MATLAB Function: '<S2>/calculate double diff'
real_T DDRTCM::DDRTCM_maximum_ln(const real_T x[2])
{
  real_T ex;
  if (x[0] < x[1]) {
    ex = x[1];
  } else {
    ex = x[0];
  }

  return ex;
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::DDRTCM_eml_find_h(const boolean_T x[50], int32_T i_data[], int32_T *
  i_size)
{
  int32_T idx;
  int32_T ii;
  boolean_T exitg1;
  idx = 0;
  ii = 0;
  exitg1 = false;
  while ((!exitg1) && (ii < 50)) {
    if (x[ii]) {
      idx++;
      i_data[idx - 1] = ii + 1;
      if (idx >= 50) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (idx < 1) {
    *i_size = 0;
  } else {
    *i_size = idx;
  }
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::DDRTCM_do_vectors_p(const uint16_T a[40], const uint16_T b[40],
  uint16_T c_data[], int32_T c_size[2], int32_T ia_data[], int32_T *ia_size,
  int32_T ib_data[], int32_T *ib_size)
{
  int32_T iafirst;
  int32_T ialast;
  int32_T ibfirst;
  int32_T iblast;
  int32_T nc;
  c_size[0] = 1;
  nc = -1;
  iafirst = 0;
  ialast = 1;
  ibfirst = 0;
  iblast = 1;
  while ((ialast <= 40) && (iblast <= 40)) {
    int32_T b_ialast;
    int32_T b_iblast;
    uint16_T ak;
    uint16_T bk;
    b_ialast = ialast;
    ak = a[ialast - 1];
    while ((b_ialast < 40) && (a[b_ialast] == ak)) {
      b_ialast++;
    }

    ialast = b_ialast;
    b_iblast = iblast;
    bk = b[iblast - 1];
    while ((b_iblast < 40) && (b[b_iblast] == bk)) {
      b_iblast++;
    }

    iblast = b_iblast;
    if (ak == bk) {
      nc++;
      c_data[nc] = ak;
      ia_data[nc] = iafirst + 1;
      ib_data[nc] = ibfirst + 1;
      ialast = b_ialast + 1;
      iafirst = b_ialast;
      iblast = b_iblast + 1;
      ibfirst = b_iblast;
    } else if (ak < bk) {
      ialast = b_ialast + 1;
      iafirst = b_ialast;
    } else {
      iblast = b_iblast + 1;
      ibfirst = b_iblast;
    }
  }

  if (nc + 1 < 1) {
    iafirst = -1;
  } else {
    iafirst = nc;
  }

  *ia_size = iafirst + 1;
  if (nc + 1 < 1) {
    iafirst = -1;
  } else {
    iafirst = nc;
  }

  *ib_size = iafirst + 1;
  if (nc + 1 < 1) {
    c_size[1] = 0;
  } else {
    c_size[1] = nc + 1;
  }
}

// Function for MATLAB Function: '<S2>/calculate double diff'
boolean_T DDRTCM::DDRTCM_any_e1(const boolean_T x_data[], const int32_T x_size[2])
{
  int32_T ix;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  ix = 1;
  exitg1 = false;
  while ((!exitg1) && (ix <= x_size[1])) {
    if (x_data[ix - 1]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

real_T DDRTCM::DDRTCM_rt_atan2d_snf_bf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = (rtNaN);
  } else if (std::isinf(u0) && std::isinf(u1)) {
    if (u0 > 0.0) {
      DDRTCM_B.i_m = 1;
    } else {
      DDRTCM_B.i_m = -1;
    }

    if (u1 > 0.0) {
      DDRTCM_B.i1 = 1;
    } else {
      DDRTCM_B.i1 = -1;
    }

    y = std::atan2(static_cast<real_T>(DDRTCM_B.i_m), static_cast<real_T>
                   (DDRTCM_B.i1));
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = std::atan2(u0, u1);
  }

  return y;
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::calculate_Satellite_Elevation_a(const real_T user_Position_llh[3],
  const real_T satellite_Position_ecef_data[], const int32_T
  satellite_Position_ecef_size[2], real_T elevation_Angle_data[], int32_T
  *elevation_Angle_size, real_T azimuth_Angle_data[], int32_T
  *azimuth_Angle_size)
{
  *elevation_Angle_size = satellite_Position_ecef_size[0];
  DDRTCM_B.loop_ub = satellite_Position_ecef_size[0];
  if (DDRTCM_B.loop_ub - 1 >= 0) {
    std::memset(&elevation_Angle_data[0], 0, static_cast<uint32_T>
                (DDRTCM_B.loop_ub) * sizeof(real_T));
  }

  *azimuth_Angle_size = satellite_Position_ecef_size[0];
  DDRTCM_B.loop_ub = satellite_Position_ecef_size[0];
  if (DDRTCM_B.loop_ub - 1 >= 0) {
    std::memset(&azimuth_Angle_data[0], 0, static_cast<uint32_T>
                (DDRTCM_B.loop_ub) * sizeof(real_T));
  }

  DDRTCM_B.scale_l = std::cos(user_Position_llh[0]);
  DDRTCM_B.N = 6.3995936257584924E+6 / std::sqrt(DDRTCM_B.scale_l *
    DDRTCM_B.scale_l * 0.0067394967422761756 + 1.0);
  DDRTCM_B.line_of_sight_idx_0 = std::cos(user_Position_llh[1]);
  DDRTCM_B.user_Position_ecef_idx_0 = (DDRTCM_B.N + user_Position_llh[2]) *
    DDRTCM_B.scale_l * DDRTCM_B.line_of_sight_idx_0;
  DDRTCM_B.absxk_h = std::sin(user_Position_llh[1]);
  DDRTCM_B.user_Position_ecef_idx_1 = (DDRTCM_B.N + user_Position_llh[2]) * std::
    cos(user_Position_llh[0]) * DDRTCM_B.absxk_h;
  DDRTCM_B.t_b = std::sin(user_Position_llh[0]);
  DDRTCM_B.N = (0.99330562000985889 * DDRTCM_B.N + user_Position_llh[2]) *
    DDRTCM_B.t_b;
  DDRTCM_B.e_unit_tmp[0] = -DDRTCM_B.absxk_h;
  DDRTCM_B.e_unit_tmp[1] = DDRTCM_B.line_of_sight_idx_0;
  DDRTCM_B.e_unit_tmp[2] = 0.0;
  DDRTCM_B.e_unit_tmp[3] = -DDRTCM_B.t_b * DDRTCM_B.line_of_sight_idx_0;
  DDRTCM_B.e_unit_tmp[4] = -std::sin(user_Position_llh[0]) * DDRTCM_B.absxk_h;
  DDRTCM_B.e_unit_tmp[5] = DDRTCM_B.scale_l;
  DDRTCM_B.e_unit_tmp[6] = DDRTCM_B.scale_l * DDRTCM_B.line_of_sight_idx_0;
  DDRTCM_B.e_unit_tmp[7] = DDRTCM_B.scale_l * DDRTCM_B.absxk_h;
  DDRTCM_B.e_unit_tmp[8] = DDRTCM_B.t_b;
  for (DDRTCM_B.i_c = 0; DDRTCM_B.i_c <= 0; DDRTCM_B.i_c += 2) {
    __m128d tmp;
    __m128d tmp_0;
    __m128d tmp_1;
    __m128d tmp_2;
    __m128d tmp_3;
    __m128d tmp_4;
    __m128d tmp_5;
    tmp = _mm_loadu_pd(&DDRTCM_B.e_unit_tmp[DDRTCM_B.i_c]);
    tmp_2 = _mm_set1_pd(0.0);
    tmp_3 = _mm_mul_pd(tmp, tmp_2);
    tmp_0 = _mm_loadu_pd(&DDRTCM_B.e_unit_tmp[DDRTCM_B.i_c + 3]);
    tmp_4 = _mm_mul_pd(tmp_0, tmp_2);
    tmp_1 = _mm_loadu_pd(&DDRTCM_B.e_unit_tmp[DDRTCM_B.i_c + 6]);
    tmp_5 = _mm_mul_pd(tmp_1, tmp_2);
    _mm_storeu_pd(&DDRTCM_B.e_unit[DDRTCM_B.i_c], _mm_add_pd(tmp_5, _mm_add_pd
      (tmp_4, _mm_add_pd(tmp_2, tmp))));
    tmp = _mm_add_pd(tmp_3, tmp_2);
    _mm_storeu_pd(&DDRTCM_B.n_unit[DDRTCM_B.i_c], _mm_add_pd(tmp_5, _mm_add_pd
      (tmp, tmp_0)));
    _mm_storeu_pd(&DDRTCM_B.u_unit[DDRTCM_B.i_c], _mm_add_pd(_mm_add_pd(tmp_4,
      tmp), tmp_1));
  }

  for (DDRTCM_B.i_c = 2; DDRTCM_B.i_c < 3; DDRTCM_B.i_c++) {
    DDRTCM_B.scale_l = DDRTCM_B.e_unit_tmp[DDRTCM_B.i_c];
    DDRTCM_B.line_of_sight_idx_0 = DDRTCM_B.scale_l;
    DDRTCM_B.absxk_h = DDRTCM_B.scale_l * 0.0;
    DDRTCM_B.t_b = DDRTCM_B.scale_l * 0.0;
    DDRTCM_B.scale_l = DDRTCM_B.e_unit_tmp[DDRTCM_B.i_c + 3];
    DDRTCM_B.line_of_sight_idx_0 += DDRTCM_B.scale_l * 0.0;
    DDRTCM_B.absxk_h += DDRTCM_B.scale_l;
    DDRTCM_B.t_b += DDRTCM_B.scale_l * 0.0;
    DDRTCM_B.scale_l = DDRTCM_B.e_unit_tmp[DDRTCM_B.i_c + 6];
    DDRTCM_B.e_unit[DDRTCM_B.i_c] = DDRTCM_B.scale_l * 0.0 +
      DDRTCM_B.line_of_sight_idx_0;
    DDRTCM_B.n_unit[DDRTCM_B.i_c] = DDRTCM_B.scale_l * 0.0 + DDRTCM_B.absxk_h;
    DDRTCM_B.u_unit[DDRTCM_B.i_c] = DDRTCM_B.t_b + DDRTCM_B.scale_l;
  }

  DDRTCM_B.loop_ub = satellite_Position_ecef_size[0];
  for (DDRTCM_B.i_c = 0; DDRTCM_B.i_c < DDRTCM_B.loop_ub; DDRTCM_B.i_c++) {
    DDRTCM_B.scale_l = 3.3121686421112381E-170;
    DDRTCM_B.line_of_sight_idx_0 = satellite_Position_ecef_data[DDRTCM_B.i_c] -
      DDRTCM_B.user_Position_ecef_idx_0;
    DDRTCM_B.absxk_h = std::abs(DDRTCM_B.line_of_sight_idx_0);
    if (DDRTCM_B.absxk_h > 3.3121686421112381E-170) {
      DDRTCM_B.y = 1.0;
      DDRTCM_B.scale_l = DDRTCM_B.absxk_h;
    } else {
      DDRTCM_B.t_b = DDRTCM_B.absxk_h / 3.3121686421112381E-170;
      DDRTCM_B.y = DDRTCM_B.t_b * DDRTCM_B.t_b;
    }

    DDRTCM_B.line_of_sight_idx_1 = satellite_Position_ecef_data[DDRTCM_B.i_c +
      satellite_Position_ecef_size[0]] - DDRTCM_B.user_Position_ecef_idx_1;
    DDRTCM_B.absxk_h = std::abs(DDRTCM_B.line_of_sight_idx_1);
    if (DDRTCM_B.absxk_h > DDRTCM_B.scale_l) {
      DDRTCM_B.t_b = DDRTCM_B.scale_l / DDRTCM_B.absxk_h;
      DDRTCM_B.y = DDRTCM_B.y * DDRTCM_B.t_b * DDRTCM_B.t_b + 1.0;
      DDRTCM_B.scale_l = DDRTCM_B.absxk_h;
    } else {
      DDRTCM_B.t_b = DDRTCM_B.absxk_h / DDRTCM_B.scale_l;
      DDRTCM_B.y += DDRTCM_B.t_b * DDRTCM_B.t_b;
    }

    DDRTCM_B.line_of_sight_idx_2 = satellite_Position_ecef_data
      [(satellite_Position_ecef_size[0] << 1) + DDRTCM_B.i_c] - DDRTCM_B.N;
    DDRTCM_B.absxk_h = std::abs(DDRTCM_B.line_of_sight_idx_2);
    if (DDRTCM_B.absxk_h > DDRTCM_B.scale_l) {
      DDRTCM_B.t_b = DDRTCM_B.scale_l / DDRTCM_B.absxk_h;
      DDRTCM_B.y = DDRTCM_B.y * DDRTCM_B.t_b * DDRTCM_B.t_b + 1.0;
      DDRTCM_B.scale_l = DDRTCM_B.absxk_h;
    } else {
      DDRTCM_B.t_b = DDRTCM_B.absxk_h / DDRTCM_B.scale_l;
      DDRTCM_B.y += DDRTCM_B.t_b * DDRTCM_B.t_b;
    }

    DDRTCM_B.y = DDRTCM_B.scale_l * std::sqrt(DDRTCM_B.y);
    DDRTCM_B.line_of_sight_idx_0 /= DDRTCM_B.y;
    DDRTCM_B.line_of_sight_idx_1 /= DDRTCM_B.y;
    DDRTCM_B.line_of_sight_idx_2 /= DDRTCM_B.y;
    elevation_Angle_data[DDRTCM_B.i_c] = std::asin((DDRTCM_B.line_of_sight_idx_0
      * DDRTCM_B.u_unit[0] + DDRTCM_B.line_of_sight_idx_1 * DDRTCM_B.u_unit[1])
      + DDRTCM_B.line_of_sight_idx_2 * DDRTCM_B.u_unit[2]);
    azimuth_Angle_data[DDRTCM_B.i_c] = DDRTCM_rt_atan2d_snf_bf
      ((DDRTCM_B.line_of_sight_idx_0 * DDRTCM_B.e_unit[0] +
        DDRTCM_B.line_of_sight_idx_1 * DDRTCM_B.e_unit[1]) +
       DDRTCM_B.line_of_sight_idx_2 * DDRTCM_B.e_unit[2],
       (DDRTCM_B.line_of_sight_idx_0 * DDRTCM_B.n_unit[0] +
        DDRTCM_B.line_of_sight_idx_1 * DDRTCM_B.n_unit[1]) +
       DDRTCM_B.line_of_sight_idx_2 * DDRTCM_B.n_unit[2]);
  }
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::DDRTCM_do_vectors_pj(const uint16_T a_data[], const int32_T a_size
  [2], const uint16_T b_data[], const int32_T *b_size, uint16_T c_data[],
  int32_T *c_size, int32_T ia_data[], int32_T *ia_size, int32_T ib_data[],
  int32_T *ib_size)
{
  int32_T iafirst;
  int32_T ialast;
  int32_T ibfirst;
  int32_T iblast;
  int32_T nc;
  int32_T ncmax;
  if (a_size[1] <= *b_size) {
    ncmax = a_size[1];
  } else {
    ncmax = *b_size;
  }

  *c_size = ncmax;
  *ia_size = ncmax;
  *ib_size = ncmax;
  nc = 0;
  iafirst = 0;
  ialast = 1;
  ibfirst = 0;
  iblast = 1;
  while ((ialast <= a_size[1]) && (iblast <= *b_size)) {
    int32_T b_ialast;
    int32_T b_iblast;
    uint16_T ak;
    uint16_T bk;
    b_ialast = ialast;
    ak = a_data[ialast - 1];
    while ((b_ialast < a_size[1]) && (a_data[b_ialast] == ak)) {
      b_ialast++;
    }

    ialast = b_ialast;
    b_iblast = iblast;
    bk = b_data[iblast - 1];
    while ((b_iblast < *b_size) && (b_data[b_iblast] == bk)) {
      b_iblast++;
    }

    iblast = b_iblast;
    if (ak == bk) {
      nc++;
      c_data[nc - 1] = ak;
      ia_data[nc - 1] = iafirst + 1;
      ib_data[nc - 1] = ibfirst + 1;
      ialast = b_ialast + 1;
      iafirst = b_ialast;
      iblast = b_iblast + 1;
      ibfirst = b_iblast;
    } else if (ak < bk) {
      ialast = b_ialast + 1;
      iafirst = b_ialast;
    } else {
      iblast = b_iblast + 1;
      ibfirst = b_iblast;
    }
  }

  if (ncmax > 0) {
    if (nc < 1) {
      *ia_size = 0;
      *ib_size = 0;
      *c_size = 0;
    } else {
      *ia_size = nc;
      *ib_size = nc;
      *c_size = nc;
    }
  }
}

// Function for MATLAB Function: '<S2>/calculate double diff'
void DDRTCM::DDRTCM_maximum_lnq(const real_T x_data[], const int32_T *x_size,
  real_T *ex, int32_T *idx)
{
  int32_T last;
  last = *x_size;
  if (static_cast<uint8_T>(*x_size - 1) + 1 <= 2) {
    if (static_cast<uint8_T>(*x_size - 1) + 1 == 1) {
      *ex = x_data[0];
      *idx = 1;
    } else {
      *ex = x_data[*x_size - 1];
      if ((x_data[0] < *ex) || (std::isnan(x_data[0]) && (!std::isnan(*ex)))) {
        *idx = *x_size;
      } else {
        *ex = x_data[0];
        *idx = 1;
      }
    }
  } else {
    int32_T b_idx;
    int32_T k;
    if (!std::isnan(x_data[0])) {
      b_idx = 1;
    } else {
      boolean_T exitg1;
      b_idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= *x_size)) {
        if (!std::isnan(x_data[k - 1])) {
          b_idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (b_idx == 0) {
      *ex = x_data[0];
      *idx = 1;
    } else {
      *ex = x_data[b_idx - 1];
      *idx = b_idx;
      for (k = b_idx + 1; k <= last; k++) {
        real_T tmp;
        tmp = x_data[k - 1];
        if (*ex < tmp) {
          *ex = tmp;
          *idx = k;
        }
      }
    }
  }
}

void DDRTCM::DDRTCM_binary_expand_op_bfmqb0c(real_T in1_data[], int32_T
  in1_size[2], const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in2, const int32_T
  in3_data[], const int32_T in4_data[], const int32_T *in4_size, int32_T in5,
  const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in6, const int32_T in7_data[], const
  int32_T in8_data[], const int32_T *in8_size)
{
  real_T in2_0;
  int32_T in3;
  int32_T in7;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;

  // MATLAB Function: '<S2>/calculate double diff'
  in2_0 = in2->PR[((in4_data[in5 - 1] - 1) * 50 + in3_data[0]) - 1] - in6->PR
    [((in8_data[in5 - 1] - 1) * 50 + in7_data[0]) - 1];
  in3 = in3_data[0];
  in7 = in7_data[0];
  in1_size[0] = 1;
  in1_size[1] = *in8_size == 1 ? *in4_size : *in8_size;
  stride_0_1 = (*in4_size != 1);
  stride_1_1 = (*in8_size != 1);
  loop_ub = *in8_size == 1 ? *in4_size : *in8_size;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[in1_size[0] * i] = in2_0 - (in2->PR[((in4_data[i * stride_0_1] - 1)
      * 50 + in3) - 1] - in6->PR[((in8_data[i * stride_1_1] - 1) * 50 + in7) - 1]);
  }

  // End of MATLAB Function: '<S2>/calculate double diff'
}

void DDRTCM::DDRTCM_binary_expand_op_bfmqb0(real_T in1_data[], int32_T in1_size
  [2], const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in2, const int32_T in3_data[],
  const int32_T in4_data[], const int32_T *in4_size, int32_T in5, const
  sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in6, const int32_T in7_data[], const int32_T
  in8_data[], const int32_T *in8_size)
{
  real_T in2_0;
  int32_T in3;
  int32_T in7;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;

  // MATLAB Function: '<S2>/calculate double diff'
  in2_0 = in2->DR[((in4_data[in5 - 1] - 1) * 50 + in3_data[0]) - 1] - in6->DR
    [((in8_data[in5 - 1] - 1) * 50 + in7_data[0]) - 1];
  in3 = in3_data[0];
  in7 = in7_data[0];
  in1_size[0] = 1;
  in1_size[1] = *in8_size == 1 ? *in4_size : *in8_size;
  stride_0_1 = (*in4_size != 1);
  stride_1_1 = (*in8_size != 1);
  loop_ub = *in8_size == 1 ? *in4_size : *in8_size;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[in1_size[0] * i] = in2_0 - (in2->DR[((in4_data[i * stride_0_1] - 1)
      * 50 + in3) - 1] - in6->DR[((in8_data[i * stride_1_1] - 1) * 50 + in7) - 1]);
  }

  // End of MATLAB Function: '<S2>/calculate double diff'
}

void DDRTCM::DDRTCM_binary_expand_op_bfmqb(real_T in1_data[], int32_T in1_size[2],
  const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in2, const int32_T in3_data[], const
  int32_T in4_data[], const int32_T *in4_size, int32_T in5, const
  sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in6, const int32_T in7_data[], const int32_T
  in8_data[], const int32_T *in8_size)
{
  real_T in2_0;
  int32_T in3;
  int32_T in7;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;

  // MATLAB Function: '<S2>/calculate double diff'
  in2_0 = in2->carrierphase[((in4_data[in5 - 1] - 1) * 50 + in3_data[0]) - 1] -
    in6->carrierphase[((in8_data[in5 - 1] - 1) * 50 + in7_data[0]) - 1];
  in3 = in3_data[0];
  in7 = in7_data[0];
  in1_size[0] = 1;
  in1_size[1] = *in8_size == 1 ? *in4_size : *in8_size;
  stride_0_1 = (*in4_size != 1);
  stride_1_1 = (*in8_size != 1);
  loop_ub = *in8_size == 1 ? *in4_size : *in8_size;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[in1_size[0] * i] = in2_0 - (in2->carrierphase[((in4_data[i *
      stride_0_1] - 1) * 50 + in3) - 1] - in6->carrierphase[((in8_data[i *
      stride_1_1] - 1) * 50 + in7) - 1]);
  }

  // End of MATLAB Function: '<S2>/calculate double diff'
}

void DDRTCM::DDRTCM_binary_expand_op_bfmq(real_T in1_data[], int32_T in1_size[2],
  const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in2, const int32_T in3_data[], int32_T
  in4, const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in5, const int32_T in6_data[],
  int32_T in7, const int32_T in8_data[], const int32_T *in8_size, const int32_T
  in9_data[], const int32_T *in9_size)
{
  real_T in2_0;
  int32_T in3;
  int32_T in6;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;

  // MATLAB Function: '<S2>/calculate double diff'
  in2_0 = in2->PR[(50 * in4 + in3_data[0]) - 1] - in5->PR[(50 * in7 + in6_data[0])
    - 1];
  in3 = in3_data[0];
  in6 = in6_data[0];
  in1_size[0] = 1;
  in1_size[1] = *in9_size == 1 ? *in8_size : *in9_size;
  stride_0_1 = (*in8_size != 1);
  stride_1_1 = (*in9_size != 1);
  loop_ub = *in9_size == 1 ? *in8_size : *in9_size;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[in1_size[0] * i] = in2_0 - (in2->PR[((in8_data[i * stride_0_1] - 1)
      * 50 + in3) - 1] - in5->PR[((in9_data[i * stride_1_1] - 1) * 50 + in6) - 1]);
  }

  // End of MATLAB Function: '<S2>/calculate double diff'
}

void DDRTCM::DDRTCM_binary_expand_op_bfm(real_T in1_data[], int32_T in1_size[2],
  const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in2, const int32_T in3_data[], int32_T
  in4, const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in5, const int32_T in6_data[],
  int32_T in7, const int32_T in8_data[], const int32_T *in8_size, const int32_T
  in9_data[], const int32_T *in9_size)
{
  real_T in2_0;
  int32_T in3;
  int32_T in6;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;

  // MATLAB Function: '<S2>/calculate double diff'
  in2_0 = in2->DR[(50 * in4 + in3_data[0]) - 1] - in5->DR[(50 * in7 + in6_data[0])
    - 1];
  in3 = in3_data[0];
  in6 = in6_data[0];
  in1_size[0] = 1;
  in1_size[1] = *in9_size == 1 ? *in8_size : *in9_size;
  stride_0_1 = (*in8_size != 1);
  stride_1_1 = (*in9_size != 1);
  loop_ub = *in9_size == 1 ? *in8_size : *in9_size;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[in1_size[0] * i] = in2_0 - (in2->DR[((in8_data[i * stride_0_1] - 1)
      * 50 + in3) - 1] - in5->DR[((in9_data[i * stride_1_1] - 1) * 50 + in6) - 1]);
  }

  // End of MATLAB Function: '<S2>/calculate double diff'
}

void DDRTCM::DDRTCM_binary_expand_op_bf(real_T in1_data[], int32_T in1_size[2],
  const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in2, const int32_T in3_data[], int32_T
  in4, const sk7S3MUBNIp13xZwazKdzDD_DDRTC_T *in5, const int32_T in6_data[],
  int32_T in7, const int32_T in8_data[], const int32_T *in8_size, const int32_T
  in9_data[], const int32_T *in9_size)
{
  real_T in2_0;
  int32_T in3;
  int32_T in6;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;

  // MATLAB Function: '<S2>/calculate double diff'
  in2_0 = in2->carrierphase[(50 * in4 + in3_data[0]) - 1] - in5->carrierphase
    [(50 * in7 + in6_data[0]) - 1];
  in3 = in3_data[0];
  in6 = in6_data[0];
  in1_size[0] = 1;
  in1_size[1] = *in9_size == 1 ? *in8_size : *in9_size;
  stride_0_1 = (*in8_size != 1);
  stride_1_1 = (*in9_size != 1);
  loop_ub = *in9_size == 1 ? *in8_size : *in9_size;
  for (int32_T i{0}; i < loop_ub; i++) {
    in1_data[in1_size[0] * i] = in2_0 - (in2->carrierphase[((in8_data[i *
      stride_0_1] - 1) * 50 + in3) - 1] - in5->carrierphase[((in9_data[i *
      stride_1_1] - 1) * 50 + in6) - 1]);
  }

  // End of MATLAB Function: '<S2>/calculate double diff'
}

// Model step function
void DDRTCM::step()
{
  // MATLAB Function: '<S4>/GNSS Measurement Epoch Splitter' incorporates:
  //   Inport: '<Root>/MeasurementEpochBus'

  DD_GNSSMeasurementEpochSplitter(&DDRTCM_U.MeasurementEpochBus, &DDRTCM_B.WNc_h,
    &DDRTCM_B.TOW_h, &DDRTCM_B.GalMeasurementBus, &DDRTCM_B.GpsMeasurementBus,
    &DDRTCM_B.sf_GNSSMeasurementEpochSplitter);

  // MATLAB Function: '<S4>/Calculate Day of Year'
  DDRTCM_CalculateDayofYear(DDRTCM_B.WNc_h, DDRTCM_B.TOW_h, &DDRTCM_B.Nr_GPS_L1,
    &DDRTCM_DW.sf_CalculateDayofYear);

  // MATLAB Function: '<Root>/Convert RTCM3 MSM4 for L1 and E1 to GNSS Measurement Bus' incorporates:
  //   Inport: '<Root>/RTCM_3_3_L1_E1_Bus'

  for (DDRTCM_B.i = 0; DDRTCM_B.i < 40; DDRTCM_B.i++) {
    DDRTCM_B.RTCM_3_3_L1_E1_Bus_SVID[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.SVID[DDRTCM_B.i];
    DDRTCM_B.useableIdx[DDRTCM_B.i] =
      (DDRTCM_U.RTCM_3_3_L1_E1_Bus.SVID[DDRTCM_B.i] != 0);
  }

  DDRTCM_B.nz = DDRTCM_B.useableIdx[0] - 1;
  for (DDRTCM_B.k = 0; DDRTCM_B.k < 39; DDRTCM_B.k++) {
    DDRTCM_B.nz += DDRTCM_B.useableIdx[DDRTCM_B.k + 1];
  }

  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_U.RTCM_3_3_L1_E1_Bus.TOW;
  DDRTCM_DW.SFunction_DIMS2_g.satellite_position[0] = 40;
  DDRTCM_DW.SFunction_DIMS2_g.satellite_position[1] = 3;
  DDRTCM_DW.SFunction_DIMS2_g.satellite_velocity[0] = 40;
  DDRTCM_DW.SFunction_DIMS2_g.satellite_velocity[1] = 3;
  std::memset(&DDRTCM_B.GnssMeasurementBase.satellite_position[0], 0, 120U *
              sizeof(real_T));
  std::memset(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0], 0, 120U *
              sizeof(real_T));
  DDRTCM_DW.SFunction_DIMS2_g.PRN = 40;
  DDRTCM_DW.SFunction_DIMS2_g.pseudorange = 40;
  DDRTCM_DW.SFunction_DIMS2_g.pseudorange_raw = 40;
  DDRTCM_DW.SFunction_DIMS2_g.pseudorange_satclk_corrected = 40;
  DDRTCM_DW.SFunction_DIMS2_g.deltarange = 40;
  DDRTCM_DW.SFunction_DIMS2_g.deltarange_raw = 40;
  DDRTCM_DW.SFunction_DIMS2_g.deltarange_satclk_corrected = 40;
  DDRTCM_DW.SFunction_DIMS2_g.variance_pseudorange = 40;
  DDRTCM_DW.SFunction_DIMS2_g.variance_pseudorange_measured = 40;
  DDRTCM_DW.SFunction_DIMS2_g.variance_deltarange = 40;
  DDRTCM_DW.SFunction_DIMS2_g.carrierphase = 40;
  DDRTCM_DW.SFunction_DIMS2_g.carrierphase_raw = 40;
  DDRTCM_DW.SFunction_DIMS2_g.carrierphase_satclk_corrected = 40;
  DDRTCM_DW.SFunction_DIMS2_g.variance_carrierphase_measured = 40;
  DDRTCM_DW.SFunction_DIMS2_g.locktime = 40;
  DDRTCM_DW.SFunction_DIMS2_g.CN0 = 40;
  DDRTCM_B.GnssMeasurementBase.base_position[0] =
    DDRTCM_U.RTCM_3_3_L1_E1_Bus.base[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] =
    DDRTCM_U.RTCM_3_3_L1_E1_Bus.base[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] =
    DDRTCM_U.RTCM_3_3_L1_E1_Bus.base[2];
  for (DDRTCM_B.i = 0; DDRTCM_B.i < 40; DDRTCM_B.i++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.SVID[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.Pseudorange[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.Carrier[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.i] = 0.0;
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.locktime[DDRTCM_B.i];
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.i] =
      DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
    DDRTCM_B.mesaurementEpochBase.SVID[DDRTCM_B.i] = 0U;
  }

  std::memset(&DDRTCM_B.mesaurementEpochBase.Pseudorange[0], 0, 200U * sizeof
              (real_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.Pseudorange_Sigma[0], 0, 200U *
              sizeof(real_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.Doppler[0], 0, 200U * sizeof(real_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.Type[0], 255, 200U * sizeof(uint8_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.Carrier[0], 0, 200U * sizeof(real_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.Carrier_Sigma[0], 0, 200U * sizeof
              (real_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.CN0[0], 0, 200U * sizeof(real_T));
  std::memset(&DDRTCM_B.mesaurementEpochBase.Locktime[0], 0, 200U * sizeof
              (real32_T));
  DDRTCM_B.trueCount = 0;
  for (DDRTCM_B.i = 0; DDRTCM_B.i < 40; DDRTCM_B.i++) {
    DDRTCM_B.FixPtRelationalOperator_p =
      (DDRTCM_U.RTCM_3_3_L1_E1_Bus.Carrier[DDRTCM_B.i] > 10000.0);
    DDRTCM_B.enable_gps_l1 = (DDRTCM_U.RTCM_3_3_L1_E1_Bus.Carrier[DDRTCM_B.i] <
      1.0E+10);
    if ((!DDRTCM_B.FixPtRelationalOperator_p) || (!DDRTCM_B.enable_gps_l1)) {
      DDRTCM_B.trueCount++;
    }

    DDRTCM_B.useableIdx[DDRTCM_B.i] = DDRTCM_B.FixPtRelationalOperator_p;
    DDRTCM_B.e[DDRTCM_B.i] = DDRTCM_B.enable_gps_l1;
  }

  DDRTCM_B.f_size_idx_0 = DDRTCM_B.trueCount;
  DDRTCM_B.trueCount = 0;
  for (DDRTCM_B.c_i = 0; DDRTCM_B.c_i < 40; DDRTCM_B.c_i++) {
    if ((!DDRTCM_B.useableIdx[DDRTCM_B.c_i]) || (!DDRTCM_B.e[DDRTCM_B.c_i])) {
      DDRTCM_B.f_data[DDRTCM_B.trueCount] = static_cast<int8_T>(DDRTCM_B.c_i + 1);
      DDRTCM_B.trueCount++;
    }
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.f_size_idx_0; DDRTCM_B.b_k++) {
    DDRTCM_B.RTCM_3_3_L1_E1_Bus_SVID[DDRTCM_B.f_data[DDRTCM_B.b_k] - 1] =
      MAX_uint8_T;
  }

  DDRTCM_B.mesaurementEpochBase.TOW = DDRTCM_U.RTCM_3_3_L1_E1_Bus.TOW;
  DDRTCM_B.mesaurementEpochBase.WNc = 0U;
  DDRTCM_B.mesaurementEpochBase.N = 40U;
  if (DDRTCM_B.nz + 1 < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_B.nz;
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k <= DDRTCM_B.c_i; DDRTCM_B.b_k++) {
    DDRTCM_B.mesaurementEpochBase.SVID[DDRTCM_B.b_k] =
      DDRTCM_B.RTCM_3_3_L1_E1_Bus_SVID[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.i = 0; DDRTCM_B.i <= DDRTCM_B.nz; DDRTCM_B.i++) {
    if ((DDRTCM_B.mesaurementEpochBase.SVID[DDRTCM_B.i] > 0) &&
        (DDRTCM_B.mesaurementEpochBase.SVID[DDRTCM_B.i] <= 37)) {
      DDRTCM_B.mesaurementEpochBase.Type[5 * DDRTCM_B.i] = 0U;
      DDRTCM_B.mesaurementEpochBase.Pseudorange[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.Pseudorange[DDRTCM_B.i];
      DDRTCM_B.mesaurementEpochBase.Doppler[5 * DDRTCM_B.i] = 0.0;
      DDRTCM_B.mesaurementEpochBase.Carrier[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.Carrier[DDRTCM_B.i];
      DDRTCM_B.mesaurementEpochBase.CN0[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
      DDRTCM_B.mesaurementEpochBase.Locktime[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.locktime[DDRTCM_B.i];
    }

    if ((DDRTCM_B.mesaurementEpochBase.SVID[DDRTCM_B.i] > 70) &&
        (DDRTCM_B.mesaurementEpochBase.SVID[DDRTCM_B.i] <= 102)) {
      DDRTCM_B.mesaurementEpochBase.Type[5 * DDRTCM_B.i] = 17U;
      DDRTCM_B.mesaurementEpochBase.Pseudorange[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.Pseudorange[DDRTCM_B.i];
      DDRTCM_B.mesaurementEpochBase.Doppler[5 * DDRTCM_B.i] = 0.0;
      DDRTCM_B.mesaurementEpochBase.Carrier[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.Carrier[DDRTCM_B.i];
      DDRTCM_B.mesaurementEpochBase.CN0[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.CN0[DDRTCM_B.i];
      DDRTCM_B.mesaurementEpochBase.Locktime[5 * DDRTCM_B.i] =
        DDRTCM_U.RTCM_3_3_L1_E1_Bus.locktime[DDRTCM_B.i];
    }
  }

  // MATLAB Function: '<S4>/MATLAB Function'
  DDRTCM_MATLABFunction_o(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.SFunction_DIMS2_g, &DDRTCM_B.sf_MATLABFunction_o,
    &DDRTCM_DW.sf_MATLABFunction_o);

  // Outputs for Atomic SubSystem: '<S4>/Mode Switch'
  // UnitDelay: '<S133>/Delay Input1'
  //
  //  Block description for '<S133>/Delay Input1':
  //
  //   Store in Global RAM

  DDRTCM_B.dayOfYear = DDRTCM_DW.DelayInput1_DSTATE_i;

  // RelationalOperator: '<S133>/FixPt Relational Operator' incorporates:
  //   BusSelector: '<S4>/Bus Selector3'
  //   UnitDelay: '<S133>/Delay Input1'
  //
  //  Block description for '<S133>/Delay Input1':
  //
  //   Store in Global RAM

  DDRTCM_B.FixPtRelationalOperator_p =
    (DDRTCM_B.sf_MATLABFunction_o.GpsMeasurementB.time_receive !=
     DDRTCM_DW.DelayInput1_DSTATE_i);

  // DiscreteIntegrator: '<S129>/Discrete-Time Integrator' incorporates:
  //   Constant: '<S129>/Constant1'

  if (DDRTCM_B.FixPtRelationalOperator_p &&
      (DDRTCM_DW.DiscreteTimeIntegrator_PrevRe_n <= 0)) {
    DDRTCM_DW.DiscreteTimeIntegrator_DSTATE_l = DDRTCM_P.Constant1_Value;
  }

  // Chart: '<S130>/choose correction mode' incorporates:
  //   CombinatorialLogic: '<S134>/Logic'
  //   Constant: '<S132>/Constant'
  //   DiscreteIntegrator: '<S129>/Discrete-Time Integrator'
  //   Memory: '<S134>/Memory'
  //   RelationalOperator: '<S132>/Compare'

  DDRTCM_DW.Memory_PreviousInput_h = DDRTCM_P.Logic_table
    [(((static_cast<uint32_T>(DDRTCM_B.FixPtRelationalOperator_p) << 1) +
       (DDRTCM_DW.DiscreteTimeIntegrator_DSTATE_l >
        DDRTCM_P.CompareToConstant_const)) << 1) +
    DDRTCM_DW.Memory_PreviousInput_h];

  // MATLAB Function: '<S21>/Measurement Epoch Splitter' incorporates:
  //   Inport: '<Root>/MeasurementEpochBus'

  DDRTCM_MeasurementEpochSplitter(&DDRTCM_U.MeasurementEpochBus,
    &DDRTCM_B.dayOfYear, &DDRTCM_B.Nr_Galileo, &DDRTCM_B.Nr_GPS_L2,
    &DDRTCM_B.sf_MeasurementEpochSplitter);

  // Chart: '<S130>/choose correction mode' incorporates:
  //   Constant: '<S130>/Constant2'
  //   Constant: '<S130>/Constant3'
  //   Constant: '<S130>/Constant4'
  //   Constant: '<S130>/Constant5'
  //   Constant: '<S130>/Constant6'
  //   Inport: '<Root>/GNSSParametersBus'
  //   Sum: '<S130>/Sum'

  DDRTCM_choosecorrectionmode(DDRTCM_DW.Memory_PreviousInput_h,
    DDRTCM_B.dayOfYear, DDRTCM_B.Nr_Galileo + DDRTCM_B.Nr_GPS_L2,
    DDRTCM_P.Constant3_Value, DDRTCM_P.Constant4_Value, DDRTCM_P.Constant5_Value,
    DDRTCM_P.Constant6_Value, DDRTCM_P.Constant2_Value,
    &DDRTCM_U.GNSSParametersBus, &DDRTCM_B.state_o, &DDRTCM_B.parameters_gnss_i,
    &DDRTCM_DW.sf_choosecorrectionmode);

  // Update for UnitDelay: '<S133>/Delay Input1' incorporates:
  //   BusSelector: '<S4>/Bus Selector3'
  //
  //  Block description for '<S133>/Delay Input1':
  //
  //   Store in Global RAM

  DDRTCM_DW.DelayInput1_DSTATE_i =
    DDRTCM_B.sf_MATLABFunction_o.GpsMeasurementB.time_receive;

  // Update for DiscreteIntegrator: '<S129>/Discrete-Time Integrator' incorporates:
  //   Constant: '<S129>/Constant'

  DDRTCM_DW.DiscreteTimeIntegrator_DSTATE_l +=
    DDRTCM_P.DiscreteTimeIntegrator_gainval * DDRTCM_P.Constant_Value;
  DDRTCM_DW.DiscreteTimeIntegrator_PrevRe_n = static_cast<int8_T>
    (DDRTCM_B.FixPtRelationalOperator_p);

  // End of Outputs for SubSystem: '<S4>/Mode Switch'

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_1_Threshold) {
    DDRTCM_B.FixPtRelationalOperator_p =
      DDRTCM_B.parameters_gnss_i.gps.enable_gps;
  } else {
    DDRTCM_B.FixPtRelationalOperator_p =
      DDRTCM_U.GNSSParametersBus.gps.enable_gps;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_2_Threshold) {
    DDRTCM_B.enable_gps_l1 = DDRTCM_B.parameters_gnss_i.gps.enable_gps_l1;
  } else {
    DDRTCM_B.enable_gps_l1 = DDRTCM_U.GNSSParametersBus.gps.enable_gps_l1;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_3_Threshold) {
    DDRTCM_B.enable_gps_l2 = DDRTCM_B.parameters_gnss_i.gps.enable_gps_l2;
  } else {
    DDRTCM_B.enable_gps_l2 = DDRTCM_U.GNSSParametersBus.gps.enable_gps_l2;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_4_Threshold) {
    DDRTCM_B.enable_galileo = DDRTCM_B.parameters_gnss_i.galileo.enable_galileo;
  } else {
    DDRTCM_B.enable_galileo = DDRTCM_U.GNSSParametersBus.galileo.enable_galileo;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_5_Threshold) {
    DDRTCM_B.enable_galileo_e1 =
      DDRTCM_B.parameters_gnss_i.galileo.enable_galileo_e1;
  } else {
    DDRTCM_B.enable_galileo_e1 =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e1;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_6_Threshold) {
    DDRTCM_B.enable_galileo_e5a =
      DDRTCM_B.parameters_gnss_i.galileo.enable_galileo_e5a;
  } else {
    DDRTCM_B.enable_galileo_e5a =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5a;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_7_Threshold) {
    DDRTCM_B.enable_galileo_e5b =
      DDRTCM_B.parameters_gnss_i.galileo.enable_galileo_e5b;
  } else {
    DDRTCM_B.enable_galileo_e5b =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5b;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_8_Threshold) {
    DDRTCM_B.enable_galileo_e5 =
      DDRTCM_B.parameters_gnss_i.galileo.enable_galileo_e5;
  } else {
    DDRTCM_B.enable_galileo_e5 =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_9_Threshold) {
    DDRTCM_B.enable_gate = DDRTCM_B.parameters_gnss_i.gate.enable_gate;
  } else {
    DDRTCM_B.enable_gate = DDRTCM_U.GNSSParametersBus.gate.enable_gate;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_10_Threshold) {
    DDRTCM_B.prn_psl1 = DDRTCM_B.parameters_gnss_i.gate.prn_psl1;
  } else {
    DDRTCM_B.prn_psl1 = DDRTCM_U.GNSSParametersBus.gate.prn_psl1;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_11_Threshold) {
    DDRTCM_B.prn_psl2 = DDRTCM_B.parameters_gnss_i.gate.prn_psl2;
  } else {
    DDRTCM_B.prn_psl2 = DDRTCM_U.GNSSParametersBus.gate.prn_psl2;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_12_Threshold) {
    DDRTCM_B.prn_psl3 = DDRTCM_B.parameters_gnss_i.gate.prn_psl3;
  } else {
    DDRTCM_B.prn_psl3 = DDRTCM_U.GNSSParametersBus.gate.prn_psl3;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_13_Threshold) {
    DDRTCM_B.prn_psl4 = DDRTCM_B.parameters_gnss_i.gate.prn_psl4;
  } else {
    DDRTCM_B.prn_psl4 = DDRTCM_U.GNSSParametersBus.gate.prn_psl4;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_14_Threshold) {
    DDRTCM_B.prn_psl5 = DDRTCM_B.parameters_gnss_i.gate.prn_psl5;
  } else {
    DDRTCM_B.prn_psl5 = DDRTCM_U.GNSSParametersBus.gate.prn_psl5;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_15_Threshold) {
    DDRTCM_B.prn_psl6 = DDRTCM_B.parameters_gnss_i.gate.prn_psl6;
  } else {
    DDRTCM_B.prn_psl6 = DDRTCM_U.GNSSParametersBus.gate.prn_psl6;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_16_Threshold) {
    DDRTCM_B.prn_psl7 = DDRTCM_B.parameters_gnss_i.gate.prn_psl7;
  } else {
    DDRTCM_B.prn_psl7 = DDRTCM_U.GNSSParametersBus.gate.prn_psl7;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_17_Threshold) {
    DDRTCM_B.prn_psl8 = DDRTCM_B.parameters_gnss_i.gate.prn_psl8;
  } else {
    DDRTCM_B.prn_psl8 = DDRTCM_U.GNSSParametersBus.gate.prn_psl8;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_18_Threshold) {
    DDRTCM_B.prn_psl9 = DDRTCM_B.parameters_gnss_i.gate.prn_psl9;
  } else {
    DDRTCM_B.prn_psl9 = DDRTCM_U.GNSSParametersBus.gate.prn_psl9;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_19_Threshold) {
    DDRTCM_B.elevation_mask = DDRTCM_B.parameters_gnss_i.elevation_mask;
  } else {
    DDRTCM_B.elevation_mask = DDRTCM_U.GNSSParametersBus.elevation_mask;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_20_Threshold) {
    DDRTCM_B.enable_galileo_timebase =
      DDRTCM_B.parameters_gnss_i.enable_galileo_timebase;
  } else {
    DDRTCM_B.enable_galileo_timebase =
      DDRTCM_U.GNSSParametersBus.enable_galileo_timebase;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_21_Threshold) {
    DDRTCM_B.enable_differential_correct =
      DDRTCM_B.parameters_gnss_i.enable_differential_correction;
  } else {
    DDRTCM_B.enable_differential_correct =
      DDRTCM_U.GNSSParametersBus.enable_differential_correction;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_22_Threshold) {
    DDRTCM_B.enable_tropospheric_correct =
      DDRTCM_B.parameters_gnss_i.enable_tropospheric_correction;
  } else {
    DDRTCM_B.enable_tropospheric_correct =
      DDRTCM_U.GNSSParametersBus.enable_tropospheric_correction;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_23_Threshold) {
    DDRTCM_B.enable_ionospheric_correcti =
      DDRTCM_B.parameters_gnss_i.enable_ionospheric_correction;
  } else {
    DDRTCM_B.enable_ionospheric_correcti =
      DDRTCM_U.GNSSParametersBus.enable_ionospheric_correction;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_24_Threshold) {
    DDRTCM_B.enable_SatPosVel_calculatio =
      DDRTCM_B.parameters_gnss_i.enable_SatPosVel_calculation;
  } else {
    DDRTCM_B.enable_SatPosVel_calculatio =
      DDRTCM_U.GNSSParametersBus.enable_SatPosVel_calculation;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_25_Threshold) {
    DDRTCM_B.enable_WL_correction =
      DDRTCM_B.parameters_gnss_i.enable_WL_correction;
  } else {
    DDRTCM_B.enable_WL_correction =
      DDRTCM_U.GNSSParametersBus.enable_WL_correction;
  }

  // Switch generated from: '<S4>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_26_Threshold) {
    DDRTCM_B.use_measured_variance =
      DDRTCM_B.parameters_gnss_i.use_measured_variance;
  } else {
    DDRTCM_B.use_measured_variance =
      DDRTCM_U.GNSSParametersBus.use_measured_variance;
  }

  // Outputs for Enabled SubSystem: '<S4>/GPS'
  // Inport: '<Root>/GPSNavBus' incorporates:
  //   Inport: '<Root>/GPSIONBus'
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_GPS(&DDRTCM_B.GalMeasurementBus, DDRTCM_U.GPSNavBus.TOW,
             DDRTCM_U.GPSNavBus.WNc, DDRTCM_U.GPSNavBus.SVID,
             DDRTCM_U.GPSNavBus.Health, DDRTCM_U.GPSNavBus.IODC,
             DDRTCM_U.GPSNavBus.IODE, DDRTCM_U.GPSNavBus.T_gd,
             DDRTCM_U.GPSNavBus.T_oc, DDRTCM_U.GPSNavBus.A_f2,
             DDRTCM_U.GPSNavBus.A_f1, DDRTCM_U.GPSNavBus.A_f0,
             DDRTCM_U.GPSNavBus.C_rs, DDRTCM_U.GPSNavBus.DELTA_N,
             DDRTCM_U.GPSNavBus.M_0, DDRTCM_U.GPSNavBus.C_uc,
             DDRTCM_U.GPSNavBus.E, DDRTCM_U.GPSNavBus.C_us,
             DDRTCM_U.GPSNavBus.SQRT_A, DDRTCM_U.GPSNavBus.T_oe,
             DDRTCM_U.GPSNavBus.C_ic, DDRTCM_U.GPSNavBus.OMEGA_0,
             DDRTCM_U.GPSNavBus.C_is, DDRTCM_U.GPSNavBus.I_0,
             DDRTCM_U.GPSNavBus.C_rc, DDRTCM_U.GPSNavBus.omega,
             DDRTCM_U.GPSNavBus.OMEGADOT, DDRTCM_U.GPSNavBus.IDOT,
             DDRTCM_U.GPSNavBus.WNt_oc, DDRTCM_U.GPSNavBus.WNt_oe,
             DDRTCM_U.GPSIONBus.TOW, DDRTCM_U.GPSIONBus.WNc,
             DDRTCM_U.GPSIONBus.SVID, DDRTCM_U.GPSIONBus.alpha_0,
             DDRTCM_U.GPSIONBus.alpha_1, DDRTCM_U.GPSIONBus.alpha_2,
             DDRTCM_U.GPSIONBus.alpha_3, DDRTCM_U.GPSIONBus.beta_0,
             DDRTCM_U.GPSIONBus.beta_1, DDRTCM_U.GPSIONBus.beta_2,
             DDRTCM_U.GPSIONBus.beta_3, DDRTCM_U.usePosLLHArray,
             DDRTCM_B.Nr_GPS_L1, DDRTCM_B.FixPtRelationalOperator_p,
             DDRTCM_B.enable_gps_l1, DDRTCM_B.enable_gps_l2,
             DDRTCM_B.elevation_mask, DDRTCM_B.enable_differential_correct,
             DDRTCM_B.enable_tropospheric_correct,
             DDRTCM_B.enable_ionospheric_correcti,
             DDRTCM_B.enable_SatPosVel_calculatio, DDRTCM_B.enable_WL_correction,
             DDRTCM_B.use_measured_variance,
             &DDRTCM_B.sf_MATLABFunction_o.GpsMeasurementB,
             &DDRTCM_DW.sf_MATLABFunction_o.SFunction_DIMS2, &DDRTCM_B.GPS,
             &DDRTCM_DW.GPS, &DDRTCM_P.GPS);

  // End of Outputs for SubSystem: '<S4>/GPS'

  // Outputs for Enabled SubSystem: '<S4>/Galileo'
  // Inport: '<Root>/GALNavBus' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_Galileo(&DDRTCM_B.GpsMeasurementBus, DDRTCM_U.GALNavBus.TOW,
                 DDRTCM_U.GALNavBus.WNc, DDRTCM_U.GALNavBus.SVID,
                 DDRTCM_U.GALNavBus.SQRT_A, DDRTCM_U.GALNavBus.M_0,
                 DDRTCM_U.GALNavBus.E, DDRTCM_U.GALNavBus.I_0,
                 DDRTCM_U.GALNavBus.omega, DDRTCM_U.GALNavBus.OMEGA_0,
                 DDRTCM_U.GALNavBus.OMEGADOT, DDRTCM_U.GALNavBus.IDOT,
                 DDRTCM_U.GALNavBus.DELTA_N, DDRTCM_U.GALNavBus.C_uc,
                 DDRTCM_U.GALNavBus.C_us, DDRTCM_U.GALNavBus.C_rc,
                 DDRTCM_U.GALNavBus.C_rs, DDRTCM_U.GALNavBus.C_ic,
                 DDRTCM_U.GALNavBus.C_is, DDRTCM_U.GALNavBus.T_oc,
                 DDRTCM_U.GALNavBus.T_oe, DDRTCM_U.GALNavBus.A_f2,
                 DDRTCM_U.GALNavBus.A_f1, DDRTCM_U.GALNavBus.A_f0,
                 DDRTCM_U.GALNavBus.WNt_oc, DDRTCM_U.GALNavBus.WNt_oe,
                 DDRTCM_U.GALNavBus.IODnav, DDRTCM_U.usePosLLHArray,
                 DDRTCM_B.Nr_GPS_L1, DDRTCM_B.enable_galileo,
                 DDRTCM_B.enable_galileo_e1, DDRTCM_B.enable_galileo_e5a,
                 DDRTCM_B.enable_galileo_e5b, DDRTCM_B.enable_galileo_e5,
                 DDRTCM_B.enable_differential_correct,
                 DDRTCM_B.enable_ionospheric_correcti,
                 DDRTCM_B.enable_tropospheric_correct,
                 DDRTCM_B.enable_SatPosVel_calculatio,
                 DDRTCM_B.use_measured_variance, DDRTCM_B.elevation_mask,
                 &DDRTCM_B.sf_MATLABFunction_o.GalMeasurementB,
                 &DDRTCM_DW.sf_MATLABFunction_o.SFunction_DIMS3,
                 &DDRTCM_B.Galileo, &DDRTCM_DW.Galileo, &DDRTCM_P.Galileo);

  // End of Outputs for SubSystem: '<S4>/Galileo'

  // MATLAB Function: '<S5>/GNSS Measurement Epoch Splitter'
  DD_GNSSMeasurementEpochSplitter(&DDRTCM_B.mesaurementEpochBase,
    &DDRTCM_B.state_o, &DDRTCM_B.TOW, &DDRTCM_B.GpsMeasurementBus,
    &DDRTCM_B.GalMeasurementBus, &DDRTCM_B.sf_GNSSMeasurementEpochSplitt_n);

  // MATLAB Function: '<S5>/Calculate Day of Year'
  DDRTCM_CalculateDayofYear(DDRTCM_B.state_o, DDRTCM_B.TOW, &DDRTCM_B.dayOfYear,
    &DDRTCM_DW.sf_CalculateDayofYear_d);

  // MATLAB Function: '<S5>/MATLAB Function'
  DDRTCM_MATLABFunction_o(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.SFunction_DIMS2_g, &DDRTCM_B.sf_MATLABFunction_k,
    &DDRTCM_DW.sf_MATLABFunction_k);

  // Outputs for Atomic SubSystem: '<S5>/Mode Switch'
  // UnitDelay: '<S260>/Delay Input1'
  //
  //  Block description for '<S260>/Delay Input1':
  //
  //   Store in Global RAM

  DDRTCM_B.Nr_GPS_L1 = DDRTCM_DW.DelayInput1_DSTATE;

  // RelationalOperator: '<S260>/FixPt Relational Operator' incorporates:
  //   BusSelector: '<S5>/Bus Selector3'
  //   UnitDelay: '<S260>/Delay Input1'
  //
  //  Block description for '<S260>/Delay Input1':
  //
  //   Store in Global RAM

  DDRTCM_B.FixPtRelationalOperator =
    (DDRTCM_B.sf_MATLABFunction_k.GpsMeasurementB.time_receive !=
     DDRTCM_DW.DelayInput1_DSTATE);

  // DiscreteIntegrator: '<S256>/Discrete-Time Integrator' incorporates:
  //   Constant: '<S256>/Constant1'

  if (DDRTCM_B.FixPtRelationalOperator &&
      (DDRTCM_DW.DiscreteTimeIntegrator_PrevRese <= 0)) {
    DDRTCM_DW.DiscreteTimeIntegrator_DSTATE = DDRTCM_P.Constant1_Value_b;
  }

  // Memory: '<S261>/Memory'
  DDRTCM_B.useOriginalGNSSmeasurement = DDRTCM_DW.Memory_PreviousInput;

  // Chart: '<S257>/choose correction mode' incorporates:
  //   CombinatorialLogic: '<S261>/Logic'
  //   Constant: '<S259>/Constant'
  //   DiscreteIntegrator: '<S256>/Discrete-Time Integrator'
  //   Memory: '<S261>/Memory'
  //   RelationalOperator: '<S259>/Compare'

  DDRTCM_DW.Memory_PreviousInput = DDRTCM_P.Logic_table_k
    [(((static_cast<uint32_T>(DDRTCM_B.FixPtRelationalOperator) << 1) +
       (DDRTCM_DW.DiscreteTimeIntegrator_DSTATE >
        DDRTCM_P.CompareToConstant_const_j)) << 1) +
    DDRTCM_DW.Memory_PreviousInput];

  // MATLAB Function: '<S148>/Measurement Epoch Splitter'
  DDRTCM_MeasurementEpochSplitter(&DDRTCM_B.mesaurementEpochBase,
    &DDRTCM_B.Nr_GPS_L1, &DDRTCM_B.Nr_GPS_L2, &DDRTCM_B.Nr_Galileo,
    &DDRTCM_B.sf_MeasurementEpochSplitter_l);

  // Chart: '<S257>/choose correction mode' incorporates:
  //   Constant: '<S257>/Constant2'
  //   Constant: '<S257>/Constant3'
  //   Constant: '<S257>/Constant4'
  //   Constant: '<S257>/Constant5'
  //   Constant: '<S257>/Constant6'
  //   Inport: '<Root>/GNSSParametersBus'
  //   Sum: '<S257>/Sum'

  DDRTCM_choosecorrectionmode(DDRTCM_DW.Memory_PreviousInput, DDRTCM_B.Nr_GPS_L1,
    DDRTCM_B.Nr_GPS_L2 + DDRTCM_B.Nr_Galileo, DDRTCM_P.Constant3_Value_n,
    DDRTCM_P.Constant4_Value_l, DDRTCM_P.Constant5_Value_k,
    DDRTCM_P.Constant6_Value_n, DDRTCM_P.Constant2_Value_m,
    &DDRTCM_U.GNSSParametersBus, &DDRTCM_B.state, &DDRTCM_B.parameters_gnss,
    &DDRTCM_DW.sf_choosecorrectionmode_l);

  // Update for UnitDelay: '<S260>/Delay Input1' incorporates:
  //   BusSelector: '<S5>/Bus Selector3'
  //
  //  Block description for '<S260>/Delay Input1':
  //
  //   Store in Global RAM

  DDRTCM_DW.DelayInput1_DSTATE =
    DDRTCM_B.sf_MATLABFunction_k.GpsMeasurementB.time_receive;

  // Update for DiscreteIntegrator: '<S256>/Discrete-Time Integrator' incorporates:
  //   Constant: '<S256>/Constant'

  DDRTCM_DW.DiscreteTimeIntegrator_DSTATE +=
    DDRTCM_P.DiscreteTimeIntegrator_gainva_e * DDRTCM_P.Constant_Value_m;
  DDRTCM_DW.DiscreteTimeIntegrator_PrevRese = static_cast<int8_T>
    (DDRTCM_B.FixPtRelationalOperator);

  // End of Outputs for SubSystem: '<S5>/Mode Switch'

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_1_Threshold_b) {
    DDRTCM_B.FixPtRelationalOperator = DDRTCM_B.parameters_gnss.gps.enable_gps;
  } else {
    DDRTCM_B.FixPtRelationalOperator = DDRTCM_U.GNSSParametersBus.gps.enable_gps;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_2_Threshold_b) {
    DDRTCM_B.enable_gps_l1_g = DDRTCM_B.parameters_gnss.gps.enable_gps_l1;
  } else {
    DDRTCM_B.enable_gps_l1_g = DDRTCM_U.GNSSParametersBus.gps.enable_gps_l1;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_3_Threshold_b) {
    DDRTCM_B.enable_gps_l2_j = DDRTCM_B.parameters_gnss.gps.enable_gps_l2;
  } else {
    DDRTCM_B.enable_gps_l2_j = DDRTCM_U.GNSSParametersBus.gps.enable_gps_l2;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_4_Threshold_b) {
    DDRTCM_B.enable_galileo_n = DDRTCM_B.parameters_gnss.galileo.enable_galileo;
  } else {
    DDRTCM_B.enable_galileo_n =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_5_Threshold_b) {
    DDRTCM_B.enable_galileo_e1_j =
      DDRTCM_B.parameters_gnss.galileo.enable_galileo_e1;
  } else {
    DDRTCM_B.enable_galileo_e1_j =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e1;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_6_Threshold_b) {
    DDRTCM_B.enable_galileo_e5a_a =
      DDRTCM_B.parameters_gnss.galileo.enable_galileo_e5a;
  } else {
    DDRTCM_B.enable_galileo_e5a_a =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5a;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_7_Threshold_b) {
    DDRTCM_B.enable_galileo_e5b_d =
      DDRTCM_B.parameters_gnss.galileo.enable_galileo_e5b;
  } else {
    DDRTCM_B.enable_galileo_e5b_d =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5b;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_8_Threshold_b) {
    DDRTCM_B.enable_galileo_e5_f =
      DDRTCM_B.parameters_gnss.galileo.enable_galileo_e5;
  } else {
    DDRTCM_B.enable_galileo_e5_f =
      DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_9_Threshold_b) {
    DDRTCM_B.enable_gate_f = DDRTCM_B.parameters_gnss.gate.enable_gate;
  } else {
    DDRTCM_B.enable_gate_f = DDRTCM_U.GNSSParametersBus.gate.enable_gate;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_10_Threshold_b) {
    DDRTCM_B.prn_psl1_b = DDRTCM_B.parameters_gnss.gate.prn_psl1;
  } else {
    DDRTCM_B.prn_psl1_b = DDRTCM_U.GNSSParametersBus.gate.prn_psl1;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_11_Threshold_b) {
    DDRTCM_B.prn_psl2_o = DDRTCM_B.parameters_gnss.gate.prn_psl2;
  } else {
    DDRTCM_B.prn_psl2_o = DDRTCM_U.GNSSParametersBus.gate.prn_psl2;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_12_Threshold_b) {
    DDRTCM_B.prn_psl3_o = DDRTCM_B.parameters_gnss.gate.prn_psl3;
  } else {
    DDRTCM_B.prn_psl3_o = DDRTCM_U.GNSSParametersBus.gate.prn_psl3;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_13_Threshold_b) {
    DDRTCM_B.prn_psl4_a = DDRTCM_B.parameters_gnss.gate.prn_psl4;
  } else {
    DDRTCM_B.prn_psl4_a = DDRTCM_U.GNSSParametersBus.gate.prn_psl4;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_14_Threshold_b) {
    DDRTCM_B.prn_psl5_i = DDRTCM_B.parameters_gnss.gate.prn_psl5;
  } else {
    DDRTCM_B.prn_psl5_i = DDRTCM_U.GNSSParametersBus.gate.prn_psl5;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_15_Threshold_b) {
    DDRTCM_B.prn_psl6_f = DDRTCM_B.parameters_gnss.gate.prn_psl6;
  } else {
    DDRTCM_B.prn_psl6_f = DDRTCM_U.GNSSParametersBus.gate.prn_psl6;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_16_Threshold_b) {
    DDRTCM_B.prn_psl7_m = DDRTCM_B.parameters_gnss.gate.prn_psl7;
  } else {
    DDRTCM_B.prn_psl7_m = DDRTCM_U.GNSSParametersBus.gate.prn_psl7;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_17_Threshold_b) {
    DDRTCM_B.prn_psl8_f = DDRTCM_B.parameters_gnss.gate.prn_psl8;
  } else {
    DDRTCM_B.prn_psl8_f = DDRTCM_U.GNSSParametersBus.gate.prn_psl8;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_18_Threshold_b) {
    DDRTCM_B.prn_psl9_j = DDRTCM_B.parameters_gnss.gate.prn_psl9;
  } else {
    DDRTCM_B.prn_psl9_j = DDRTCM_U.GNSSParametersBus.gate.prn_psl9;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_19_Threshold_b) {
    DDRTCM_B.Nr_GPS_L1 = DDRTCM_B.parameters_gnss.elevation_mask;
  } else {
    DDRTCM_B.Nr_GPS_L1 = DDRTCM_U.GNSSParametersBus.elevation_mask;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_20_Threshold_b) {
    DDRTCM_B.enable_galileo_timebase_c =
      DDRTCM_B.parameters_gnss.enable_galileo_timebase;
  } else {
    DDRTCM_B.enable_galileo_timebase_c =
      DDRTCM_U.GNSSParametersBus.enable_galileo_timebase;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_21_Threshold_b) {
    DDRTCM_B.enable_differential_corre_n =
      DDRTCM_B.parameters_gnss.enable_differential_correction;
  } else {
    DDRTCM_B.enable_differential_corre_n =
      DDRTCM_U.GNSSParametersBus.enable_differential_correction;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_22_Threshold_b) {
    DDRTCM_B.enable_tropospheric_corre_o =
      DDRTCM_B.parameters_gnss.enable_tropospheric_correction;
  } else {
    DDRTCM_B.enable_tropospheric_corre_o =
      DDRTCM_U.GNSSParametersBus.enable_tropospheric_correction;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_23_Threshold_b) {
    DDRTCM_B.enable_ionospheric_correc_o =
      DDRTCM_B.parameters_gnss.enable_ionospheric_correction;
  } else {
    DDRTCM_B.enable_ionospheric_correc_o =
      DDRTCM_U.GNSSParametersBus.enable_ionospheric_correction;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_24_Threshold_b) {
    DDRTCM_B.enable_SatPosVel_calculat_m =
      DDRTCM_B.parameters_gnss.enable_SatPosVel_calculation;
  } else {
    DDRTCM_B.enable_SatPosVel_calculat_m =
      DDRTCM_U.GNSSParametersBus.enable_SatPosVel_calculation;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_25_Threshold_b) {
    DDRTCM_B.enable_WL_correction_k =
      DDRTCM_B.parameters_gnss.enable_WL_correction;
  } else {
    DDRTCM_B.enable_WL_correction_k =
      DDRTCM_U.GNSSParametersBus.enable_WL_correction;
  }

  // Switch generated from: '<S5>/Switch' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/useModeSwitchLogic'

  if (DDRTCM_U.useModeSwitchLogic > DDRTCM_P.Switch_26_Threshold_b) {
    DDRTCM_B.use_measured_variance_m =
      DDRTCM_B.parameters_gnss.use_measured_variance;
  } else {
    DDRTCM_B.use_measured_variance_m =
      DDRTCM_U.GNSSParametersBus.use_measured_variance;
  }

  // Outputs for Enabled SubSystem: '<S5>/GPS'
  // Inport: '<Root>/GPSNavBus' incorporates:
  //   Inport: '<Root>/GPSIONBus'
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_GPS(&DDRTCM_B.GpsMeasurementBus, DDRTCM_U.GPSNavBus.TOW,
             DDRTCM_U.GPSNavBus.WNc, DDRTCM_U.GPSNavBus.SVID,
             DDRTCM_U.GPSNavBus.Health, DDRTCM_U.GPSNavBus.IODC,
             DDRTCM_U.GPSNavBus.IODE, DDRTCM_U.GPSNavBus.T_gd,
             DDRTCM_U.GPSNavBus.T_oc, DDRTCM_U.GPSNavBus.A_f2,
             DDRTCM_U.GPSNavBus.A_f1, DDRTCM_U.GPSNavBus.A_f0,
             DDRTCM_U.GPSNavBus.C_rs, DDRTCM_U.GPSNavBus.DELTA_N,
             DDRTCM_U.GPSNavBus.M_0, DDRTCM_U.GPSNavBus.C_uc,
             DDRTCM_U.GPSNavBus.E, DDRTCM_U.GPSNavBus.C_us,
             DDRTCM_U.GPSNavBus.SQRT_A, DDRTCM_U.GPSNavBus.T_oe,
             DDRTCM_U.GPSNavBus.C_ic, DDRTCM_U.GPSNavBus.OMEGA_0,
             DDRTCM_U.GPSNavBus.C_is, DDRTCM_U.GPSNavBus.I_0,
             DDRTCM_U.GPSNavBus.C_rc, DDRTCM_U.GPSNavBus.omega,
             DDRTCM_U.GPSNavBus.OMEGADOT, DDRTCM_U.GPSNavBus.IDOT,
             DDRTCM_U.GPSNavBus.WNt_oc, DDRTCM_U.GPSNavBus.WNt_oe,
             DDRTCM_U.GPSIONBus.TOW, DDRTCM_U.GPSIONBus.WNc,
             DDRTCM_U.GPSIONBus.SVID, DDRTCM_U.GPSIONBus.alpha_0,
             DDRTCM_U.GPSIONBus.alpha_1, DDRTCM_U.GPSIONBus.alpha_2,
             DDRTCM_U.GPSIONBus.alpha_3, DDRTCM_U.GPSIONBus.beta_0,
             DDRTCM_U.GPSIONBus.beta_1, DDRTCM_U.GPSIONBus.beta_2,
             DDRTCM_U.GPSIONBus.beta_3, DDRTCM_U.usePosLLHArray,
             DDRTCM_B.dayOfYear, DDRTCM_B.FixPtRelationalOperator,
             DDRTCM_B.enable_gps_l1_g, DDRTCM_B.enable_gps_l2_j,
             DDRTCM_B.Nr_GPS_L1, DDRTCM_B.enable_differential_corre_n,
             DDRTCM_B.enable_tropospheric_corre_o,
             DDRTCM_B.enable_ionospheric_correc_o,
             DDRTCM_B.enable_SatPosVel_calculat_m,
             DDRTCM_B.enable_WL_correction_k, DDRTCM_B.use_measured_variance_m,
             &DDRTCM_B.sf_MATLABFunction_k.GpsMeasurementB,
             &DDRTCM_DW.sf_MATLABFunction_k.SFunction_DIMS2, &DDRTCM_B.GPS_d,
             &DDRTCM_DW.GPS_d, &DDRTCM_P.GPS_d);

  // End of Outputs for SubSystem: '<S5>/GPS'

  // Outputs for Enabled SubSystem: '<S5>/Galileo'
  // Inport: '<Root>/GALNavBus' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_Galileo(&DDRTCM_B.GalMeasurementBus, DDRTCM_U.GALNavBus.TOW,
                 DDRTCM_U.GALNavBus.WNc, DDRTCM_U.GALNavBus.SVID,
                 DDRTCM_U.GALNavBus.SQRT_A, DDRTCM_U.GALNavBus.M_0,
                 DDRTCM_U.GALNavBus.E, DDRTCM_U.GALNavBus.I_0,
                 DDRTCM_U.GALNavBus.omega, DDRTCM_U.GALNavBus.OMEGA_0,
                 DDRTCM_U.GALNavBus.OMEGADOT, DDRTCM_U.GALNavBus.IDOT,
                 DDRTCM_U.GALNavBus.DELTA_N, DDRTCM_U.GALNavBus.C_uc,
                 DDRTCM_U.GALNavBus.C_us, DDRTCM_U.GALNavBus.C_rc,
                 DDRTCM_U.GALNavBus.C_rs, DDRTCM_U.GALNavBus.C_ic,
                 DDRTCM_U.GALNavBus.C_is, DDRTCM_U.GALNavBus.T_oc,
                 DDRTCM_U.GALNavBus.T_oe, DDRTCM_U.GALNavBus.A_f2,
                 DDRTCM_U.GALNavBus.A_f1, DDRTCM_U.GALNavBus.A_f0,
                 DDRTCM_U.GALNavBus.WNt_oc, DDRTCM_U.GALNavBus.WNt_oe,
                 DDRTCM_U.GALNavBus.IODnav, DDRTCM_U.usePosLLHArray,
                 DDRTCM_B.dayOfYear, DDRTCM_B.enable_galileo_n,
                 DDRTCM_B.enable_galileo_e1_j, DDRTCM_B.enable_galileo_e5a_a,
                 DDRTCM_B.enable_galileo_e5b_d, DDRTCM_B.enable_galileo_e5_f,
                 DDRTCM_B.enable_differential_corre_n,
                 DDRTCM_B.enable_ionospheric_correc_o,
                 DDRTCM_B.enable_tropospheric_corre_o,
                 DDRTCM_B.enable_SatPosVel_calculat_m,
                 DDRTCM_B.use_measured_variance_m, DDRTCM_B.Nr_GPS_L1,
                 &DDRTCM_B.sf_MATLABFunction_k.GalMeasurementB,
                 &DDRTCM_DW.sf_MATLABFunction_k.SFunction_DIMS3,
                 &DDRTCM_B.Galileo_k, &DDRTCM_DW.Galileo_k, &DDRTCM_P.Galileo_k);

  // End of Outputs for SubSystem: '<S5>/Galileo'

  // MATLAB Function: '<S5>/Fuse'
  DDRTCM_Fuse(DDRTCM_B.GPS_d.SvidCarrierInUse,
              &DDRTCM_DW.GPS_d.SFunction_DIMS2_h, DDRTCM_B.Galileo_k.PRN_n,
              &DDRTCM_DW.Galileo_k.BusSelector_DIMS1_i, &DDRTCM_B.sf_Fuse_j,
              &DDRTCM_DW.sf_Fuse_j);

  // MATLAB Function: '<S4>/Fuse'
  DDRTCM_Fuse(DDRTCM_B.GPS.SvidCarrierInUse, &DDRTCM_DW.GPS.SFunction_DIMS2_h,
              DDRTCM_B.Galileo.PRN_n, &DDRTCM_DW.Galileo.BusSelector_DIMS1_i,
              &DDRTCM_B.sf_Fuse, &DDRTCM_DW.sf_Fuse);

  // MATLAB Function: '<S2>/Intersect'
  DDRTCM_B.SFunction_DIMS2 = DDRTCM_DW.sf_Fuse.SFunction_DIMS2;
  DDRTCM_B.SFunction_DIMS2_j = DDRTCM_DW.sf_Fuse_j.SFunction_DIMS2;
  DDRTCM_do_vectors_e3(DDRTCM_B.sf_Fuse.y, &DDRTCM_B.SFunction_DIMS2,
                       DDRTCM_B.sf_Fuse_j.y, &DDRTCM_B.SFunction_DIMS2_j,
                       DDRTCM_B.tmp_data_b, &DDRTCM_B.tmp_size_a,
                       DDRTCM_B.ia_data, &DDRTCM_B.ia_size, DDRTCM_B.ib_data,
                       &DDRTCM_B.ib_size);
  DDRTCM_DW.SFunction_DIMS2_i = DDRTCM_B.tmp_size_a;

  // Outport: '<Root>/SVIDUsedRCM' incorporates:
  //   MATLAB Function: '<S2>/Intersect'

  DDRTCM_B.c_i = DDRTCM_B.tmp_size_a;
  if (DDRTCM_B.c_i - 1 >= 0) {
    std::memcpy(&DDRTCM_Y.SVIDUsedRCM[0], &DDRTCM_B.tmp_data_b[0], static_cast<
                uint32_T>(DDRTCM_B.c_i) * sizeof(uint16_T));
  }

  // End of Outport: '<Root>/SVIDUsedRCM'

  // MATLAB Function: '<S5>/mergeDiffCorrections'
  DDRTCM_mergeDiffCorrections
    (DDRTCM_B.GPS_d.sf_CalculateDifferentialCorrect.diffPseudorangeCorrection,
     DDRTCM_B.GPS_d.sf_CalculateDifferentialCorrect.maskDiffCorr,
     &DDRTCM_DW.GPS_d.sf_CalculateDifferentialCorrect.SFunction_DIMS3,
     DDRTCM_B.Galileo_k.sf_CalculateDifferentialCorrect.diffPseudorangeCorrection,
     DDRTCM_B.Galileo_k.sf_CalculateDifferentialCorrect.maskDiffCorr,
     &DDRTCM_DW.Galileo_k.sf_CalculateDifferentialCorrect.SFunction_DIMS3,
     DDRTCM_B.pseudorangeCorrections, DDRTCM_B.SVIDCorrections);

  // MATLAB Function: '<S4>/mergeDiffCorrections'
  DDRTCM_mergeDiffCorrections
    (DDRTCM_B.GPS.sf_CalculateDifferentialCorrect.diffPseudorangeCorrection,
     DDRTCM_B.GPS.sf_CalculateDifferentialCorrect.maskDiffCorr,
     &DDRTCM_DW.GPS.sf_CalculateDifferentialCorrect.SFunction_DIMS3,
     DDRTCM_B.Galileo.sf_CalculateDifferentialCorrect.diffPseudorangeCorrection,
     DDRTCM_B.Galileo.sf_CalculateDifferentialCorrect.maskDiffCorr,
     &DDRTCM_DW.Galileo.sf_CalculateDifferentialCorrect.SFunction_DIMS3,
     DDRTCM_B.pseudorangeCorrections, DDRTCM_B.SVIDCorrections);

  // BusCreator generated from: '<S4>/Merge GNSS Measurement' incorporates:
  //   BusSelector: '<S16>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Merge.satellite_position[0] =
    DDRTCM_DW.GPS.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Merge.satellite_position[1] =
    DDRTCM_DW.GPS.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Merge.satellite_velocity[0] =
    DDRTCM_DW.GPS.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Merge.satellite_velocity[1] =
    DDRTCM_DW.GPS.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Merge.PRN =
    DDRTCM_DW.GPS.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.pseudorange =
    DDRTCM_DW.GPS.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.pseudorange_raw =
    DDRTCM_DW.GPS.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.pseudorange_satclk_corrected =
    DDRTCM_DW.GPS.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.deltarange =
    DDRTCM_DW.GPS.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.deltarange_raw =
    DDRTCM_DW.GPS.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.deltarange_satclk_corrected =
    DDRTCM_DW.GPS.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.variance_pseudorange =
    DDRTCM_DW.GPS.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.variance_pseudorange_measured =
    DDRTCM_DW.GPS.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.variance_deltarange =
    DDRTCM_DW.GPS.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.carrierphase =
    DDRTCM_DW.GPS.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.carrierphase_raw =
    DDRTCM_DW.GPS.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.carrierphase_satclk_corrected =
    DDRTCM_DW.GPS.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.variance_carrierphase_measured =
    DDRTCM_DW.GPS.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.locktime =
    DDRTCM_DW.GPS.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Merge.CN0 =
    DDRTCM_DW.GPS.BusSelector_DIMS19;
  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_B.GPS.time_receive;
  DDRTCM_B.nz = DDRTCM_DW.GPS.BusSelector_DIMS2[0] *
    DDRTCM_DW.GPS.BusSelector_DIMS2[1];
  if (DDRTCM_B.nz - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_position[0],
                &DDRTCM_B.GPS.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.nz) * sizeof(real_T));
  }

  DDRTCM_B.loop_ub_tmp_f = DDRTCM_DW.GPS.BusSelector_DIMS3[0] *
    DDRTCM_DW.GPS.BusSelector_DIMS3[1];
  if (DDRTCM_B.loop_ub_tmp_f - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0],
                &DDRTCM_B.GPS.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp_f) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.GnssMeasurementBase.base_position[0] = DDRTCM_B.GPS.base_position[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] = DDRTCM_B.GPS.base_position[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] = DDRTCM_B.GPS.base_position[2];

  // BusCreator generated from: '<S4>/Merge GNSS Measurement' incorporates:
  //   BusSelector: '<S17>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.satellite_position[0] =
    DDRTCM_DW.Galileo.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.satellite_position[1] =
    DDRTCM_DW.Galileo.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.satellite_velocity[0] =
    DDRTCM_DW.Galileo.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.satellite_velocity[1] =
    DDRTCM_DW.Galileo.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.PRN =
    DDRTCM_DW.Galileo.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.pseudorange =
    DDRTCM_DW.Galileo.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.pseudorange_raw =
    DDRTCM_DW.Galileo.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.pseudorange_satclk_corrected =
    DDRTCM_DW.Galileo.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.deltarange =
    DDRTCM_DW.Galileo.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.deltarange_raw =
    DDRTCM_DW.Galileo.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.deltarange_satclk_corrected =
    DDRTCM_DW.Galileo.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.variance_pseudorange =
    DDRTCM_DW.Galileo.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.variance_pseudorange_measured =
    DDRTCM_DW.Galileo.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.variance_deltarange =
    DDRTCM_DW.Galileo.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.carrierphase =
    DDRTCM_DW.Galileo.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.carrierphase_raw =
    DDRTCM_DW.Galileo.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.carrierphase_satclk_corrected =
    DDRTCM_DW.Galileo.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.variance_carrierphase_measured =
    DDRTCM_DW.Galileo.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.locktime =
    DDRTCM_DW.Galileo.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_p.CN0 =
    DDRTCM_DW.Galileo.BusSelector_DIMS19;
  DDRTCM_B.BusConversion_InsertedFor_Mer_m.time_receive =
    DDRTCM_B.Galileo.time_receive;
  DDRTCM_B.loop_ub_tmp_b = DDRTCM_DW.Galileo.BusSelector_DIMS2[0] *
    DDRTCM_DW.Galileo.BusSelector_DIMS2[1];
  if (DDRTCM_B.loop_ub_tmp_b - 1 >= 0) {
    std::memcpy(&DDRTCM_B.BusConversion_InsertedFor_Mer_m.satellite_position[0],
                &DDRTCM_B.Galileo.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp_b) * sizeof(real_T));
  }

  DDRTCM_B.loop_ub_tmp_j = DDRTCM_DW.Galileo.BusSelector_DIMS3[0] *
    DDRTCM_DW.Galileo.BusSelector_DIMS3[1];
  if (DDRTCM_B.loop_ub_tmp_j - 1 >= 0) {
    std::memcpy(&DDRTCM_B.BusConversion_InsertedFor_Mer_m.satellite_velocity[0],
                &DDRTCM_B.Galileo.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp_j) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.pseudorange_satclk_corrected[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.deltarange_satclk_corrected[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_pseudorange_measured[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.carrierphase_satclk_corrected[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_carrierphase_measured[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.BusConversion_InsertedFor_Mer_m.base_position[0] =
    DDRTCM_B.Galileo.base_position[0];
  DDRTCM_B.BusConversion_InsertedFor_Mer_m.base_position[1] =
    DDRTCM_B.Galileo.base_position[1];
  DDRTCM_B.BusConversion_InsertedFor_Mer_m.base_position[2] =
    DDRTCM_B.Galileo.base_position[2];

  // MATLAB Function: '<S4>/Dummy GNSS Measurement'
  DDRTCM_DummyGNSSMeasurement(&DDRTCM_B.sf_DummyGNSSMeasurement,
    &DDRTCM_DW.sf_DummyGNSSMeasurement);

  // BusCreator generated from: '<S4>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gps.enable_gps =
    DDRTCM_B.FixPtRelationalOperator_p;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gps.enable_gps_l1 =
    DDRTCM_B.enable_gps_l1;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gps.enable_gps_l2 =
    DDRTCM_B.enable_gps_l2;

  // BusCreator generated from: '<S4>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.galileo.enable_galileo =
    DDRTCM_B.enable_galileo;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.galileo.enable_galileo_e1 =
    DDRTCM_B.enable_galileo_e1;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.galileo.enable_galileo_e5a =
    DDRTCM_B.enable_galileo_e5a;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.galileo.enable_galileo_e5b =
    DDRTCM_B.enable_galileo_e5b;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.galileo.enable_galileo_e5 =
    DDRTCM_B.enable_galileo_e5;

  // BusCreator generated from: '<S4>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.enable_gate =
    DDRTCM_B.enable_gate;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl1 = DDRTCM_B.prn_psl1;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl2 = DDRTCM_B.prn_psl2;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl3 = DDRTCM_B.prn_psl3;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl4 = DDRTCM_B.prn_psl4;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl5 = DDRTCM_B.prn_psl5;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl6 = DDRTCM_B.prn_psl6;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl7 = DDRTCM_B.prn_psl7;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl8 = DDRTCM_B.prn_psl8;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.gate.prn_psl9 = DDRTCM_B.prn_psl9;

  // BusCreator generated from: '<S4>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.elevation_mask =
    DDRTCM_B.elevation_mask;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.enable_galileo_timebase =
    DDRTCM_B.enable_galileo_timebase;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.enable_differential_correction =
    DDRTCM_B.enable_differential_correct;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.enable_tropospheric_correction =
    DDRTCM_B.enable_tropospheric_correct;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.enable_ionospheric_correction =
    DDRTCM_B.enable_ionospheric_correcti;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.enable_SatPosVel_calculation =
    DDRTCM_B.enable_SatPosVel_calculatio;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.enable_WL_correction =
    DDRTCM_B.enable_WL_correction;
  DDRTCM_B.BusConversion_InsertedFor_Mer_d.use_measured_variance =
    DDRTCM_B.use_measured_variance;

  // MATLAB Function: '<S4>/Merge GNSS Measurement' incorporates:
  //   Constant: '<S2>/Constant'
  //   Inport: '<Root>/GALGSTGPSBus'
  //   Inport: '<Root>/enableGGTO'

  DDRTCM_MergeGNSSMeasurement(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.BusConversion_InsertedFor_Merge,
    &DDRTCM_B.BusConversion_InsertedFor_Mer_m,
    &DDRTCM_DW.BusConversion_InsertedFor_Mer_p,
    &DDRTCM_B.sf_DummyGNSSMeasurement.dummy_GNSS_Measurement_Bus,
    &DDRTCM_DW.sf_DummyGNSSMeasurement.SFunction_DIMS2, &DDRTCM_U.GALGSTGPSBus,
    DDRTCM_B.TOW_h, DDRTCM_B.WNc_h, &DDRTCM_B.BusConversion_InsertedFor_Mer_d,
    DDRTCM_U.enableGGTO, DDRTCM_P.Constant_Value_d, &DDRTCM_B.dayOfYear,
    &DDRTCM_B.FixPtRelationalOperator_p, &DDRTCM_B.sf_MergeGNSSMeasurement,
    &DDRTCM_DW.sf_MergeGNSSMeasurement);

  // MATLAB Function: '<S122>/MATLAB Function' incorporates:
  //   Inport: '<Root>/ClockErrorArray'
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/IntegrityParametersBus'
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_MATLABFunction(&DDRTCM_U.IntegrityParametersBus,
                        &DDRTCM_B.sf_MergeGNSSMeasurement.GnssMeasurementBus,
                        &DDRTCM_DW.sf_MergeGNSSMeasurement.SFunction_DIMS2,
                        DDRTCM_U.GNSSParametersBus.gps.enable_gps_l1,
                        DDRTCM_U.GNSSParametersBus.gps.enable_gps_l2,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e1,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5a,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5b,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.HAL,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.P_BayesThreshold,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.TTE,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.numVar,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.maxNumToIdentifyOnce,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.VarianceMode,
                        DDRTCM_U.IntegrityParametersBus.enable_GNSS_exclusion,
                        DDRTCM_U.usePosLLHArray, DDRTCM_U.ClockErrorArray,
                        &DDRTCM_B.useOriginalGNSSmeasurement, &DDRTCM_B.WNc_h,
                        &DDRTCM_B.TOW_h, &DDRTCM_B.dayOfYear,
                        DDRTCM_B.faulty_PRNs_g, DDRTCM_B.PRNs_to_exclude_j,
                        DDRTCM_B.PRNs_excluded_f, &DDRTCM_B.sf_MATLABFunction,
                        &DDRTCM_DW.sf_MATLABFunction, &DDRTCM_P);

  // MATLAB Function: '<S122>/switch GNSS Measurements'
  DDRTCM_switchGNSSMeasurements(DDRTCM_B.useOriginalGNSSmeasurement,
    &DDRTCM_B.sf_MergeGNSSMeasurement.GnssMeasurementBus,
    &DDRTCM_DW.sf_MergeGNSSMeasurement.SFunction_DIMS2,
    &DDRTCM_B.sf_MATLABFunction.GNSS_measurement_out,
    &DDRTCM_DW.sf_MATLABFunction.SFunction_DIMS2,
    &DDRTCM_B.sf_switchGNSSMeasurements, &DDRTCM_DW.sf_switchGNSSMeasurements);

  // MATLAB Function: '<S2>/Multipath-Detector' incorporates:
  //   Inport: '<Root>/GNSSParametersBus'

  if (DDRTCM_U.GNSSParametersBus.enable_WL_correction) {
    DDRTCM_B.WNc_h = 0.86191840032200562;
  } else {
    DDRTCM_B.WNc_h = 0.19029367279836487;
  }

  DDRTCM_DW.SFunction_DIMS3 = 10;
  DDRTCM_DW.SFunction_DIMS2_a =
    DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2;
  std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_satell[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.satellite_position
              [0], 120U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_sate_c[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.satellite_velocity
              [0], 120U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_PRN[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN[0], 40U
              * sizeof(uint16_T));
  std::memcpy(&DDRTCM_B.pseudorangeCorrections[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.pseudorange[
              0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.dr_kl_ur_GPS_data[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.deltarange
              [0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.carrierphase_kl_ur_GPS_data[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_pseudorange
              [0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_varian[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_pseudorange_measured
              [0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.elevation_Angle_data[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_deltarange
              [0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.pr_kl_ur_GAL_data[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.carrierphase
              [0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.dr_kl_ur_GAL_data[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_carrierphase_measured
              [0], 40U * sizeof(real_T));
  std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_lockti[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.locktime[0],
              40U * sizeof(real32_T));
  std::memcpy(&DDRTCM_B.carrierphase_kl_ur_GAL_data[0],
              &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.CN0[0], 40U
              * sizeof(real_T));
  if (DDRTCM_DW.SFunction_DIMS2_a.PRN != 0) {
    DDRTCM_B.Lia_size = DDRTCM_DW.SFunction_DIMS2_a.PRN;
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2_a.PRN;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
      DDRTCM_B.useableIdx[DDRTCM_B.b_k] =
        (DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN[DDRTCM_B.b_k]
         == 0);
    }

    if (!DDRTCM_any_jj(DDRTCM_B.useableIdx, &DDRTCM_B.Lia_size)) {
      DDRTCM_B.k = DDRTCM_DW.SFunction_DIMS2_a.PRN;
      for (DDRTCM_B.i = 0; DDRTCM_B.i < DDRTCM_B.k; DDRTCM_B.i++) {
        DDRTCM_B.b_k =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN[DDRTCM_B.i];
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < 40; DDRTCM_B.trueCount
             ++) {
          DDRTCM_B.useableIdx[DDRTCM_B.trueCount] = !std::isnan
            (DDRTCM_DW.testmeasure_Buffer[(110 * DDRTCM_B.trueCount +
              DDRTCM_B.b_k) - 1]);
        }

        if (DDRTCM_combineVectorElements_n(DDRTCM_B.useableIdx) > 39) {
          DDRTCM_B.trueCount = 0;
          for (DDRTCM_B.c_i = 0; DDRTCM_B.c_i < 40; DDRTCM_B.c_i++) {
            if (DDRTCM_B.useableIdx[DDRTCM_B.c_i]) {
              DDRTCM_B.trueCount++;
            }
          }

          DDRTCM_B.f_size_idx_0 = DDRTCM_B.trueCount;
          DDRTCM_B.trueCount = 0;
          DDRTCM_B.c_i = 0;
          for (DDRTCM_B.d_i = 0; DDRTCM_B.d_i < 40; DDRTCM_B.d_i++) {
            if (DDRTCM_B.useableIdx[DDRTCM_B.d_i]) {
              DDRTCM_B.c_data[DDRTCM_B.trueCount] = static_cast<int8_T>
                (DDRTCM_B.d_i + 1);
              DDRTCM_B.trueCount++;
              DDRTCM_B.c_i++;
            }
          }

          DDRTCM_B.TOW_h = static_cast<real_T>(DDRTCM_B.c_i) * 0.1;
          if (DDRTCM_B.TOW_h < 0.1) {
            DDRTCM_B.timeVec_size[0] = 1;
            DDRTCM_B.timeVec_size[1] = 0;
          } else {
            DDRTCM_eml_float_colon(DDRTCM_B.TOW_h, DDRTCM_B.timeVec_data,
              DDRTCM_B.timeVec_size);
          }

          DDRTCM_B.tmp_size[0] = 1;
          DDRTCM_B.tmp_size[1] = DDRTCM_B.f_size_idx_0;
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <
               DDRTCM_B.f_size_idx_0; DDRTCM_B.trueCount++) {
            DDRTCM_B.tmp_data_d[DDRTCM_B.trueCount] =
              DDRTCM_DW.testmeasure_Buffer[((DDRTCM_B.c_data[DDRTCM_B.trueCount]
              - 1) * 110 + DDRTCM_B.b_k) - 1];
          }

          DDRTCM_polyfit(DDRTCM_B.timeVec_data, DDRTCM_B.timeVec_size,
                         DDRTCM_B.tmp_data_d, DDRTCM_B.tmp_size, DDRTCM_B.p);
          DDRTCM_B.testGradient_tmp =
            DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN[DDRTCM_B.i]
            - 1;
          DDRTCM_DW.testGradient[DDRTCM_B.testGradient_tmp] = DDRTCM_B.p[0];
          if (std::abs(DDRTCM_B.p[0]) > 5.0) {
            for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < 40;
                 DDRTCM_B.trueCount++) {
              DDRTCM_DW.testmeasure_Buffer[(DDRTCM_B.b_k + 110 *
                DDRTCM_B.trueCount) - 1] = (rtNaN);
            }

            DDRTCM_DW.CS_PRN[DDRTCM_B.testGradient_tmp] = 0.0;
          } else {
            DDRTCM_DW.CS_PRN[DDRTCM_B.testGradient_tmp]++;
          }
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 110; DDRTCM_B.b_k++) {
        DDRTCM_B.bv[DDRTCM_B.b_k] = (DDRTCM_DW.CS_PRN[DDRTCM_B.b_k] < 100.0);
      }

      DDRTCM_eml_find_p(DDRTCM_B.bv, DDRTCM_B.tmp_data_m, &DDRTCM_B.ia_size);
      DDRTCM_B.tmp_size_j = DDRTCM_B.ia_size;
      DDRTCM_B.c_i = DDRTCM_B.ia_size;
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        DDRTCM_B.tmp_data[DDRTCM_B.b_k] = DDRTCM_B.tmp_data_m[DDRTCM_B.b_k];
      }

      DDRTCM_B.SFunction_DIMS2_a = DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_isMember_i
        (DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN,
         &DDRTCM_B.SFunction_DIMS2_a, DDRTCM_B.tmp_data, &DDRTCM_B.tmp_size_j,
         DDRTCM_B.useableIdx, &DDRTCM_B.Lia_size);
      DDRTCM_B.d_i = DDRTCM_B.Lia_size - 1;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.f_size_idx_0 = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.e_data[DDRTCM_B.c_i] = static_cast<int8_T>(DDRTCM_B.trueCount
            + 1);
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.i = DDRTCM_DW.SFunction_DIMS2_a.satellite_position[0];
      DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2_a.satellite_position[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.f_size_idx_0;
             DDRTCM_B.trueCount++) {
          DDRTCM_B.b_addRow_b[DDRTCM_B.trueCount + DDRTCM_B.f_size_idx_0 *
            DDRTCM_B.b_k] =
            DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.satellite_position
            [(DDRTCM_B.i * DDRTCM_B.b_k + DDRTCM_B.e_data[DDRTCM_B.trueCount]) -
            1];
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.satellite_position[0] = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.c_i = DDRTCM_B.f_size_idx_0 *
        DDRTCM_DW.SFunction_DIMS2_a.satellite_position[1];
      if (DDRTCM_B.c_i - 1 >= 0) {
        std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_satell[0],
                    &DDRTCM_B.b_addRow_b[0], static_cast<uint32_T>(DDRTCM_B.c_i)
                    * sizeof(real_T));
      }

      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.f_size_idx_0 = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.f_data_b[DDRTCM_B.c_i] = static_cast<int8_T>
            (DDRTCM_B.trueCount + 1);
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.i = DDRTCM_DW.SFunction_DIMS2_a.satellite_velocity[0];
      DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2_a.satellite_velocity[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.f_size_idx_0;
             DDRTCM_B.trueCount++) {
          DDRTCM_B.b_addRow_b[DDRTCM_B.trueCount + DDRTCM_B.f_size_idx_0 *
            DDRTCM_B.b_k] =
            DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.satellite_velocity
            [(DDRTCM_B.i * DDRTCM_B.b_k + DDRTCM_B.f_data_b[DDRTCM_B.trueCount])
            - 1];
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.satellite_velocity[0] = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.c_i = DDRTCM_B.f_size_idx_0 *
        DDRTCM_DW.SFunction_DIMS2_a.satellite_velocity[1];
      if (DDRTCM_B.c_i - 1 >= 0) {
        std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_sate_c[0],
                    &DDRTCM_B.b_addRow_b[0], static_cast<uint32_T>(DDRTCM_B.c_i)
                    * sizeof(real_T));
      }

      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.f_size_idx_0 = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.g_data[DDRTCM_B.c_i] = static_cast<int8_T>(DDRTCM_B.trueCount
            + 1);
          DDRTCM_B.c_i++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.f_size_idx_0; DDRTCM_B.b_k
           ++) {
        DDRTCM_B.a__2_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN[DDRTCM_B.g_data
          [DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.PRN = DDRTCM_B.f_size_idx_0;
      if (DDRTCM_B.f_size_idx_0 - 1 >= 0) {
        std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_PRN[0],
                    &DDRTCM_B.a__2_data[0], static_cast<uint32_T>
                    (DDRTCM_B.f_size_idx_0) * sizeof(uint16_T));
      }

      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.f_size_idx_0 = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.h_data[DDRTCM_B.c_i] = static_cast<int8_T>(DDRTCM_B.trueCount
            + 1);
          DDRTCM_B.c_i++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.f_size_idx_0; DDRTCM_B.b_k
           ++) {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.pseudorange[DDRTCM_B.h_data
          [DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.pseudorange = DDRTCM_B.f_size_idx_0;
      if (DDRTCM_B.f_size_idx_0 - 1 >= 0) {
        std::memcpy(&DDRTCM_B.pseudorangeCorrections[0], &DDRTCM_B.timeVec_data
                    [0], static_cast<uint32_T>(DDRTCM_B.f_size_idx_0) * sizeof
                    (real_T));
      }

      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.pseudorange_raw = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.pseudorange_satclk_corrected = DDRTCM_B.c_i;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.l_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.deltarange[DDRTCM_B.l_data
          [DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.deltarange = DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.dr_kl_ur_GPS_data[0], &DDRTCM_B.timeVec_data[0],
                    static_cast<uint32_T>(DDRTCM_B.trueCount) * sizeof(real_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.deltarange_raw = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.deltarange_satclk_corrected =
        DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.o_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_pseudorange
          [DDRTCM_B.o_data[DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.variance_pseudorange = DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.carrierphase_kl_ur_GPS_data[0],
                    &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                    (DDRTCM_B.trueCount) * sizeof(real_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.q_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_pseudorange_measured
          [DDRTCM_B.q_data[DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.variance_pseudorange_measured =
        DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_varian[0],
                    &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                    (DDRTCM_B.trueCount) * sizeof(real_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.r_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_deltarange
          [DDRTCM_B.r_data[DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.variance_deltarange = DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.elevation_Angle_data[0], &DDRTCM_B.timeVec_data[0],
                    static_cast<uint32_T>(DDRTCM_B.trueCount) * sizeof(real_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.s_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.carrierphase[DDRTCM_B.s_data
          [DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.carrierphase = DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.pr_kl_ur_GAL_data[0], &DDRTCM_B.timeVec_data[0],
                    static_cast<uint32_T>(DDRTCM_B.trueCount) * sizeof(real_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.carrierphase_raw = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_DW.SFunction_DIMS2_a.carrierphase_satclk_corrected =
        DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.v_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.variance_carrierphase_measured
          [DDRTCM_B.v_data[DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.variance_carrierphase_measured =
        DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.dr_kl_ur_GAL_data[0], &DDRTCM_B.timeVec_data[0],
                    static_cast<uint32_T>(DDRTCM_B.trueCount) * sizeof(real_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.w_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.tmp_data_l[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.locktime[DDRTCM_B.w_data
          [DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.locktime = DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.rtb_GNSS_measurement_out_lockti[0],
                    &DDRTCM_B.tmp_data_l[0], static_cast<uint32_T>
                    (DDRTCM_B.trueCount) * sizeof(real32_T));
      }

      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.f_size_idx_0++;
        }
      }

      DDRTCM_B.trueCount = DDRTCM_B.f_size_idx_0;
      DDRTCM_B.f_size_idx_0 = 0;
      for (DDRTCM_B.s_i = 0; DDRTCM_B.s_i <= DDRTCM_B.d_i; DDRTCM_B.s_i++) {
        if (!DDRTCM_B.useableIdx[DDRTCM_B.s_i]) {
          DDRTCM_B.x_data[DDRTCM_B.f_size_idx_0] = static_cast<int8_T>
            (DDRTCM_B.s_i + 1);
          DDRTCM_B.f_size_idx_0++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.CN0[DDRTCM_B.x_data
          [DDRTCM_B.b_k] - 1];
      }

      DDRTCM_DW.SFunction_DIMS2_a.CN0 = DDRTCM_B.trueCount;
      if (DDRTCM_B.trueCount - 1 >= 0) {
        std::memcpy(&DDRTCM_B.carrierphase_kl_ur_GAL_data[0],
                    &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                    (DDRTCM_B.trueCount) * sizeof(real_T));
      }

      std::memcpy(&DDRTCM_B.dv[0], &DDRTCM_DW.testmeasure_Buffer[0], 4290U *
                  sizeof(real_T));
      std::memcpy(&DDRTCM_DW.testmeasure_Buffer[110], &DDRTCM_B.dv[0], 4290U *
                  sizeof(real_T));
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 110; DDRTCM_B.b_k++) {
        DDRTCM_DW.testmeasure_Buffer[DDRTCM_B.b_k] = (rtNaN);
      }

      if (DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2.carrierphase ==
          DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2.pseudorange) {
        DDRTCM_B.c_i =
          DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2.carrierphase;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_DW.testmeasure_Buffer[DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.PRN
            [DDRTCM_B.b_k] - 1] =
            DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.carrierphase[DDRTCM_B.b_k]
            - DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.pseudorange[DDRTCM_B.b_k]
            / DDRTCM_B.WNc_h;
        }
      } else {
        DDRTC_binary_expand_op_bfmqb0c5(DDRTCM_DW.testmeasure_Buffer,
          &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a,
          &DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2, DDRTCM_B.WNc_h);
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 110; DDRTCM_B.b_k++) {
        DDRTCM_B.bv[DDRTCM_B.b_k] = (DDRTCM_DW.testGradient[DDRTCM_B.b_k] != 0.0);
      }

      if (DDRTCM_any_jj3(DDRTCM_B.bv)) {
        DDRTCM_DW.SFunction_DIMS3 =
          DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2.PRN;
      }
    }
  }

  // BusCreator generated from: '<S5>/Merge GNSS Measurement' incorporates:
  //   BusSelector: '<S143>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.satellite_position[0] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.satellite_position[1] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.satellite_velocity[0] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.satellite_velocity[1] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.PRN =
    DDRTCM_DW.GPS_d.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.pseudorange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.pseudorange_raw =
    DDRTCM_DW.GPS_d.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.pseudorange_satclk_corrected =
    DDRTCM_DW.GPS_d.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.deltarange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.deltarange_raw =
    DDRTCM_DW.GPS_d.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.deltarange_satclk_corrected =
    DDRTCM_DW.GPS_d.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.variance_pseudorange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.variance_pseudorange_measured =
    DDRTCM_DW.GPS_d.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.variance_deltarange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.carrierphase =
    DDRTCM_DW.GPS_d.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.carrierphase_raw =
    DDRTCM_DW.GPS_d.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.carrierphase_satclk_corrected =
    DDRTCM_DW.GPS_d.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.variance_carrierphase_measured =
    DDRTCM_DW.GPS_d.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.locktime =
    DDRTCM_DW.GPS_d.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_i.CN0 =
    DDRTCM_DW.GPS_d.BusSelector_DIMS19;
  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_B.GPS_d.time_receive;
  DDRTCM_B.testGradient_tmp = DDRTCM_DW.GPS_d.BusSelector_DIMS2[0] *
    DDRTCM_DW.GPS_d.BusSelector_DIMS2[1];
  if (DDRTCM_B.testGradient_tmp - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_position[0],
                &DDRTCM_B.GPS_d.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.testGradient_tmp) * sizeof(real_T));
  }

  DDRTCM_B.f_size_idx_0 = DDRTCM_DW.GPS_d.BusSelector_DIMS3[0] *
    DDRTCM_DW.GPS_d.BusSelector_DIMS3[1];
  if (DDRTCM_B.f_size_idx_0 - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0],
                &DDRTCM_B.GPS_d.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.f_size_idx_0) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.GnssMeasurementBase.base_position[0] = DDRTCM_B.GPS_d.base_position[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] = DDRTCM_B.GPS_d.base_position[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] = DDRTCM_B.GPS_d.base_position[2];

  // BusCreator generated from: '<S5>/Merge GNSS Measurement' incorporates:
  //   BusSelector: '<S144>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.satellite_position[0] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.satellite_position[1] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.satellite_velocity[0] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.satellite_velocity[1] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.PRN =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.pseudorange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.pseudorange_raw =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.pseudorange_satclk_corrected =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.deltarange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.deltarange_raw =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.deltarange_satclk_corrected =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.variance_pseudorange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.variance_pseudorange_measured =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.variance_deltarange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.carrierphase =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.carrierphase_raw =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.carrierphase_satclk_corrected =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.variance_carrierphase_measured =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.locktime =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Mer_b.CN0 =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS19;
  DDRTCM_B.BusConversion_InsertedFor_Mer_m.time_receive =
    DDRTCM_B.Galileo_k.time_receive;
  DDRTCM_B.s_i = DDRTCM_DW.Galileo_k.BusSelector_DIMS2[0] *
    DDRTCM_DW.Galileo_k.BusSelector_DIMS2[1];
  if (DDRTCM_B.s_i - 1 >= 0) {
    std::memcpy(&DDRTCM_B.BusConversion_InsertedFor_Mer_m.satellite_position[0],
                &DDRTCM_B.Galileo_k.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.s_i) * sizeof(real_T));
  }

  DDRTCM_B.loop_ub_tmp = DDRTCM_DW.Galileo_k.BusSelector_DIMS3[0] *
    DDRTCM_DW.Galileo_k.BusSelector_DIMS3[1];
  if (DDRTCM_B.loop_ub_tmp - 1 >= 0) {
    std::memcpy(&DDRTCM_B.BusConversion_InsertedFor_Mer_m.satellite_velocity[0],
                &DDRTCM_B.Galileo_k.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.pseudorange_satclk_corrected[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo_k.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.deltarange_satclk_corrected[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo_k.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_pseudorange_measured[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo_k.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.carrierphase_satclk_corrected[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo_k.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.variance_carrierphase_measured[DDRTCM_B.b_k]
      = DDRTCM_B.Galileo_k.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.BusConversion_InsertedFor_Mer_m.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.BusConversion_InsertedFor_Mer_m.base_position[0] =
    DDRTCM_B.Galileo_k.base_position[0];
  DDRTCM_B.BusConversion_InsertedFor_Mer_m.base_position[1] =
    DDRTCM_B.Galileo_k.base_position[1];
  DDRTCM_B.BusConversion_InsertedFor_Mer_m.base_position[2] =
    DDRTCM_B.Galileo_k.base_position[2];

  // MATLAB Function: '<S5>/Dummy GNSS Measurement'
  DDRTCM_DummyGNSSMeasurement(&DDRTCM_B.sf_DummyGNSSMeasurement_c,
    &DDRTCM_DW.sf_DummyGNSSMeasurement_c);

  // BusCreator generated from: '<S5>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gps.enable_gps =
    DDRTCM_B.FixPtRelationalOperator;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gps.enable_gps_l1 =
    DDRTCM_B.enable_gps_l1_g;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gps.enable_gps_l2 =
    DDRTCM_B.enable_gps_l2_j;

  // BusCreator generated from: '<S5>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.galileo.enable_galileo =
    DDRTCM_B.enable_galileo_n;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.galileo.enable_galileo_e1 =
    DDRTCM_B.enable_galileo_e1_j;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.galileo.enable_galileo_e5a =
    DDRTCM_B.enable_galileo_e5a_a;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.galileo.enable_galileo_e5b =
    DDRTCM_B.enable_galileo_e5b_d;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.galileo.enable_galileo_e5 =
    DDRTCM_B.enable_galileo_e5_f;

  // BusCreator generated from: '<S5>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.enable_gate =
    DDRTCM_B.enable_gate_f;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl1 = DDRTCM_B.prn_psl1_b;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl2 = DDRTCM_B.prn_psl2_o;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl3 = DDRTCM_B.prn_psl3_o;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl4 = DDRTCM_B.prn_psl4_a;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl5 = DDRTCM_B.prn_psl5_i;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl6 = DDRTCM_B.prn_psl6_f;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl7 = DDRTCM_B.prn_psl7_m;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl8 = DDRTCM_B.prn_psl8_f;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.gate.prn_psl9 = DDRTCM_B.prn_psl9_j;

  // BusCreator generated from: '<S5>/Merge GNSS Measurement'
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.elevation_mask = DDRTCM_B.Nr_GPS_L1;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.enable_galileo_timebase =
    DDRTCM_B.enable_galileo_timebase_c;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.enable_differential_correction =
    DDRTCM_B.enable_differential_corre_n;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.enable_tropospheric_correction =
    DDRTCM_B.enable_tropospheric_corre_o;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.enable_ionospheric_correction =
    DDRTCM_B.enable_ionospheric_correc_o;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.enable_SatPosVel_calculation =
    DDRTCM_B.enable_SatPosVel_calculat_m;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.enable_WL_correction =
    DDRTCM_B.enable_WL_correction_k;
  DDRTCM_B.BusConversion_InsertedFor_Me_jc.use_measured_variance =
    DDRTCM_B.use_measured_variance_m;

  // MATLAB Function: '<S5>/Merge GNSS Measurement' incorporates:
  //   Constant: '<S2>/Constant'
  //   Inport: '<Root>/GALGSTGPSBus'
  //   Inport: '<Root>/enableGGTO'

  DDRTCM_MergeGNSSMeasurement(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.BusConversion_InsertedFor_Mer_i,
    &DDRTCM_B.BusConversion_InsertedFor_Mer_m,
    &DDRTCM_DW.BusConversion_InsertedFor_Mer_b,
    &DDRTCM_B.sf_DummyGNSSMeasurement_c.dummy_GNSS_Measurement_Bus,
    &DDRTCM_DW.sf_DummyGNSSMeasurement_c.SFunction_DIMS2, &DDRTCM_U.GALGSTGPSBus,
    DDRTCM_B.TOW, DDRTCM_B.state_o, &DDRTCM_B.BusConversion_InsertedFor_Me_jc,
    DDRTCM_U.enableGGTO, DDRTCM_P.Constant_Value_d, &DDRTCM_B.WNc_h,
    &DDRTCM_B.FixPtRelationalOperator_p, &DDRTCM_B.sf_MergeGNSSMeasurement_l,
    &DDRTCM_DW.sf_MergeGNSSMeasurement_l);

  // MATLAB Function: '<S249>/MATLAB Function' incorporates:
  //   Inport: '<Root>/ClockErrorArray'
  //   Inport: '<Root>/GNSSParametersBus'
  //   Inport: '<Root>/IntegrityParametersBus'
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_MATLABFunction(&DDRTCM_U.IntegrityParametersBus,
                        &DDRTCM_B.sf_MergeGNSSMeasurement_l.GnssMeasurementBus,
                        &DDRTCM_DW.sf_MergeGNSSMeasurement_l.SFunction_DIMS2,
                        DDRTCM_U.GNSSParametersBus.gps.enable_gps_l1,
                        DDRTCM_U.GNSSParametersBus.gps.enable_gps_l2,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e1,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5a,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5b,
                        DDRTCM_U.GNSSParametersBus.galileo.enable_galileo_e5,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.HAL,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.P_BayesThreshold,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.TTE,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.numVar,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.maxNumToIdentifyOnce,
                        DDRTCM_U.IntegrityParametersBus.raim_parameter.VarianceMode,
                        DDRTCM_U.IntegrityParametersBus.enable_GNSS_exclusion,
                        DDRTCM_U.usePosLLHArray, DDRTCM_U.ClockErrorArray,
                        &DDRTCM_B.useOriginalGNSSmeasurement, &DDRTCM_B.state_o,
                        &DDRTCM_B.TOW, &DDRTCM_B.WNc_h, DDRTCM_B.faulty_PRNs,
                        DDRTCM_B.PRNs_to_exclude, DDRTCM_B.PRNs_excluded,
                        &DDRTCM_B.sf_MATLABFunction_p,
                        &DDRTCM_DW.sf_MATLABFunction_p, &DDRTCM_P);

  // MATLAB Function: '<S249>/switch GNSS Measurements'
  DDRTCM_switchGNSSMeasurements(DDRTCM_B.useOriginalGNSSmeasurement,
    &DDRTCM_B.sf_MergeGNSSMeasurement_l.GnssMeasurementBus,
    &DDRTCM_DW.sf_MergeGNSSMeasurement_l.SFunction_DIMS2,
    &DDRTCM_B.sf_MATLABFunction_p.GNSS_measurement_out,
    &DDRTCM_DW.sf_MATLABFunction_p.SFunction_DIMS2,
    &DDRTCM_B.sf_switchGNSSMeasurements_g,
    &DDRTCM_DW.sf_switchGNSSMeasurements_g);

  // BusAssignment: '<S2>/assign Pos B' incorporates:
  //   SignalConversion generated from: '<S2>/assign Pos B'

  DDRTCM_DW.assignPosB_DIMS1 =
    DDRTCM_DW.sf_switchGNSSMeasurements_g.SFunction_DIMS2;

  // MATLAB Function: '<S2>/calculate double diff'
  if (!DDRTCM_DW.Buffer_r_not_empty) {
    DDRTCM_DW.Buffer_r_not_empty = true;
    std::memset(&DDRTCM_DW.Buffer_r.TOW[0], 0, 50U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.PR[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.DR[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.SVID[0], 0, 2000U * sizeof(uint16_T));
    std::memset(&DDRTCM_DW.Buffer_r.satellite_position[0], 0, 6000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_r.satellite_velocity[0], 0, 6000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_r.variance_pseudorange[0], 0, 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_r.variance_pseudorange_measured[0], 0, 2000U *
                sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.variance_deltarange[0], 0, 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_r.carrierphase[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.variance_carrierphase_measured[0], 0, 2000U *
                sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.locktime[0], 0, 2000U * sizeof(real32_T));
    std::memset(&DDRTCM_DW.Buffer_r.CN0[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_r.base_position[0], 0, 150U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.TOW[0], 0, 50U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.PR[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.DR[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.SVID[0], 0, 2000U * sizeof(uint16_T));
    std::memset(&DDRTCM_DW.Buffer_u.satellite_position[0], 0, 6000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_u.satellite_velocity[0], 0, 6000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_u.variance_pseudorange[0], 0, 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_u.variance_pseudorange_measured[0], 0, 2000U *
                sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.variance_deltarange[0], 0, 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_DW.Buffer_u.carrierphase[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.variance_carrierphase_measured[0], 0, 2000U *
                sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.locktime[0], 0, 2000U * sizeof(real32_T));
    std::memset(&DDRTCM_DW.Buffer_u.CN0[0], 0, 2000U * sizeof(real_T));
    std::memset(&DDRTCM_DW.Buffer_u.base_position[0], 0, 150U * sizeof(real_T));
  }

  // Outport: '<Root>/GNSSMeasurementBus' incorporates:
  //   MATLAB Function: '<S2>/calculate double diff'

  DDRTCM_Y.GNSSMeasurementBus.time_receive = 0.0;

  // MATLAB Function: '<S2>/calculate double diff'
  DDRTCM_DW.SFunction_DIMS2.satellite_position[0] = 0;
  DDRTCM_DW.SFunction_DIMS2.satellite_position[1] = 0;
  DDRTCM_DW.SFunction_DIMS2.satellite_velocity[0] = 0;
  DDRTCM_DW.SFunction_DIMS2.satellite_velocity[1] = 0;
  DDRTCM_DW.SFunction_DIMS2.PRN = 0;
  DDRTCM_DW.SFunction_DIMS2.pseudorange = 0;
  DDRTCM_DW.SFunction_DIMS2.pseudorange_raw = 0;
  DDRTCM_DW.SFunction_DIMS2.pseudorange_satclk_corrected = 0;
  DDRTCM_DW.SFunction_DIMS2.deltarange = 0;
  DDRTCM_DW.SFunction_DIMS2.deltarange_raw = 0;
  DDRTCM_DW.SFunction_DIMS2.deltarange_satclk_corrected = 0;
  DDRTCM_DW.SFunction_DIMS2.variance_pseudorange = 0;
  DDRTCM_DW.SFunction_DIMS2.variance_pseudorange_measured = 0;
  DDRTCM_DW.SFunction_DIMS2.variance_deltarange = 0;
  DDRTCM_DW.SFunction_DIMS2.carrierphase = 0;
  DDRTCM_DW.SFunction_DIMS2.carrierphase_raw = 0;
  DDRTCM_DW.SFunction_DIMS2.carrierphase_satclk_corrected = 0;
  DDRTCM_DW.SFunction_DIMS2.variance_carrierphase_measured = 0;
  DDRTCM_DW.SFunction_DIMS2.locktime = 0;
  DDRTCM_DW.SFunction_DIMS2.CN0 = 0;

  // Outport: '<Root>/GNSSMeasurementBus' incorporates:
  //   MATLAB Function: '<S2>/calculate double diff'

  DDRTCM_Y.GNSSMeasurementBus.base_position[0] = 0.0;
  DDRTCM_Y.GNSSMeasurementBus.base_position[1] = 0.0;
  DDRTCM_Y.GNSSMeasurementBus.base_position[2] = 0.0;

  // MATLAB Function: '<S2>/calculate double diff' incorporates:
  //   Inport: '<Root>/RTCM_3_3_L1_E1_Bus'
  //   MATLAB Function: '<Root>/Convert RTCM3 MSM4 for L1 and E1 to GNSS Measurement Bus'
  //   MATLAB Function: '<S2>/Multipath-Detector'
  //   SignalConversion generated from: '<S2>/assign Pos B'

  if (DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.time_receive >
      DDRTCM_DW.Buffer_r.TOW[0]) {
    DDRTCM_B.dv3[0] =
      DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.time_receive;
    std::memcpy(&DDRTCM_B.dv3[1], &DDRTCM_DW.Buffer_r.TOW[0], 49U * sizeof
                (real_T));
    std::memcpy(&DDRTCM_DW.Buffer_r.TOW[0], &DDRTCM_B.dv3[0], 50U * sizeof
                (real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.pseudorange[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.PR[DDRTCM_B.b_k * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.PR[0], &DDRTCM_B.addRow[0], 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.deltarange[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.DR[DDRTCM_B.b_k * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.DR[0], &DDRTCM_B.addRow[0], 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.PRN[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow_c[50 * DDRTCM_B.b_k] = static_cast<uint16_T>
        (DDRTCM_B.timeVec_data[DDRTCM_B.b_k]);
      std::memcpy(&DDRTCM_B.addRow_c[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.SVID[DDRTCM_B.b_k * 50], 49U * sizeof
                  (uint16_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.SVID[0], &DDRTCM_B.addRow_c[0], 2000U *
                sizeof(uint16_T));
    std::memset(&DDRTCM_B.b_addRow_b[0], 0, 120U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.i = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.i = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.c_i = DDRTCM_B.k - DDRTCM_B.i;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.c_i;
           DDRTCM_B.trueCount++) {
        DDRTCM_B.b_addRow_b[(DDRTCM_B.i + DDRTCM_B.trueCount) + 40 *
          DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.satellite_position
          [DDRTCM_B.c_i * DDRTCM_B.b_k + DDRTCM_B.trueCount];
      }
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.b_addRow_b[DDRTCM_B.b_k];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 2000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 40];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 4000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 80];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < 49; DDRTCM_B.trueCount++)
      {
        for (DDRTCM_B.k = 0; DDRTCM_B.k < 3; DDRTCM_B.k++) {
          DDRTCM_B.c = (50 * DDRTCM_B.b_k + DDRTCM_B.trueCount) + 2000 *
            DDRTCM_B.k;
          DDRTCM_B.b_addRow[DDRTCM_B.c + 1] =
            DDRTCM_DW.Buffer_r.satellite_position[DDRTCM_B.c];
        }
      }
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.satellite_position[0], &DDRTCM_B.b_addRow[0],
                6000U * sizeof(real_T));
    std::memset(&DDRTCM_B.b_addRow_b[0], 0, 120U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.k = 0;
      DDRTCM_B.c = 0;
    } else {
      DDRTCM_B.k = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.c = 40;
    }

    DDRTCM_B.c_i = DDRTCM_B.c - DDRTCM_B.k;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.c_i;
           DDRTCM_B.trueCount++) {
        DDRTCM_B.b_addRow_b[(DDRTCM_B.k + DDRTCM_B.trueCount) + 40 *
          DDRTCM_B.b_k] =
          DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.satellite_velocity
          [DDRTCM_B.c_i * DDRTCM_B.b_k + DDRTCM_B.trueCount];
      }
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.b_addRow_b[DDRTCM_B.b_k];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 2000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 40];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 4000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 80];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < 49; DDRTCM_B.trueCount++)
      {
        for (DDRTCM_B.k = 0; DDRTCM_B.k < 3; DDRTCM_B.k++) {
          DDRTCM_B.c = (50 * DDRTCM_B.b_k + DDRTCM_B.trueCount) + 2000 *
            DDRTCM_B.k;
          DDRTCM_B.b_addRow[DDRTCM_B.c + 1] =
            DDRTCM_DW.Buffer_r.satellite_velocity[DDRTCM_B.c];
        }
      }
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.satellite_velocity[0], &DDRTCM_B.b_addRow[0],
                6000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.variance_pseudorange
        [DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.variance_pseudorange[DDRTCM_B.b_k * 50],
                  49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.variance_pseudorange[0], &DDRTCM_B.addRow[0],
                2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.variance_pseudorange_measured
        [DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.variance_pseudorange_measured[DDRTCM_B.b_k
                  * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.variance_pseudorange_measured[0],
                &DDRTCM_B.addRow[0], 2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.variance_deltarange
        [DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.variance_deltarange[DDRTCM_B.b_k * 50],
                  49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.variance_deltarange[0], &DDRTCM_B.addRow[0],
                2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.carrierphase[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.carrierphase[DDRTCM_B.b_k * 50], 49U *
                  sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.carrierphase[0], &DDRTCM_B.addRow[0], 2000U *
                sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.variance_carrierphase_measured
        [DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.variance_carrierphase_measured[DDRTCM_B.b_k
                  * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.variance_carrierphase_measured[0],
                &DDRTCM_B.addRow[0], 2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.locktime[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow_m[50 * DDRTCM_B.b_k] = static_cast<real32_T>
        (DDRTCM_B.timeVec_data[DDRTCM_B.b_k]);
      std::memcpy(&DDRTCM_B.addRow_m[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.locktime[DDRTCM_B.b_k * 50], 49U * sizeof
                  (real32_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.locktime[0], &DDRTCM_B.addRow_m[0], 2000U *
                sizeof(real32_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.assignPosB_DIMS1.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.assignPosB_DIMS1.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a.CN0[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_r.CN0[DDRTCM_B.b_k * 50], 49U * sizeof
                  (real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.CN0[0], &DDRTCM_B.addRow[0], 2000U * sizeof
                (real_T));
    DDRTCM_B.dv1[0] = DDRTCM_U.RTCM_3_3_L1_E1_Bus.base[0];
    DDRTCM_B.dv1[50] = DDRTCM_U.RTCM_3_3_L1_E1_Bus.base[1];
    DDRTCM_B.dv1[100] = DDRTCM_U.RTCM_3_3_L1_E1_Bus.base[2];
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 49; DDRTCM_B.b_k++) {
      DDRTCM_B.dv1[DDRTCM_B.b_k + 1] =
        DDRTCM_DW.Buffer_r.base_position[DDRTCM_B.b_k];
      DDRTCM_B.dv1[DDRTCM_B.b_k + 51] =
        DDRTCM_DW.Buffer_r.base_position[DDRTCM_B.b_k + 50];
      DDRTCM_B.dv1[DDRTCM_B.b_k + 101] =
        DDRTCM_DW.Buffer_r.base_position[DDRTCM_B.b_k + 100];
    }

    std::memcpy(&DDRTCM_DW.Buffer_r.base_position[0], &DDRTCM_B.dv1[0], 150U *
                sizeof(real_T));
  }

  if (DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.time_receive >
      DDRTCM_DW.Buffer_u.TOW[0]) {
    DDRTCM_B.dv3[0] =
      DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.time_receive;
    std::memcpy(&DDRTCM_B.dv3[1], &DDRTCM_DW.Buffer_u.TOW[0], 49U * sizeof
                (real_T));
    std::memcpy(&DDRTCM_DW.Buffer_u.TOW[0], &DDRTCM_B.dv3[0], 50U * sizeof
                (real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.pseudorangeCorrections[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.PR[DDRTCM_B.b_k * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.PR[0], &DDRTCM_B.addRow[0], 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.dr_kl_ur_GPS_data[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.DR[DDRTCM_B.b_k * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.DR[0], &DDRTCM_B.addRow[0], 2000U * sizeof
                (real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.rtb_GNSS_measurement_out_PRN[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow_c[50 * DDRTCM_B.b_k] = static_cast<uint16_T>
        (DDRTCM_B.timeVec_data[DDRTCM_B.b_k]);
      std::memcpy(&DDRTCM_B.addRow_c[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.SVID[DDRTCM_B.b_k * 50], 49U * sizeof
                  (uint16_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.SVID[0], &DDRTCM_B.addRow_c[0], 2000U *
                sizeof(uint16_T));
    std::memset(&DDRTCM_B.b_addRow_b[0], 0, 120U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.k = 0;
      DDRTCM_B.c = 0;
    } else {
      DDRTCM_B.k = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.c = 40;
    }

    DDRTCM_B.c_i = DDRTCM_B.c - DDRTCM_B.k;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.c_i;
           DDRTCM_B.trueCount++) {
        DDRTCM_B.b_addRow_b[(DDRTCM_B.k + DDRTCM_B.trueCount) + 40 *
          DDRTCM_B.b_k] = DDRTCM_B.rtb_GNSS_measurement_out_satell[DDRTCM_B.c_i *
          DDRTCM_B.b_k + DDRTCM_B.trueCount];
      }
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.b_addRow_b[DDRTCM_B.b_k];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 2000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 40];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 4000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 80];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < 49; DDRTCM_B.trueCount++)
      {
        for (DDRTCM_B.k = 0; DDRTCM_B.k < 3; DDRTCM_B.k++) {
          DDRTCM_B.c = (50 * DDRTCM_B.b_k + DDRTCM_B.trueCount) + 2000 *
            DDRTCM_B.k;
          DDRTCM_B.b_addRow[DDRTCM_B.c + 1] =
            DDRTCM_DW.Buffer_u.satellite_position[DDRTCM_B.c];
        }
      }
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.satellite_position[0], &DDRTCM_B.b_addRow[0],
                6000U * sizeof(real_T));
    std::memset(&DDRTCM_B.b_addRow_b[0], 0, 120U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.k = 0;
      DDRTCM_B.c = 0;
    } else {
      DDRTCM_B.k = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.c = 40;
    }

    DDRTCM_B.c_i = DDRTCM_B.c - DDRTCM_B.k;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.c_i;
           DDRTCM_B.trueCount++) {
        DDRTCM_B.b_addRow_b[(DDRTCM_B.k + DDRTCM_B.trueCount) + 40 *
          DDRTCM_B.b_k] = DDRTCM_B.rtb_GNSS_measurement_out_sate_c[DDRTCM_B.c_i *
          DDRTCM_B.b_k + DDRTCM_B.trueCount];
      }
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.b_addRow_b[DDRTCM_B.b_k];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 2000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 40];
      DDRTCM_B.b_addRow[50 * DDRTCM_B.b_k + 4000] =
        DDRTCM_B.b_addRow_b[DDRTCM_B.b_k + 80];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < 49; DDRTCM_B.trueCount++)
      {
        for (DDRTCM_B.k = 0; DDRTCM_B.k < 3; DDRTCM_B.k++) {
          DDRTCM_B.c = (50 * DDRTCM_B.b_k + DDRTCM_B.trueCount) + 2000 *
            DDRTCM_B.k;
          DDRTCM_B.b_addRow[DDRTCM_B.c + 1] =
            DDRTCM_DW.Buffer_u.satellite_velocity[DDRTCM_B.c];
        }
      }
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.satellite_velocity[0], &DDRTCM_B.b_addRow[0],
                6000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.carrierphase_kl_ur_GPS_data[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.variance_pseudorange[DDRTCM_B.b_k * 50],
                  49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.variance_pseudorange[0], &DDRTCM_B.addRow[0],
                2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.rtb_GNSS_measurement_out_varian[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.variance_pseudorange_measured[DDRTCM_B.b_k
                  * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.variance_pseudorange_measured[0],
                &DDRTCM_B.addRow[0], 2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.elevation_Angle_data[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.variance_deltarange[DDRTCM_B.b_k * 50],
                  49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.variance_deltarange[0], &DDRTCM_B.addRow[0],
                2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.pr_kl_ur_GAL_data[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.carrierphase[DDRTCM_B.b_k * 50], 49U *
                  sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.carrierphase[0], &DDRTCM_B.addRow[0], 2000U *
                sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.dr_kl_ur_GAL_data[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.variance_carrierphase_measured[DDRTCM_B.b_k
                  * 50], 49U * sizeof(real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.variance_carrierphase_measured[0],
                &DDRTCM_B.addRow[0], 2000U * sizeof(real_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.rtb_GNSS_measurement_out_lockti[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow_m[50 * DDRTCM_B.b_k] = static_cast<real32_T>
        (DDRTCM_B.timeVec_data[DDRTCM_B.b_k]);
      std::memcpy(&DDRTCM_B.addRow_m[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.locktime[DDRTCM_B.b_k * 50], 49U * sizeof
                  (real32_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.locktime[0], &DDRTCM_B.addRow_m[0], 2000U *
                sizeof(real32_T));
    std::memset(&DDRTCM_B.timeVec_data[0], 0, 40U * sizeof(real_T));
    if (41 - DDRTCM_DW.SFunction_DIMS2_a.PRN > 40) {
      DDRTCM_B.c = 0;
      DDRTCM_B.k = 0;
    } else {
      DDRTCM_B.c = 40 - DDRTCM_DW.SFunction_DIMS2_a.PRN;
      DDRTCM_B.k = 40;
    }

    DDRTCM_B.k -= DDRTCM_B.c;
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.k; DDRTCM_B.b_k++) {
      DDRTCM_B.timeVec_data[DDRTCM_B.c + DDRTCM_B.b_k] =
        DDRTCM_B.carrierphase_kl_ur_GAL_data[DDRTCM_B.b_k];
    }

    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
      DDRTCM_B.addRow[50 * DDRTCM_B.b_k] = DDRTCM_B.timeVec_data[DDRTCM_B.b_k];
      std::memcpy(&DDRTCM_B.addRow[DDRTCM_B.b_k * 50 + 1],
                  &DDRTCM_DW.Buffer_u.CN0[DDRTCM_B.b_k * 50], 49U * sizeof
                  (real_T));
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.CN0[0], &DDRTCM_B.addRow[0], 2000U * sizeof
                (real_T));
    DDRTCM_B.dv1[0] =
      DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.base_position[0];
    DDRTCM_B.dv1[50] =
      DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.base_position[1];
    DDRTCM_B.dv1[100] =
      DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a.base_position[2];
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 49; DDRTCM_B.b_k++) {
      DDRTCM_B.dv1[DDRTCM_B.b_k + 1] =
        DDRTCM_DW.Buffer_u.base_position[DDRTCM_B.b_k];
      DDRTCM_B.dv1[DDRTCM_B.b_k + 51] =
        DDRTCM_DW.Buffer_u.base_position[DDRTCM_B.b_k + 50];
      DDRTCM_B.dv1[DDRTCM_B.b_k + 101] =
        DDRTCM_DW.Buffer_u.base_position[DDRTCM_B.b_k + 100];
    }

    std::memcpy(&DDRTCM_DW.Buffer_u.base_position[0], &DDRTCM_B.dv1[0], 150U *
                sizeof(real_T));
  }

  // Outport: '<Root>/svidRefSatGPS' incorporates:
  //   MATLAB Function: '<S2>/calculate double diff'

  DDRTCM_Y.svidRefSatGPS = MAX_uint16_T;

  // Outport: '<Root>/svidRefSatGAL' incorporates:
  //   MATLAB Function: '<S2>/calculate double diff'

  DDRTCM_Y.svidRefSatGAL = MAX_uint16_T;

  // MATLAB Function: '<S2>/calculate double diff' incorporates:
  //   Inport: '<Root>/usePosLLHArray'
  //   MATLAB Function: '<S2>/Intersect'

  DDRTCM_B.k = -1;
  DDRTCM_B.c = -1;
  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 50; DDRTCM_B.b_k++) {
    DDRTCM_B.dv2[DDRTCM_B.b_k] = DDRTCM_DW.Buffer_r.TOW[DDRTCM_B.b_k];
    DDRTCM_B.dv2[DDRTCM_B.b_k + 50] = DDRTCM_DW.Buffer_u.TOW[DDRTCM_B.b_k];
  }

  DDRTCM_maximum_l(DDRTCM_B.dv2, DDRTCM_B.p);
  DDRTCM_B.state_o = DDRTCM_minimum(DDRTCM_B.p);
  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 50; DDRTCM_B.b_k++) {
    DDRTCM_B.dv2[DDRTCM_B.b_k] = DDRTCM_DW.Buffer_r.TOW[DDRTCM_B.b_k];
    DDRTCM_B.dv2[DDRTCM_B.b_k + 50] = DDRTCM_DW.Buffer_u.TOW[DDRTCM_B.b_k];
  }

  DDRTCM_minimum_a(DDRTCM_B.dv2, DDRTCM_B.p);
  if (DDRTCM_B.state_o - DDRTCM_maximum_ln(DDRTCM_B.p) > 0.0) {
    for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 50; DDRTCM_B.b_k++) {
      DDRTCM_B.b_y[DDRTCM_B.b_k] = (std::abs(DDRTCM_DW.Buffer_r.TOW[DDRTCM_B.b_k]
        - DDRTCM_B.state_o) < 0.05);
      DDRTCM_B.b_y_n[DDRTCM_B.b_k] = (std::abs
        (DDRTCM_DW.Buffer_u.TOW[DDRTCM_B.b_k] - DDRTCM_B.state_o) < 0.05);
    }

    DDRTCM_eml_find_h(DDRTCM_B.b_y, DDRTCM_B.idx_r_data, &DDRTCM_B.tmp_size_j);
    DDRTCM_eml_find_h(DDRTCM_B.b_y_n, DDRTCM_B.idx_u_data,
                      &DDRTCM_B.SFunction_DIMS2_a);
    if ((DDRTCM_B.tmp_size_j != 0) && (DDRTCM_B.SFunction_DIMS2_a != 0)) {
      // Outport: '<Root>/GNSSMeasurementBus'
      DDRTCM_Y.GNSSMeasurementBus.time_receive = DDRTCM_B.state_o;
      DDRTCM_B.k = DDRTCM_B.idx_r_data[0];
      DDRTCM_B.c = DDRTCM_B.idx_u_data[0];
      DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
      DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
      DDRTCM_B.b_k = DDRTCM_B.idx_r_data[0];
      DDRTCM_B.trueCount = 0;
      for (DDRTCM_B.c_i = 0; DDRTCM_B.c_i < 40; DDRTCM_B.c_i++) {
        DDRTCM_B.rtb_GNSS_measurement_out_PRN[DDRTCM_B.c_i] =
          DDRTCM_DW.Buffer_r.SVID[(50 * DDRTCM_B.c_i + DDRTCM_B.d_i) - 1];
        DDRTCM_B.u_SVID[DDRTCM_B.c_i] = DDRTCM_DW.Buffer_u.SVID[(50 *
          DDRTCM_B.c_i + DDRTCM_B.i) - 1];
        DDRTCM_B.FixPtRelationalOperator_p = (DDRTCM_DW.Buffer_r.SVID[(50 *
          DDRTCM_B.c_i + DDRTCM_B.b_k) - 1] == 0);
        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.trueCount++;
        }

        DDRTCM_B.useableIdx[DDRTCM_B.c_i] = DDRTCM_B.FixPtRelationalOperator_p;
      }

      DDRTCM_B.d_i = DDRTCM_B.trueCount;
      DDRTCM_B.trueCount = 0;
      for (DDRTCM_B.c_i = 0; DDRTCM_B.c_i < 40; DDRTCM_B.c_i++) {
        if (DDRTCM_B.useableIdx[DDRTCM_B.c_i]) {
          DDRTCM_B.gc_data[DDRTCM_B.trueCount] = static_cast<int8_T>
            (DDRTCM_B.c_i + 1);
          DDRTCM_B.trueCount++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.d_i; DDRTCM_B.b_k++) {
        DDRTCM_B.rtb_GNSS_measurement_out_PRN[DDRTCM_B.gc_data[DDRTCM_B.b_k] - 1]
          = MAX_uint16_T;
      }

      DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.d_i = 0; DDRTCM_B.d_i < 40; DDRTCM_B.d_i++) {
        DDRTCM_B.FixPtRelationalOperator_p = (DDRTCM_DW.Buffer_u.SVID[(50 *
          DDRTCM_B.d_i + DDRTCM_B.i) - 1] == 0);
        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.c_i++;
        }

        DDRTCM_B.useableIdx[DDRTCM_B.d_i] = DDRTCM_B.FixPtRelationalOperator_p;
      }

      DDRTCM_B.trueCount = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 40; DDRTCM_B.b_k++) {
        if (DDRTCM_B.useableIdx[DDRTCM_B.b_k]) {
          DDRTCM_B.hc_data[DDRTCM_B.c_i] = static_cast<int8_T>(DDRTCM_B.b_k + 1);
          DDRTCM_B.c_i++;
        }
      }

      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.trueCount; DDRTCM_B.b_k++)
      {
        DDRTCM_B.u_SVID[DDRTCM_B.hc_data[DDRTCM_B.b_k] - 1] = MAX_uint16_T;
      }

      DDRTCM_do_vectors_p(DDRTCM_B.rtb_GNSS_measurement_out_PRN, DDRTCM_B.u_SVID,
                          DDRTCM_B.SVID_data, DDRTCM_B.timeVec_size,
                          DDRTCM_B.ia_data, &DDRTCM_B.ia_size, DDRTCM_B.ib_data,
                          &DDRTCM_B.ib_size);
      DDRTCM_B.c_i = DDRTCM_B.ia_size;
      if (DDRTCM_B.c_i - 1 >= 0) {
        std::memcpy(&DDRTCM_B.b_idx_r_data[0], &DDRTCM_B.ia_data[0],
                    static_cast<uint32_T>(DDRTCM_B.c_i) * sizeof(int32_T));
      }

      DDRTCM_B.c_i = DDRTCM_B.ib_size;
      if (DDRTCM_B.c_i - 1 >= 0) {
        std::memcpy(&DDRTCM_B.b_idx_u_data[0], &DDRTCM_B.ib_data[0],
                    static_cast<uint32_T>(DDRTCM_B.c_i) * sizeof(int32_T));
      }

      DDRTCM_B.c_i = DDRTCM_B.timeVec_size[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        DDRTCM_B.useableIdx[DDRTCM_B.b_k] = (DDRTCM_B.SVID_data[DDRTCM_B.b_k] >=
          1);
      }

      DDRTCM_B.c_i = DDRTCM_B.timeVec_size[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        DDRTCM_B.e[DDRTCM_B.b_k] = (DDRTCM_B.SVID_data[DDRTCM_B.b_k] <= 37);
      }

      DDRTCM_B.dc_size_idx_1 = DDRTCM_B.timeVec_size[1];
      DDRTCM_B.c_i = DDRTCM_B.timeVec_size[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        DDRTCM_B.dc_data[DDRTCM_B.b_k] = (DDRTCM_B.SVID_data[DDRTCM_B.b_k] >= 70);
      }

      DDRTCM_B.c_i = DDRTCM_B.timeVec_size[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        DDRTCM_B.ec_data[DDRTCM_B.b_k] = (DDRTCM_B.SVID_data[DDRTCM_B.b_k] <=
          102);
      }

      DDRTCM_B.pr_kl_ur_GPS_size[0] = 0;
      DDRTCM_B.pr_kl_ur_GPS_size[1] = 0;
      DDRTCM_B.dr_kl_ur_GPS_size[0] = 0;
      DDRTCM_B.dr_kl_ur_GPS_size[1] = 0;
      DDRTCM_B.carrierphase_kl_ur_GPS_size[0] = 0;
      DDRTCM_B.carrierphase_kl_ur_GPS_size[1] = 0;
      DDRTCM_B.d_i = DDRTCM_B.timeVec_size[1] - 1;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (DDRTCM_B.useableIdx[DDRTCM_B.trueCount] &&
            DDRTCM_B.e[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.i = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (DDRTCM_B.useableIdx[DDRTCM_B.trueCount] &&
            DDRTCM_B.e[DDRTCM_B.trueCount]) {
          DDRTCM_B.ic_data[DDRTCM_B.c_i] = static_cast<int8_T>
            (DDRTCM_B.trueCount + 1);
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.idx_u_GPS_size = DDRTCM_B.i;
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.i; DDRTCM_B.b_k++) {
        DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] =
          DDRTCM_B.ib_data[DDRTCM_B.ic_data[DDRTCM_B.b_k] - 1];
      }

      DDRTCM_B.bc_size_d[0] = 1;
      DDRTCM_B.bc_size_d[1] = DDRTCM_B.timeVec_size[1];
      DDRTCM_B.c_i = DDRTCM_B.timeVec_size[1];
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
        DDRTCM_B.bc_data[DDRTCM_B.b_k] = (DDRTCM_B.useableIdx[DDRTCM_B.b_k] &&
          DDRTCM_B.e[DDRTCM_B.b_k]);
      }

      if (DDRTCM_any_e1(DDRTCM_B.bc_data, DDRTCM_B.bc_size_d)) {
        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.useableIdx[DDRTCM_B.trueCount] &&
              DDRTCM_B.e[DDRTCM_B.trueCount]) {
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.jc_size_idx_1 = DDRTCM_B.c_i;
        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.useableIdx[DDRTCM_B.trueCount] &&
              DDRTCM_B.e[DDRTCM_B.trueCount]) {
            DDRTCM_B.jc_data[DDRTCM_B.c_i] = static_cast<int8_T>
              (DDRTCM_B.trueCount + 1);
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.idx_u_GPS_size = DDRTCM_B.jc_size_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.jc_size_idx_1;
             DDRTCM_B.b_k++) {
          DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] =
            DDRTCM_B.ib_data[DDRTCM_B.jc_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.useableIdx[DDRTCM_B.trueCount] &&
              DDRTCM_B.e[DDRTCM_B.trueCount]) {
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.c_i;
        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.useableIdx[DDRTCM_B.trueCount] &&
              DDRTCM_B.e[DDRTCM_B.trueCount]) {
            DDRTCM_B.kc_data[DDRTCM_B.c_i] = static_cast<int8_T>
              (DDRTCM_B.trueCount + 1);
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.idx_r_GPS_size = DDRTCM_B.kc_size_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.kc_size_idx_1;
             DDRTCM_B.b_k++) {
          DDRTCM_B.idx_r_GPS_data[DDRTCM_B.b_k] =
            DDRTCM_B.ia_data[DDRTCM_B.kc_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.tmp_size_e[0] = DDRTCM_B.jc_size_idx_1;
        DDRTCM_B.tmp_size_e[1] = 3;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <
               DDRTCM_B.jc_size_idx_1; DDRTCM_B.trueCount++) {
            DDRTCM_B.b_addRow_b[DDRTCM_B.trueCount + DDRTCM_B.jc_size_idx_1 *
              DDRTCM_B.b_k] = DDRTCM_DW.Buffer_u.satellite_position
              [(((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.i) + 2000 * DDRTCM_B.b_k) - 1];
          }
        }

        calculate_Satellite_Elevation_a(DDRTCM_U.usePosLLHArray,
          DDRTCM_B.b_addRow_b, DDRTCM_B.tmp_size_e, DDRTCM_B.timeVec_data,
          &DDRTCM_B.SFunction_DIMS2, DDRTCM_B.rtb_GNSS_measurement_out_varian,
          &DDRTCM_B.ia_size);
        DDRTCM_B.timeVec_size[0] = 1;
        DDRTCM_B.timeVec_size[1] = DDRTCM_B.jc_size_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.jc_size_idx_1;
             DDRTCM_B.b_k++) {
          DDRTCM_B.SVID_data[DDRTCM_B.b_k] =
            DDRTCM_B.u_SVID[DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_do_vectors_pj(DDRTCM_B.SVID_data, DDRTCM_B.timeVec_size,
                             DDRTCM_B.tmp_data_b, &DDRTCM_B.tmp_size_a,
                             DDRTCM_B.a__2_data, &DDRTCM_B.SFunction_DIMS2_j,
                             DDRTCM_B.ia_data, &DDRTCM_B.ia_size,
                             DDRTCM_B.ib_data, &DDRTCM_B.ib_size);
        DDRTCM_B.c_i = DDRTCM_B.ia_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.rtb_GNSS_measurement_out_varian[DDRTCM_B.b_k] =
            DDRTCM_B.ia_data[DDRTCM_B.b_k];
        }

        DDRTCM_B.elevation_Angle_size = DDRTCM_B.SFunction_DIMS2;
        DDRTCM_B.c_i = DDRTCM_B.SFunction_DIMS2;
        if (DDRTCM_B.c_i - 1 >= 0) {
          std::memset(&DDRTCM_B.elevation_Angle_data[0], 0, static_cast<uint32_T>
                      (DDRTCM_B.c_i) * sizeof(real_T));
        }

        DDRTCM_B.c_i = DDRTCM_B.ia_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.trueCount = static_cast<int32_T>
            (DDRTCM_B.rtb_GNSS_measurement_out_varian[DDRTCM_B.b_k]);
          DDRTCM_B.elevation_Angle_data[DDRTCM_B.trueCount - 1] =
            DDRTCM_B.timeVec_data[DDRTCM_B.trueCount - 1];
        }

        DDRTCM_maximum_lnq(DDRTCM_B.elevation_Angle_data,
                           &DDRTCM_B.elevation_Angle_size, &DDRTCM_B.state_o,
                           &DDRTCM_B.trueCount);
        DDRTCM_B.b_k = DDRTCM_B.idx_u_GPS_data[DDRTCM_B.trueCount - 1] - 1;

        // Outport: '<Root>/svidRefSatGPS' incorporates:
        //   Inport: '<Root>/usePosLLHArray'
        //   MATLAB Function: '<S2>/Intersect'

        DDRTCM_Y.svidRefSatGPS = DDRTCM_B.u_SVID[DDRTCM_B.b_k];
        if (DDRTCM_B.jc_size_idx_1 == DDRTCM_B.kc_size_idx_1) {
          DDRTCM_B.state_o = DDRTCM_DW.Buffer_u.PR[(DDRTCM_B.b_k * 50 +
            DDRTCM_B.idx_u_data[0]) - 1] - DDRTCM_DW.Buffer_r.PR
            [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.trueCount - 1] - 1) * 50 +
              DDRTCM_B.idx_r_data[0]) - 1];
          DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
          DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
          DDRTCM_B.pr_kl_ur_GPS_size[0] = 1;
          DDRTCM_B.pr_kl_ur_GPS_size[1] = DDRTCM_B.jc_size_idx_1;
          for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.jc_size_idx_1;
               DDRTCM_B.b_k++) {
            DDRTCM_B.pseudorangeCorrections[DDRTCM_B.b_k] = DDRTCM_B.state_o -
              (DDRTCM_DW.Buffer_u.PR[((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1)
                * 50 + DDRTCM_B.i) - 1] - DDRTCM_DW.Buffer_r.PR
               [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.d_i)
               - 1]);
          }
        } else {
          DDRTCM_binary_expand_op_bfmqb0c(DDRTCM_B.pseudorangeCorrections,
            DDRTCM_B.pr_kl_ur_GPS_size, &DDRTCM_DW.Buffer_u, DDRTCM_B.idx_u_data,
            DDRTCM_B.idx_u_GPS_data, &DDRTCM_B.idx_u_GPS_size,
            DDRTCM_B.trueCount, &DDRTCM_DW.Buffer_r, DDRTCM_B.idx_r_data,
            DDRTCM_B.idx_r_GPS_data, &DDRTCM_B.idx_r_GPS_size);
        }

        DDRTCM_B.pseudorangeCorrections[DDRTCM_B.trueCount - 1] = (rtNaN);
        if (DDRTCM_B.jc_size_idx_1 == DDRTCM_B.kc_size_idx_1) {
          DDRTCM_B.state_o = DDRTCM_DW.Buffer_u.DR
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.trueCount - 1] - 1) * 50 +
              DDRTCM_B.idx_u_data[0]) - 1] - DDRTCM_DW.Buffer_r.DR
            [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.trueCount - 1] - 1) * 50 +
              DDRTCM_B.idx_r_data[0]) - 1];
          DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
          DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
          DDRTCM_B.dr_kl_ur_GPS_size[0] = 1;
          DDRTCM_B.dr_kl_ur_GPS_size[1] = DDRTCM_B.jc_size_idx_1;
          for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.jc_size_idx_1;
               DDRTCM_B.b_k++) {
            DDRTCM_B.dr_kl_ur_GPS_data[DDRTCM_B.b_k] = DDRTCM_B.state_o -
              (DDRTCM_DW.Buffer_u.DR[((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1)
                * 50 + DDRTCM_B.i) - 1] - DDRTCM_DW.Buffer_r.DR
               [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.d_i)
               - 1]);
          }
        } else {
          DDRTCM_binary_expand_op_bfmqb0(DDRTCM_B.dr_kl_ur_GPS_data,
            DDRTCM_B.dr_kl_ur_GPS_size, &DDRTCM_DW.Buffer_u, DDRTCM_B.idx_u_data,
            DDRTCM_B.idx_u_GPS_data, &DDRTCM_B.idx_u_GPS_size,
            DDRTCM_B.trueCount, &DDRTCM_DW.Buffer_r, DDRTCM_B.idx_r_data,
            DDRTCM_B.idx_r_GPS_data, &DDRTCM_B.idx_r_GPS_size);
        }

        DDRTCM_B.dr_kl_ur_GPS_data[DDRTCM_B.trueCount - 1] = (rtNaN);
        if (DDRTCM_B.jc_size_idx_1 == DDRTCM_B.kc_size_idx_1) {
          DDRTCM_B.state_o = DDRTCM_DW.Buffer_u.carrierphase
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.trueCount - 1] - 1) * 50 +
              DDRTCM_B.idx_u_data[0]) - 1] - DDRTCM_DW.Buffer_r.carrierphase
            [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.trueCount - 1] - 1) * 50 +
              DDRTCM_B.idx_r_data[0]) - 1];
          DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
          DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
          DDRTCM_B.carrierphase_kl_ur_GPS_size[0] = 1;
          DDRTCM_B.carrierphase_kl_ur_GPS_size[1] = DDRTCM_B.jc_size_idx_1;
          for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.jc_size_idx_1;
               DDRTCM_B.b_k++) {
            DDRTCM_B.carrierphase_kl_ur_GPS_data[DDRTCM_B.b_k] =
              DDRTCM_B.state_o - (DDRTCM_DW.Buffer_u.carrierphase
                                  [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) *
              50 + DDRTCM_B.i) - 1] - DDRTCM_DW.Buffer_r.carrierphase
                                  [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.b_k] - 1) *
              50 + DDRTCM_B.d_i) - 1]);
          }
        } else {
          DDRTCM_binary_expand_op_bfmqb(DDRTCM_B.carrierphase_kl_ur_GPS_data,
            DDRTCM_B.carrierphase_kl_ur_GPS_size, &DDRTCM_DW.Buffer_u,
            DDRTCM_B.idx_u_data, DDRTCM_B.idx_u_GPS_data,
            &DDRTCM_B.idx_u_GPS_size, DDRTCM_B.trueCount, &DDRTCM_DW.Buffer_r,
            DDRTCM_B.idx_r_data, DDRTCM_B.idx_r_GPS_data,
            &DDRTCM_B.idx_r_GPS_size);
        }

        DDRTCM_B.carrierphase_kl_ur_GPS_data[DDRTCM_B.trueCount - 1] = (rtNaN);
      }

      DDRTCM_B.pr_kl_ur_GAL_size[0] = 0;
      DDRTCM_B.pr_kl_ur_GAL_size[1] = 0;
      DDRTCM_B.dr_kl_ur_GAL_size[0] = 0;
      DDRTCM_B.dr_kl_ur_GAL_size[1] = 0;
      DDRTCM_B.carrierphase_kl_ur_GAL_size[0] = 0;
      DDRTCM_B.carrierphase_kl_ur_GAL_size[1] = 0;
      DDRTCM_B.d_i = DDRTCM_B.dc_size_idx_1 - 1;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (DDRTCM_B.dc_data[DDRTCM_B.trueCount] &&
            DDRTCM_B.ec_data[DDRTCM_B.trueCount]) {
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.i = DDRTCM_B.c_i;
      DDRTCM_B.c_i = 0;
      for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
           DDRTCM_B.trueCount++) {
        if (DDRTCM_B.dc_data[DDRTCM_B.trueCount] &&
            DDRTCM_B.ec_data[DDRTCM_B.trueCount]) {
          DDRTCM_B.lc_data[DDRTCM_B.c_i] = static_cast<int8_T>
            (DDRTCM_B.trueCount + 1);
          DDRTCM_B.c_i++;
        }
      }

      DDRTCM_B.idx_u_GAL_size = DDRTCM_B.i;
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.i; DDRTCM_B.b_k++) {
        DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] =
          DDRTCM_B.b_idx_u_data[DDRTCM_B.lc_data[DDRTCM_B.b_k] - 1];
      }

      DDRTCM_B.bc_size[0] = 1;
      DDRTCM_B.bc_size[1] = DDRTCM_B.dc_size_idx_1;
      for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.dc_size_idx_1; DDRTCM_B.b_k
           ++) {
        DDRTCM_B.useableIdx[DDRTCM_B.b_k] = (DDRTCM_B.dc_data[DDRTCM_B.b_k] &&
          DDRTCM_B.ec_data[DDRTCM_B.b_k]);
      }

      if (DDRTCM_any_e1(DDRTCM_B.useableIdx, DDRTCM_B.bc_size)) {
        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.dc_data[DDRTCM_B.trueCount] &&
              DDRTCM_B.ec_data[DDRTCM_B.trueCount]) {
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.dc_size_idx_1 = DDRTCM_B.c_i;
        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.dc_data[DDRTCM_B.trueCount] &&
              DDRTCM_B.ec_data[DDRTCM_B.trueCount]) {
            DDRTCM_B.mc_data[DDRTCM_B.c_i] = static_cast<int8_T>
              (DDRTCM_B.trueCount + 1);
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.idx_u_GAL_size = DDRTCM_B.dc_size_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.dc_size_idx_1;
             DDRTCM_B.b_k++) {
          DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] =
            DDRTCM_B.b_idx_u_data[DDRTCM_B.mc_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.dc_data[DDRTCM_B.trueCount] &&
              DDRTCM_B.ec_data[DDRTCM_B.trueCount]) {
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.jc_size_idx_1 = DDRTCM_B.c_i;
        DDRTCM_B.c_i = 0;
        for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.d_i;
             DDRTCM_B.trueCount++) {
          if (DDRTCM_B.dc_data[DDRTCM_B.trueCount] &&
              DDRTCM_B.ec_data[DDRTCM_B.trueCount]) {
            DDRTCM_B.nc_data[DDRTCM_B.c_i] = static_cast<int8_T>
              (DDRTCM_B.trueCount + 1);
            DDRTCM_B.c_i++;
          }
        }

        DDRTCM_B.idx_r_GPS_size = DDRTCM_B.jc_size_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.jc_size_idx_1;
             DDRTCM_B.b_k++) {
          DDRTCM_B.idx_r_GPS_data[DDRTCM_B.b_k] =
            DDRTCM_B.b_idx_r_data[DDRTCM_B.nc_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.tmp_size_e[0] = DDRTCM_B.dc_size_idx_1;
        DDRTCM_B.tmp_size_e[1] = 3;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <
               DDRTCM_B.dc_size_idx_1; DDRTCM_B.trueCount++) {
            DDRTCM_B.b_addRow_b[DDRTCM_B.trueCount + DDRTCM_B.dc_size_idx_1 *
              DDRTCM_B.b_k] = DDRTCM_DW.Buffer_u.satellite_position
              [(((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.i) + 2000 * DDRTCM_B.b_k) - 1];
          }
        }

        calculate_Satellite_Elevation_a(DDRTCM_U.usePosLLHArray,
          DDRTCM_B.b_addRow_b, DDRTCM_B.tmp_size_e, DDRTCM_B.timeVec_data,
          &DDRTCM_B.SFunction_DIMS2, DDRTCM_B.rtb_GNSS_measurement_out_varian,
          &DDRTCM_B.ia_size);
        DDRTCM_B.timeVec_size[0] = 1;
        DDRTCM_B.timeVec_size[1] = DDRTCM_B.dc_size_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.dc_size_idx_1;
             DDRTCM_B.b_k++) {
          DDRTCM_B.SVID_data[DDRTCM_B.b_k] =
            DDRTCM_B.u_SVID[DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_do_vectors_pj(DDRTCM_B.SVID_data, DDRTCM_B.timeVec_size,
                             DDRTCM_B.tmp_data_b, &DDRTCM_B.tmp_size_a,
                             DDRTCM_B.a__2_data, &DDRTCM_B.SFunction_DIMS2_j,
                             DDRTCM_B.ia_data, &DDRTCM_B.ia_size,
                             DDRTCM_B.ib_data, &DDRTCM_B.ib_size);
        DDRTCM_B.c_i = DDRTCM_B.ia_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.rtb_GNSS_measurement_out_varian[DDRTCM_B.b_k] =
            DDRTCM_B.ia_data[DDRTCM_B.b_k];
        }

        DDRTCM_B.elevation_Angle_size = DDRTCM_B.SFunction_DIMS2;
        DDRTCM_B.c_i = DDRTCM_B.SFunction_DIMS2;
        if (DDRTCM_B.c_i - 1 >= 0) {
          std::memset(&DDRTCM_B.elevation_Angle_data[0], 0, static_cast<uint32_T>
                      (DDRTCM_B.c_i) * sizeof(real_T));
        }

        DDRTCM_B.c_i = DDRTCM_B.ia_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.trueCount = static_cast<int32_T>
            (DDRTCM_B.rtb_GNSS_measurement_out_varian[DDRTCM_B.b_k]);
          DDRTCM_B.elevation_Angle_data[DDRTCM_B.trueCount - 1] =
            DDRTCM_B.timeVec_data[DDRTCM_B.trueCount - 1];
        }

        DDRTCM_maximum_lnq(DDRTCM_B.elevation_Angle_data,
                           &DDRTCM_B.elevation_Angle_size, &DDRTCM_B.state_o,
                           &DDRTCM_B.kc_size_idx_1);
        DDRTCM_B.b_k = DDRTCM_B.kc_size_idx_1 - 1;
        DDRTCM_B.c_i = DDRTCM_B.b_idx_u_data[DDRTCM_B.mc_data[DDRTCM_B.b_k] - 1]
          - 1;

        // Outport: '<Root>/svidRefSatGAL' incorporates:
        //   Inport: '<Root>/usePosLLHArray'
        //   MATLAB Function: '<S2>/Intersect'

        DDRTCM_Y.svidRefSatGAL = DDRTCM_B.u_SVID[DDRTCM_B.c_i];
        DDRTCM_B.b_k = DDRTCM_B.b_idx_r_data[DDRTCM_B.nc_data[DDRTCM_B.b_k] - 1]
          - 1;
        if (DDRTCM_B.dc_size_idx_1 == DDRTCM_B.jc_size_idx_1) {
          DDRTCM_B.state_o = DDRTCM_DW.Buffer_u.PR[(50 * DDRTCM_B.c_i +
            DDRTCM_B.idx_u_data[0]) - 1] - DDRTCM_DW.Buffer_r.PR[(50 *
            DDRTCM_B.b_k + DDRTCM_B.idx_r_data[0]) - 1];
          DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
          DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
          DDRTCM_B.pr_kl_ur_GAL_size[0] = 1;
          DDRTCM_B.pr_kl_ur_GAL_size[1] = DDRTCM_B.dc_size_idx_1;
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <
               DDRTCM_B.dc_size_idx_1; DDRTCM_B.trueCount++) {
            DDRTCM_B.pr_kl_ur_GAL_data[DDRTCM_B.trueCount] = DDRTCM_B.state_o -
              (DDRTCM_DW.Buffer_u.PR
               [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.i) - 1] - DDRTCM_DW.Buffer_r.PR
               [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.d_i) - 1]);
          }
        } else {
          DDRTCM_binary_expand_op_bfmq(DDRTCM_B.pr_kl_ur_GAL_data,
            DDRTCM_B.pr_kl_ur_GAL_size, &DDRTCM_DW.Buffer_u, DDRTCM_B.idx_u_data,
            DDRTCM_B.c_i, &DDRTCM_DW.Buffer_r, DDRTCM_B.idx_r_data, DDRTCM_B.b_k,
            DDRTCM_B.idx_u_GAL_data, &DDRTCM_B.idx_u_GAL_size,
            DDRTCM_B.idx_r_GPS_data, &DDRTCM_B.idx_r_GPS_size);
        }

        DDRTCM_B.pr_kl_ur_GAL_data[DDRTCM_B.kc_size_idx_1 - 1] = (rtNaN);
        if (DDRTCM_B.dc_size_idx_1 == DDRTCM_B.jc_size_idx_1) {
          DDRTCM_B.state_o = DDRTCM_DW.Buffer_u.DR[(50 * DDRTCM_B.c_i +
            DDRTCM_B.idx_u_data[0]) - 1] - DDRTCM_DW.Buffer_r.DR[(50 *
            DDRTCM_B.b_k + DDRTCM_B.idx_r_data[0]) - 1];
          DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
          DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
          DDRTCM_B.dr_kl_ur_GAL_size[0] = 1;
          DDRTCM_B.dr_kl_ur_GAL_size[1] = DDRTCM_B.dc_size_idx_1;
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <
               DDRTCM_B.dc_size_idx_1; DDRTCM_B.trueCount++) {
            DDRTCM_B.dr_kl_ur_GAL_data[DDRTCM_B.trueCount] = DDRTCM_B.state_o -
              (DDRTCM_DW.Buffer_u.DR
               [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.i) - 1] - DDRTCM_DW.Buffer_r.DR
               [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.d_i) - 1]);
          }
        } else {
          DDRTCM_binary_expand_op_bfm(DDRTCM_B.dr_kl_ur_GAL_data,
            DDRTCM_B.dr_kl_ur_GAL_size, &DDRTCM_DW.Buffer_u, DDRTCM_B.idx_u_data,
            DDRTCM_B.c_i, &DDRTCM_DW.Buffer_r, DDRTCM_B.idx_r_data, DDRTCM_B.b_k,
            DDRTCM_B.idx_u_GAL_data, &DDRTCM_B.idx_u_GAL_size,
            DDRTCM_B.idx_r_GPS_data, &DDRTCM_B.idx_r_GPS_size);
        }

        DDRTCM_B.dr_kl_ur_GAL_data[DDRTCM_B.kc_size_idx_1 - 1] = (rtNaN);
        if (DDRTCM_B.dc_size_idx_1 == DDRTCM_B.jc_size_idx_1) {
          DDRTCM_B.state_o = DDRTCM_DW.Buffer_u.carrierphase[(50 * DDRTCM_B.c_i
            + DDRTCM_B.idx_u_data[0]) - 1] - DDRTCM_DW.Buffer_r.carrierphase[(50
            * DDRTCM_B.b_k + DDRTCM_B.idx_r_data[0]) - 1];
          DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
          DDRTCM_B.d_i = DDRTCM_B.idx_r_data[0];
          DDRTCM_B.carrierphase_kl_ur_GAL_size[0] = 1;
          DDRTCM_B.carrierphase_kl_ur_GAL_size[1] = DDRTCM_B.dc_size_idx_1;
          for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.dc_size_idx_1;
               DDRTCM_B.b_k++) {
            DDRTCM_B.carrierphase_kl_ur_GAL_data[DDRTCM_B.b_k] =
              DDRTCM_B.state_o - (DDRTCM_DW.Buffer_u.carrierphase
                                  [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1) *
              50 + DDRTCM_B.i) - 1] - DDRTCM_DW.Buffer_r.carrierphase
                                  [((DDRTCM_B.idx_r_GPS_data[DDRTCM_B.b_k] - 1) *
              50 + DDRTCM_B.d_i) - 1]);
          }
        } else {
          DDRTCM_binary_expand_op_bf(DDRTCM_B.carrierphase_kl_ur_GAL_data,
            DDRTCM_B.carrierphase_kl_ur_GAL_size, &DDRTCM_DW.Buffer_u,
            DDRTCM_B.idx_u_data, DDRTCM_B.c_i, &DDRTCM_DW.Buffer_r,
            DDRTCM_B.idx_r_data, DDRTCM_B.b_k, DDRTCM_B.idx_u_GAL_data,
            &DDRTCM_B.idx_u_GAL_size, DDRTCM_B.idx_r_GPS_data,
            &DDRTCM_B.idx_r_GPS_size);
        }

        DDRTCM_B.carrierphase_kl_ur_GAL_data[DDRTCM_B.kc_size_idx_1 - 1] =
          (rtNaN);
      }

      if (((DDRTCM_B.carrierphase_kl_ur_GPS_size[0] != 0) &&
           (DDRTCM_B.carrierphase_kl_ur_GPS_size[1] != 0)) ||
          ((DDRTCM_B.carrierphase_kl_ur_GAL_size[0] != 0) &&
           (DDRTCM_B.carrierphase_kl_ur_GAL_size[1] != 0))) {
        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.dc_size_idx_1 = DDRTCM_B.idx_u_GPS_size +
          DDRTCM_B.idx_u_GAL_size;
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        DDRTCM_B.d_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.c_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.b_addRow_b[DDRTCM_B.trueCount + DDRTCM_B.dc_size_idx_1 *
              DDRTCM_B.b_k] = DDRTCM_DW.Buffer_u.satellite_position
              [(((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.i) + 2000 * DDRTCM_B.b_k) - 1];
          }

          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.b_addRow_b[(DDRTCM_B.trueCount + DDRTCM_B.idx_u_GPS_size) +
              DDRTCM_B.dc_size_idx_1 * DDRTCM_B.b_k] =
              DDRTCM_DW.Buffer_u.satellite_position
              [(((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.kc_size_idx_1) + 2000 * DDRTCM_B.b_k) - 1];
          }
        }

        DDRTCM_DW.SFunction_DIMS2.satellite_position[0] = DDRTCM_B.dc_size_idx_1;
        DDRTCM_DW.SFunction_DIMS2.satellite_position[1] = 3;
        DDRTCM_B.c_i = DDRTCM_B.dc_size_idx_1 * 3;
        if (DDRTCM_B.c_i - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_satellit[0],
                      &DDRTCM_B.b_addRow_b[0], static_cast<uint32_T>
                      (DDRTCM_B.c_i) * sizeof(real_T));
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        DDRTCM_B.d_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < 3; DDRTCM_B.b_k++) {
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.c_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.b_addRow_b[DDRTCM_B.trueCount + DDRTCM_B.dc_size_idx_1 *
              DDRTCM_B.b_k] = DDRTCM_DW.Buffer_u.satellite_velocity
              [(((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.i) + 2000 * DDRTCM_B.b_k) - 1];
          }

          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.b_addRow_b[(DDRTCM_B.trueCount + DDRTCM_B.idx_u_GPS_size) +
              DDRTCM_B.dc_size_idx_1 * DDRTCM_B.b_k] =
              DDRTCM_DW.Buffer_u.satellite_velocity
              [(((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.trueCount] - 1) * 50 +
                 DDRTCM_B.kc_size_idx_1) + 2000 * DDRTCM_B.b_k) - 1];
          }
        }

        DDRTCM_DW.SFunction_DIMS2.satellite_velocity[0] = DDRTCM_B.dc_size_idx_1;
        DDRTCM_DW.SFunction_DIMS2.satellite_velocity[1] = 3;
        DDRTCM_B.c_i = DDRTCM_B.dc_size_idx_1 * 3;
        if (DDRTCM_B.c_i - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_satell_g[0],
                      &DDRTCM_B.b_addRow_b[0], static_cast<uint32_T>
                      (DDRTCM_B.c_i) * sizeof(real_T));
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.tmp_data_b[DDRTCM_B.b_k] =
            DDRTCM_B.u_SVID[DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.tmp_data_b[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_B.u_SVID[DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.PRN = DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.SVIDCorrections[0], &DDRTCM_B.tmp_data_b[0],
                      static_cast<uint32_T>(DDRTCM_B.dc_size_idx_1) * sizeof
                      (uint16_T));
        }

        DDRTCM_B.c_i = DDRTCM_B.pr_kl_ur_GPS_size[0];
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.pr_kl_ur_GPS_size[1];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.varargin_1_data[DDRTCM_B.trueCount] =
              DDRTCM_B.pseudorangeCorrections[DDRTCM_B.pr_kl_ur_GPS_size[0] *
              DDRTCM_B.trueCount];
          }
        }

        DDRTCM_B.c_i = DDRTCM_B.pr_kl_ur_GAL_size[0];
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.pr_kl_ur_GAL_size[1];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.varargin_2_data[DDRTCM_B.trueCount] =
              DDRTCM_B.pr_kl_ur_GAL_data[DDRTCM_B.pr_kl_ur_GAL_size[0] *
              DDRTCM_B.trueCount];
          }
        }

        if ((DDRTCM_B.pr_kl_ur_GPS_size[1] != 0) && (DDRTCM_B.pr_kl_ur_GPS_size
             [0] != 0)) {
          DDRTCM_B.sizes_idx_1 = 1;
        } else if ((DDRTCM_B.pr_kl_ur_GAL_size[1] != 0) &&
                   (DDRTCM_B.pr_kl_ur_GAL_size[0] != 0)) {
          DDRTCM_B.sizes_idx_1 = 1;
        } else {
          DDRTCM_B.b_k = (DDRTCM_B.pr_kl_ur_GPS_size[0] > 0);
          if (DDRTCM_B.pr_kl_ur_GAL_size[0] > DDRTCM_B.b_k) {
            DDRTCM_B.sizes_idx_1 = 1;
          } else {
            DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.b_k);
          }
        }

        DDRTCM_B.FixPtRelationalOperator_p = (DDRTCM_B.sizes_idx_1 == 0);
        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.pr_kl_ur_GPS_size[1]);
        } else if ((DDRTCM_B.pr_kl_ur_GPS_size[1] != 0) &&
                   (DDRTCM_B.pr_kl_ur_GPS_size[0] != 0)) {
          DDRTCM_B.empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.pr_kl_ur_GPS_size[1]);
        } else {
          DDRTCM_B.empty_non_axis_sizes[0] = 0;
        }

        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.empty_non_axis_sizes_m[0] = static_cast<int8_T>
            (DDRTCM_B.pr_kl_ur_GAL_size[1]);
        } else if ((DDRTCM_B.pr_kl_ur_GAL_size[1] != 0) &&
                   (DDRTCM_B.pr_kl_ur_GAL_size[0] != 0)) {
          DDRTCM_B.empty_non_axis_sizes_m[0] = static_cast<int8_T>
            (DDRTCM_B.pr_kl_ur_GAL_size[1]);
        } else {
          DDRTCM_B.empty_non_axis_sizes_m[0] = 0;
        }

        DDRTCM_B.i = DDRTCM_B.empty_non_axis_sizes[0] +
          DDRTCM_B.empty_non_axis_sizes_m[0];
        DDRTCM_B.c_i = DDRTCM_B.sizes_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.empty_non_axis_sizes[0];
          if (DDRTCM_B.d_i - 1 >= 0) {
            std::memcpy(&DDRTCM_B.result_data[0], &DDRTCM_B.varargin_1_data[0],
                        static_cast<uint32_T>(DDRTCM_B.d_i) * sizeof(real_T));
          }
        }

        DDRTCM_B.c_i = DDRTCM_B.sizes_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.empty_non_axis_sizes_m[0];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.result_data[DDRTCM_B.trueCount +
              DDRTCM_B.empty_non_axis_sizes[0]] =
              DDRTCM_B.varargin_2_data[DDRTCM_B.trueCount];
          }
        }

        DDRTCM_DW.SFunction_DIMS2.pseudorange = DDRTCM_B.i;
        if (DDRTCM_B.i - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_pseudora[0],
                      &DDRTCM_B.result_data[0], static_cast<uint32_T>(DDRTCM_B.i)
                      * sizeof(real_T));
        }

        if (DDRTCM_B.pr_kl_ur_GPS_size[0] == 0) {
          DDRTCM_B.c_i = 0;
        } else if (DDRTCM_B.pr_kl_ur_GPS_size[1] == 0) {
          DDRTCM_B.c_i = 0;
        } else {
          DDRTCM_B.c_i = DDRTCM_B.pr_kl_ur_GPS_size[1];
        }

        if (DDRTCM_B.pr_kl_ur_GAL_size[0] == 0) {
          DDRTCM_B.i = 0;
        } else if (DDRTCM_B.pr_kl_ur_GAL_size[1] == 0) {
          DDRTCM_B.i = 0;
        } else {
          DDRTCM_B.i = DDRTCM_B.pr_kl_ur_GAL_size[1];
        }

        if (DDRTCM_B.c_i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        } else if (DDRTCM_B.i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else if (DDRTCM_B.i > DDRTCM_B.c_i) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        }

        if (DDRTCM_B.sizes_idx_1 == 0) {
          DDRTCM_B.empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.c_i);
          DDRTCM_B.b_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          if (DDRTCM_B.c_i != 0) {
            DDRTCM_B.empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.c_i);
          } else {
            DDRTCM_B.empty_non_axis_sizes[0] = 0;
          }

          if (DDRTCM_B.i != 0) {
            DDRTCM_B.b_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
          } else {
            DDRTCM_B.b_empty_non_axis_sizes[0] = 0;
          }
        }

        DDRTCM_DW.SFunction_DIMS2.pseudorange_raw =
          DDRTCM_B.empty_non_axis_sizes[0] + DDRTCM_B.b_empty_non_axis_sizes[0];
        if (DDRTCM_B.pr_kl_ur_GPS_size[0] == 0) {
          DDRTCM_B.c_i = 0;
        } else if (DDRTCM_B.pr_kl_ur_GPS_size[1] == 0) {
          DDRTCM_B.c_i = 0;
        } else {
          DDRTCM_B.c_i = DDRTCM_B.pr_kl_ur_GPS_size[1];
        }

        if (DDRTCM_B.pr_kl_ur_GAL_size[0] == 0) {
          DDRTCM_B.i = 0;
        } else if (DDRTCM_B.pr_kl_ur_GAL_size[1] == 0) {
          DDRTCM_B.i = 0;
        } else {
          DDRTCM_B.i = DDRTCM_B.pr_kl_ur_GAL_size[1];
        }

        if (DDRTCM_B.c_i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        } else if (DDRTCM_B.i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else if (DDRTCM_B.i > DDRTCM_B.c_i) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        }

        if (DDRTCM_B.sizes_idx_1 == 0) {
          DDRTCM_B.b_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.c_i);
          DDRTCM_B.c_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          if (DDRTCM_B.c_i != 0) {
            DDRTCM_B.b_empty_non_axis_sizes[0] = static_cast<int8_T>
              (DDRTCM_B.c_i);
          } else {
            DDRTCM_B.b_empty_non_axis_sizes[0] = 0;
          }

          if (DDRTCM_B.i != 0) {
            DDRTCM_B.c_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
          } else {
            DDRTCM_B.c_empty_non_axis_sizes[0] = 0;
          }
        }

        DDRTCM_DW.SFunction_DIMS2.pseudorange_satclk_corrected =
          DDRTCM_B.b_empty_non_axis_sizes[0] + DDRTCM_B.c_empty_non_axis_sizes[0];
        DDRTCM_B.c_i = DDRTCM_B.dr_kl_ur_GPS_size[0];
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.dr_kl_ur_GPS_size[1];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.varargin_1_data[DDRTCM_B.trueCount] =
              DDRTCM_B.dr_kl_ur_GPS_data[DDRTCM_B.dr_kl_ur_GPS_size[0] *
              DDRTCM_B.trueCount];
          }
        }

        DDRTCM_B.c_i = DDRTCM_B.dr_kl_ur_GAL_size[0];
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.dr_kl_ur_GAL_size[1];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.varargin_2_data[DDRTCM_B.trueCount] =
              DDRTCM_B.dr_kl_ur_GAL_data[DDRTCM_B.dr_kl_ur_GAL_size[0] *
              DDRTCM_B.trueCount];
          }
        }

        if ((DDRTCM_B.dr_kl_ur_GPS_size[1] != 0) && (DDRTCM_B.dr_kl_ur_GPS_size
             [0] != 0)) {
          DDRTCM_B.sizes_idx_1 = 1;
        } else if ((DDRTCM_B.dr_kl_ur_GAL_size[1] != 0) &&
                   (DDRTCM_B.dr_kl_ur_GAL_size[0] != 0)) {
          DDRTCM_B.sizes_idx_1 = 1;
        } else {
          DDRTCM_B.b_k = (DDRTCM_B.dr_kl_ur_GPS_size[0] > 0);
          if (DDRTCM_B.dr_kl_ur_GAL_size[0] > DDRTCM_B.b_k) {
            DDRTCM_B.sizes_idx_1 = 1;
          } else {
            DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.b_k);
          }
        }

        DDRTCM_B.FixPtRelationalOperator_p = (DDRTCM_B.sizes_idx_1 == 0);
        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.c_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.dr_kl_ur_GPS_size[1]);
        } else if ((DDRTCM_B.dr_kl_ur_GPS_size[1] != 0) &&
                   (DDRTCM_B.dr_kl_ur_GPS_size[0] != 0)) {
          DDRTCM_B.c_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.dr_kl_ur_GPS_size[1]);
        } else {
          DDRTCM_B.c_empty_non_axis_sizes[0] = 0;
        }

        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.b_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.dr_kl_ur_GAL_size[1]);
        } else if ((DDRTCM_B.dr_kl_ur_GAL_size[1] != 0) &&
                   (DDRTCM_B.dr_kl_ur_GAL_size[0] != 0)) {
          DDRTCM_B.b_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.dr_kl_ur_GAL_size[1]);
        } else {
          DDRTCM_B.b_empty_non_axis_sizes[0] = 0;
        }

        DDRTCM_B.i = DDRTCM_B.c_empty_non_axis_sizes[0] +
          DDRTCM_B.b_empty_non_axis_sizes[0];
        DDRTCM_B.c_i = DDRTCM_B.sizes_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.c_empty_non_axis_sizes[0];
          if (DDRTCM_B.d_i - 1 >= 0) {
            std::memcpy(&DDRTCM_B.result_data[0], &DDRTCM_B.varargin_1_data[0],
                        static_cast<uint32_T>(DDRTCM_B.d_i) * sizeof(real_T));
          }
        }

        DDRTCM_B.c_i = DDRTCM_B.sizes_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.b_empty_non_axis_sizes[0];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.result_data[DDRTCM_B.trueCount +
              DDRTCM_B.c_empty_non_axis_sizes[0]] =
              DDRTCM_B.varargin_2_data[DDRTCM_B.trueCount];
          }
        }

        DDRTCM_DW.SFunction_DIMS2.deltarange = DDRTCM_B.i;
        if (DDRTCM_B.i - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_deltaran[0],
                      &DDRTCM_B.result_data[0], static_cast<uint32_T>(DDRTCM_B.i)
                      * sizeof(real_T));
        }

        if (DDRTCM_B.dr_kl_ur_GPS_size[0] == 0) {
          DDRTCM_B.c_i = 0;
        } else if (DDRTCM_B.dr_kl_ur_GPS_size[1] == 0) {
          DDRTCM_B.c_i = 0;
        } else {
          DDRTCM_B.c_i = DDRTCM_B.dr_kl_ur_GPS_size[1];
        }

        if (DDRTCM_B.dr_kl_ur_GAL_size[0] == 0) {
          DDRTCM_B.i = 0;
        } else if (DDRTCM_B.dr_kl_ur_GAL_size[1] == 0) {
          DDRTCM_B.i = 0;
        } else {
          DDRTCM_B.i = DDRTCM_B.dr_kl_ur_GAL_size[1];
        }

        if (DDRTCM_B.c_i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        } else if (DDRTCM_B.i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else if (DDRTCM_B.i > DDRTCM_B.c_i) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        }

        if (DDRTCM_B.sizes_idx_1 == 0) {
          DDRTCM_B.c_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.c_i);
          DDRTCM_B.e_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          if (DDRTCM_B.c_i != 0) {
            DDRTCM_B.c_empty_non_axis_sizes[0] = static_cast<int8_T>
              (DDRTCM_B.c_i);
          } else {
            DDRTCM_B.c_empty_non_axis_sizes[0] = 0;
          }

          if (DDRTCM_B.i != 0) {
            DDRTCM_B.e_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
          } else {
            DDRTCM_B.e_empty_non_axis_sizes[0] = 0;
          }
        }

        DDRTCM_DW.SFunction_DIMS2.deltarange_raw =
          DDRTCM_B.c_empty_non_axis_sizes[0] + DDRTCM_B.e_empty_non_axis_sizes[0];
        if (DDRTCM_B.dr_kl_ur_GPS_size[0] == 0) {
          DDRTCM_B.c_i = 0;
        } else if (DDRTCM_B.dr_kl_ur_GPS_size[1] == 0) {
          DDRTCM_B.c_i = 0;
        } else {
          DDRTCM_B.c_i = DDRTCM_B.dr_kl_ur_GPS_size[1];
        }

        if (DDRTCM_B.dr_kl_ur_GAL_size[0] == 0) {
          DDRTCM_B.i = 0;
        } else if (DDRTCM_B.dr_kl_ur_GAL_size[1] == 0) {
          DDRTCM_B.i = 0;
        } else {
          DDRTCM_B.i = DDRTCM_B.dr_kl_ur_GAL_size[1];
        }

        if (DDRTCM_B.c_i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        } else if (DDRTCM_B.i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else if (DDRTCM_B.i > DDRTCM_B.c_i) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        }

        if (DDRTCM_B.sizes_idx_1 == 0) {
          DDRTCM_B.e_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.c_i);
          DDRTCM_B.f_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          if (DDRTCM_B.c_i != 0) {
            DDRTCM_B.e_empty_non_axis_sizes[0] = static_cast<int8_T>
              (DDRTCM_B.c_i);
          } else {
            DDRTCM_B.e_empty_non_axis_sizes[0] = 0;
          }

          if (DDRTCM_B.i != 0) {
            DDRTCM_B.f_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.i);
          } else {
            DDRTCM_B.f_empty_non_axis_sizes[0] = 0;
          }
        }

        DDRTCM_DW.SFunction_DIMS2.deltarange_satclk_corrected =
          DDRTCM_B.e_empty_non_axis_sizes[0] + DDRTCM_B.f_empty_non_axis_sizes[0];
        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
            DDRTCM_DW.Buffer_u.variance_pseudorange
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.i) - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_DW.Buffer_u.variance_pseudorange
            [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1) * 50 +
              DDRTCM_B.kc_size_idx_1) - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.variance_pseudorange = DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_variance[0],
                      &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                      (DDRTCM_B.dc_size_idx_1) * sizeof(real_T));
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
            DDRTCM_DW.Buffer_u.variance_pseudorange_measured
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.i) - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_DW.Buffer_u.variance_pseudorange_measured
            [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1) * 50 +
              DDRTCM_B.kc_size_idx_1) - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.variance_pseudorange_measured =
          DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_varian_d[0],
                      &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                      (DDRTCM_B.dc_size_idx_1) * sizeof(real_T));
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
            DDRTCM_DW.Buffer_u.variance_deltarange
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.i) - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_DW.Buffer_u.variance_deltarange
            [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1) * 50 +
              DDRTCM_B.kc_size_idx_1) - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.variance_deltarange = DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_varian_g[0],
                      &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                      (DDRTCM_B.dc_size_idx_1) * sizeof(real_T));
        }

        DDRTCM_B.c_i = DDRTCM_B.carrierphase_kl_ur_GPS_size[0];
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.carrierphase_kl_ur_GPS_size[1];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.varargin_1_data[DDRTCM_B.trueCount] =
              DDRTCM_B.carrierphase_kl_ur_GPS_data[DDRTCM_B.carrierphase_kl_ur_GPS_size
              [0] * DDRTCM_B.trueCount];
          }
        }

        DDRTCM_B.c_i = DDRTCM_B.carrierphase_kl_ur_GAL_size[0];
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.carrierphase_kl_ur_GAL_size[1];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.varargin_2_data[DDRTCM_B.trueCount] =
              DDRTCM_B.carrierphase_kl_ur_GAL_data[DDRTCM_B.carrierphase_kl_ur_GAL_size
              [0] * DDRTCM_B.trueCount];
          }
        }

        if ((DDRTCM_B.carrierphase_kl_ur_GPS_size[1] != 0) &&
            (DDRTCM_B.carrierphase_kl_ur_GPS_size[0] != 0)) {
          DDRTCM_B.sizes_idx_1 = 1;
        } else if ((DDRTCM_B.carrierphase_kl_ur_GAL_size[1] != 0) &&
                   (DDRTCM_B.carrierphase_kl_ur_GAL_size[0] != 0)) {
          DDRTCM_B.sizes_idx_1 = 1;
        } else {
          DDRTCM_B.b_k = (DDRTCM_B.carrierphase_kl_ur_GPS_size[0] > 0);
          if (DDRTCM_B.carrierphase_kl_ur_GAL_size[0] > DDRTCM_B.b_k) {
            DDRTCM_B.sizes_idx_1 = 1;
          } else {
            DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.b_k);
          }
        }

        DDRTCM_B.FixPtRelationalOperator_p = (DDRTCM_B.sizes_idx_1 == 0);
        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.f_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.carrierphase_kl_ur_GPS_size[1]);
        } else if ((DDRTCM_B.carrierphase_kl_ur_GPS_size[1] != 0) &&
                   (DDRTCM_B.carrierphase_kl_ur_GPS_size[0] != 0)) {
          DDRTCM_B.f_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.carrierphase_kl_ur_GPS_size[1]);
        } else {
          DDRTCM_B.f_empty_non_axis_sizes[0] = 0;
        }

        if (DDRTCM_B.FixPtRelationalOperator_p) {
          DDRTCM_B.e_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.carrierphase_kl_ur_GAL_size[1]);
        } else if ((DDRTCM_B.carrierphase_kl_ur_GAL_size[1] != 0) &&
                   (DDRTCM_B.carrierphase_kl_ur_GAL_size[0] != 0)) {
          DDRTCM_B.e_empty_non_axis_sizes[0] = static_cast<int8_T>
            (DDRTCM_B.carrierphase_kl_ur_GAL_size[1]);
        } else {
          DDRTCM_B.e_empty_non_axis_sizes[0] = 0;
        }

        DDRTCM_B.i = DDRTCM_B.f_empty_non_axis_sizes[0] +
          DDRTCM_B.e_empty_non_axis_sizes[0];
        DDRTCM_B.c_i = DDRTCM_B.sizes_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.f_empty_non_axis_sizes[0];
          if (DDRTCM_B.d_i - 1 >= 0) {
            std::memcpy(&DDRTCM_B.result_data[0], &DDRTCM_B.varargin_1_data[0],
                        static_cast<uint32_T>(DDRTCM_B.d_i) * sizeof(real_T));
          }
        }

        DDRTCM_B.c_i = DDRTCM_B.sizes_idx_1;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.d_i = DDRTCM_B.e_empty_non_axis_sizes[0];
          for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount < DDRTCM_B.d_i;
               DDRTCM_B.trueCount++) {
            DDRTCM_B.result_data[DDRTCM_B.trueCount +
              DDRTCM_B.f_empty_non_axis_sizes[0]] =
              DDRTCM_B.varargin_2_data[DDRTCM_B.trueCount];
          }
        }

        DDRTCM_DW.SFunction_DIMS2.carrierphase = DDRTCM_B.i;
        if (DDRTCM_B.i - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_carrierp[0],
                      &DDRTCM_B.result_data[0], static_cast<uint32_T>(DDRTCM_B.i)
                      * sizeof(real_T));
        }

        if (DDRTCM_B.carrierphase_kl_ur_GPS_size[0] == 0) {
          DDRTCM_B.c_i = 0;
        } else if (DDRTCM_B.carrierphase_kl_ur_GPS_size[1] == 0) {
          DDRTCM_B.c_i = 0;
        } else {
          DDRTCM_B.c_i = DDRTCM_B.carrierphase_kl_ur_GPS_size[1];
        }

        if (DDRTCM_B.carrierphase_kl_ur_GAL_size[0] == 0) {
          DDRTCM_B.i = 0;
        } else if (DDRTCM_B.carrierphase_kl_ur_GAL_size[1] == 0) {
          DDRTCM_B.i = 0;
        } else {
          DDRTCM_B.i = DDRTCM_B.carrierphase_kl_ur_GAL_size[1];
        }

        if (DDRTCM_B.c_i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        } else if (DDRTCM_B.i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else if (DDRTCM_B.i > DDRTCM_B.c_i) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        }

        if (DDRTCM_B.sizes_idx_1 == 0) {
          DDRTCM_B.f_empty_non_axis_sizes[0] = static_cast<int8_T>(DDRTCM_B.c_i);
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          if (DDRTCM_B.c_i != 0) {
            DDRTCM_B.f_empty_non_axis_sizes[0] = static_cast<int8_T>
              (DDRTCM_B.c_i);
          } else {
            DDRTCM_B.f_empty_non_axis_sizes[0] = 0;
          }

          if (DDRTCM_B.i != 0) {
            DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
          } else {
            DDRTCM_B.sizes_idx_1 = 0;
          }
        }

        DDRTCM_DW.SFunction_DIMS2.carrierphase_raw =
          DDRTCM_B.f_empty_non_axis_sizes[0] + DDRTCM_B.sizes_idx_1;
        if (DDRTCM_B.carrierphase_kl_ur_GPS_size[0] == 0) {
          DDRTCM_B.c_i = 0;
        } else if (DDRTCM_B.carrierphase_kl_ur_GPS_size[1] == 0) {
          DDRTCM_B.c_i = 0;
        } else {
          DDRTCM_B.c_i = DDRTCM_B.carrierphase_kl_ur_GPS_size[1];
        }

        if (DDRTCM_B.carrierphase_kl_ur_GAL_size[0] == 0) {
          DDRTCM_B.i = 0;
        } else if (DDRTCM_B.carrierphase_kl_ur_GAL_size[1] == 0) {
          DDRTCM_B.i = 0;
        } else {
          DDRTCM_B.i = DDRTCM_B.carrierphase_kl_ur_GAL_size[1];
        }

        if (DDRTCM_B.c_i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        } else if (DDRTCM_B.i != 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else if (DDRTCM_B.i > DDRTCM_B.c_i) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
        }

        if (DDRTCM_B.sizes_idx_1 == 0) {
          DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
          DDRTCM_B.i_empty_non_axis_sizes_idx_0 = static_cast<int8_T>(DDRTCM_B.i);
        } else {
          if (DDRTCM_B.c_i != 0) {
            DDRTCM_B.sizes_idx_1 = static_cast<int8_T>(DDRTCM_B.c_i);
          } else {
            DDRTCM_B.sizes_idx_1 = 0;
          }

          if (DDRTCM_B.i != 0) {
            DDRTCM_B.i_empty_non_axis_sizes_idx_0 = static_cast<int8_T>
              (DDRTCM_B.i);
          } else {
            DDRTCM_B.i_empty_non_axis_sizes_idx_0 = 0;
          }
        }

        DDRTCM_DW.SFunction_DIMS2.carrierphase_satclk_corrected =
          DDRTCM_B.sizes_idx_1 + DDRTCM_B.i_empty_non_axis_sizes_idx_0;
        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k] =
            DDRTCM_DW.Buffer_u.variance_carrierphase_measured
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.i) - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_DW.Buffer_u.variance_carrierphase_measured
            [((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1) * 50 +
              DDRTCM_B.kc_size_idx_1) - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.variance_carrierphase_measured =
          DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_varia_dh[0],
                      &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                      (DDRTCM_B.dc_size_idx_1) * sizeof(real_T));
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.tmp_data_l[DDRTCM_B.b_k] = DDRTCM_DW.Buffer_u.locktime
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.i) - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.tmp_data_l[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_DW.Buffer_u.locktime[((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k]
            - 1) * 50 + DDRTCM_B.kc_size_idx_1) - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.locktime = DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_locktime[0],
                      &DDRTCM_B.tmp_data_l[0], static_cast<uint32_T>
                      (DDRTCM_B.dc_size_idx_1) * sizeof(real32_T));
        }

        DDRTCM_B.i = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.kc_size_idx_1 = DDRTCM_B.idx_u_data[0];
        DDRTCM_B.c_i = DDRTCM_B.idx_u_GPS_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k] = DDRTCM_DW.Buffer_u.CN0
            [((DDRTCM_B.idx_u_GPS_data[DDRTCM_B.b_k] - 1) * 50 + DDRTCM_B.i) - 1];
        }

        DDRTCM_B.c_i = DDRTCM_B.idx_u_GAL_size;
        for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.c_i; DDRTCM_B.b_k++) {
          DDRTCM_B.timeVec_data[DDRTCM_B.b_k + DDRTCM_B.idx_u_GPS_size] =
            DDRTCM_DW.Buffer_u.CN0[((DDRTCM_B.idx_u_GAL_data[DDRTCM_B.b_k] - 1) *
            50 + DDRTCM_B.kc_size_idx_1) - 1];
        }

        DDRTCM_DW.SFunction_DIMS2.CN0 = DDRTCM_B.dc_size_idx_1;
        if (DDRTCM_B.dc_size_idx_1 - 1 >= 0) {
          std::memcpy(&DDRTCM_B.rtb_double_differences_CN0[0],
                      &DDRTCM_B.timeVec_data[0], static_cast<uint32_T>
                      (DDRTCM_B.dc_size_idx_1) * sizeof(real_T));
        }

        // Outport: '<Root>/GNSSMeasurementBus'
        DDRTCM_Y.GNSSMeasurementBus.base_position[0] =
          DDRTCM_DW.Buffer_r.base_position[DDRTCM_B.idx_r_data[0] - 1];
        DDRTCM_Y.GNSSMeasurementBus.base_position[1] =
          DDRTCM_DW.Buffer_r.base_position[DDRTCM_B.idx_r_data[0] + 49];
        DDRTCM_Y.GNSSMeasurementBus.base_position[2] =
          DDRTCM_DW.Buffer_r.base_position[DDRTCM_B.idx_r_data[0] + 99];
      }
    }
  }

  // Outport: '<Root>/GNSSMeasurementBus' incorporates:
  //   MATLAB Function: '<S2>/ConvertGNSSMeasuremendVariableToFixed'

  std::memset(&DDRTCM_Y.GNSSMeasurementBus.satellite_position[0], 0, 120U *
              sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.satellite_velocity[0], 0, 120U *
              sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.PRN[0], 0, 40U * sizeof(uint16_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.pseudorange[0], 0, 40U * sizeof
              (real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.pseudorange_raw[0], 0, 40U * sizeof
              (real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.pseudorange_satclk_corrected[0], 0,
              40U * sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.deltarange[0], 0, 40U * sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.deltarange_raw[0], 0, 40U * sizeof
              (real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.deltarange_satclk_corrected[0], 0,
              40U * sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.variance_pseudorange[0], 0, 40U *
              sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.variance_pseudorange_measured[0], 0,
              40U * sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.variance_deltarange[0], 0, 40U *
              sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.carrierphase[0], 0, 40U * sizeof
              (real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.carrierphase_raw[0], 0, 40U * sizeof
              (real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.carrierphase_satclk_corrected[0], 0,
              40U * sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.variance_carrierphase_measured[0], 0,
              40U * sizeof(real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.locktime[0], 0, 40U * sizeof(real32_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.CN0[0], 0, 40U * sizeof(real_T));

  // MATLAB Function: '<S2>/ConvertGNSSMeasuremendVariableToFixed' incorporates:
  //   Outport: '<Root>/GNSSMeasurementBus'

  DDRTCM_B.i = DDRTCM_DW.SFunction_DIMS2.satellite_position[0];
  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  DDRTCM_B.d_i = DDRTCM_DW.SFunction_DIMS2.satellite_position[1];
  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.d_i; DDRTCM_B.b_k++) {
    for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.c_i;
         DDRTCM_B.trueCount++) {
      DDRTCM_Y.GNSSMeasurementBus.satellite_position[DDRTCM_B.trueCount + 40 *
        DDRTCM_B.b_k] = DDRTCM_B.rtb_double_differences_satellit[DDRTCM_B.i *
        DDRTCM_B.b_k + DDRTCM_B.trueCount];
    }
  }

  DDRTCM_B.i = DDRTCM_DW.SFunction_DIMS2.satellite_velocity[0];
  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  DDRTCM_B.d_i = DDRTCM_DW.SFunction_DIMS2.satellite_velocity[1];
  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_B.d_i; DDRTCM_B.b_k++) {
    for (DDRTCM_B.trueCount = 0; DDRTCM_B.trueCount <= DDRTCM_B.c_i;
         DDRTCM_B.trueCount++) {
      DDRTCM_Y.GNSSMeasurementBus.satellite_velocity[DDRTCM_B.trueCount + 40 *
        DDRTCM_B.b_k] = DDRTCM_B.rtb_double_differences_satell_g[DDRTCM_B.i *
        DDRTCM_B.b_k + DDRTCM_B.trueCount];
    }
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.PRN[0], &DDRTCM_B.SVIDCorrections[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(uint16_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.CN0[0],
                &DDRTCM_B.rtb_double_differences_CN0[0], static_cast<uint32_T>
                (DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.locktime[0],
                &DDRTCM_B.rtb_double_differences_locktime[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real32_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.pseudorange[0],
                &DDRTCM_B.rtb_double_differences_pseudora[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memset(&DDRTCM_Y.GNSSMeasurementBus.pseudorange_raw[0], 0, static_cast<
                uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memset(&DDRTCM_Y.GNSSMeasurementBus.pseudorange_satclk_corrected[0], 0,
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.deltarange[0],
                &DDRTCM_B.rtb_double_differences_deltaran[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memset(&DDRTCM_Y.GNSSMeasurementBus.deltarange_raw[0], 0,
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memset(&DDRTCM_Y.GNSSMeasurementBus.deltarange_satclk_corrected[0], 0,
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.carrierphase[0],
                &DDRTCM_B.rtb_double_differences_carrierp[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memset(&DDRTCM_Y.GNSSMeasurementBus.carrierphase_raw[0], 0,
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memset(&DDRTCM_Y.GNSSMeasurementBus.carrierphase_satclk_corrected[0], 0,
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.variance_pseudorange[0],
                &DDRTCM_B.rtb_double_differences_variance[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.variance_deltarange[0],
                &DDRTCM_B.rtb_double_differences_varian_g[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.variance_pseudorange_measured[0],
                &DDRTCM_B.rtb_double_differences_varian_d[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  if (DDRTCM_DW.SFunction_DIMS2.PRN < 1) {
    DDRTCM_B.c_i = -1;
  } else {
    DDRTCM_B.c_i = DDRTCM_DW.SFunction_DIMS2.PRN - 1;
  }

  if (DDRTCM_B.c_i >= 0) {
    std::memcpy(&DDRTCM_Y.GNSSMeasurementBus.variance_carrierphase_measured[0],
                &DDRTCM_B.rtb_double_differences_varia_dh[0],
                static_cast<uint32_T>(DDRTCM_B.c_i + 1) * sizeof(real_T));
  }

  // Outport: '<Root>/GNSSMeasurementBus' incorporates:
  //   MATLAB Function: '<S2>/ConvertGNSSMeasuremendVariableToFixed'

  std::memset(&DDRTCM_Y.GNSSMeasurementBus.elevation_angle[0], 0, 40U * sizeof
              (real_T));
  std::memset(&DDRTCM_Y.GNSSMeasurementBus.azimuth_angle[0], 0, 40U * sizeof
              (real_T));

  // Outport: '<Root>/GnssMeasurementSize' incorporates:
  //   MATLAB Function: '<S2>/ConvertGNSSMeasuremendVariableToFixed'

  DDRTCM_Y.GnssMeasurementSize = DDRTCM_DW.SFunction_DIMS2.PRN;

  // Outport: '<Root>/idxSyncR' incorporates:
  //   MATLAB Function: '<S2>/calculate double diff'

  DDRTCM_Y.idxSyncR = DDRTCM_B.k;

  // Outport: '<Root>/idxSyncU' incorporates:
  //   MATLAB Function: '<S2>/calculate double diff'

  DDRTCM_Y.idxSyncU = DDRTCM_B.c;

  // MATLAB Function: '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles2' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  ConvertGNSSMeasuremendVariableT
    (&DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a,
     &DDRTCM_DW.sf_switchGNSSMeasurements_g.SFunction_DIMS2,
     DDRTCM_U.usePosLLHArray, &DDRTCM_B.GNSSMeasurementFixed_c,
     &DDRTCM_B.state_o, &DDRTCM_B.sf_ConvertGNSSMeasuremendVari_h);

  // MATLAB Function: '<S145>/CalcDOP' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_CalcDOP(DDRTCM_U.usePosLLHArray,
                 &DDRTCM_B.sf_switchGNSSMeasurements_g.GNSS_Measurement_a,
                 &DDRTCM_DW.sf_switchGNSSMeasurements_g.SFunction_DIMS2,
                 &DDRTCM_B.state_o, &DDRTCM_B.TOW, &DDRTCM_B.sf_CalcDOP_j,
                 &DDRTCM_DW.sf_CalcDOP_j);

  // MATLAB Function: '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles2' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  ConvertGNSSMeasuremendVariableT
    (&DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a,
     &DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2,
     DDRTCM_U.usePosLLHArray, &DDRTCM_B.GNSSMeasurementFixed_e,
     &DDRTCM_B.state_o, &DDRTCM_B.sf_ConvertGNSSMeasuremendVari_c);

  // MATLAB Function: '<S18>/CalcDOP' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  DDRTCM_CalcDOP(DDRTCM_U.usePosLLHArray,
                 &DDRTCM_B.sf_switchGNSSMeasurements.GNSS_Measurement_a,
                 &DDRTCM_DW.sf_switchGNSSMeasurements.SFunction_DIMS2,
                 &DDRTCM_B.state_o, &DDRTCM_B.TOW, &DDRTCM_B.sf_CalcDOP,
                 &DDRTCM_DW.sf_CalcDOP);

  // BusCreator generated from: '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles1' incorporates:
  //   BusSelector: '<S144>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Conve.satellite_position[0] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Conve.satellite_position[1] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Conve.satellite_velocity[0] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Conve.satellite_velocity[1] =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Conve.PRN =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.pseudorange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.pseudorange_raw =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.pseudorange_satclk_corrected =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.deltarange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.deltarange_raw =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.deltarange_satclk_corrected =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.variance_pseudorange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.variance_pseudorange_measured =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.variance_deltarange =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.carrierphase =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.carrierphase_raw =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.carrierphase_satclk_corrected =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.variance_carrierphase_measured =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.locktime =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Conve.CN0 =
    DDRTCM_DW.Galileo_k.BusSelector_DIMS19;
  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_B.Galileo_k.time_receive;
  if (DDRTCM_B.s_i - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_position[0],
                &DDRTCM_B.Galileo_k.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.s_i) * sizeof(real_T));
  }

  if (DDRTCM_B.loop_ub_tmp - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0],
                &DDRTCM_B.Galileo_k.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo_k.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo_k.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.GnssMeasurementBase.base_position[0] =
    DDRTCM_B.Galileo_k.base_position[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] =
    DDRTCM_B.Galileo_k.base_position[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] =
    DDRTCM_B.Galileo_k.base_position[2];

  // MATLAB Function: '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles1' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  ConvertGNSSMeasuremendVariableT(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.BusConversion_InsertedFor_Conve, DDRTCM_U.usePosLLHArray,
    &DDRTCM_B.GNSSMeasurementFixed_m, &DDRTCM_B.state_o,
    &DDRTCM_B.sf_ConvertGNSSMeasuremendVari_g);

  // BusCreator generated from: '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles' incorporates:
  //   BusSelector: '<S143>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Con_m.satellite_position[0] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.satellite_position[1] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.satellite_velocity[0] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.satellite_velocity[1] =
    DDRTCM_DW.GPS_d.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.PRN =
    DDRTCM_DW.GPS_d.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.pseudorange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.pseudorange_raw =
    DDRTCM_DW.GPS_d.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.pseudorange_satclk_corrected =
    DDRTCM_DW.GPS_d.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.deltarange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.deltarange_raw =
    DDRTCM_DW.GPS_d.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.deltarange_satclk_corrected =
    DDRTCM_DW.GPS_d.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.variance_pseudorange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.variance_pseudorange_measured =
    DDRTCM_DW.GPS_d.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.variance_deltarange =
    DDRTCM_DW.GPS_d.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.carrierphase =
    DDRTCM_DW.GPS_d.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.carrierphase_raw =
    DDRTCM_DW.GPS_d.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.carrierphase_satclk_corrected =
    DDRTCM_DW.GPS_d.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.variance_carrierphase_measured =
    DDRTCM_DW.GPS_d.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.locktime =
    DDRTCM_DW.GPS_d.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Con_m.CN0 =
    DDRTCM_DW.GPS_d.BusSelector_DIMS19;
  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_B.GPS_d.time_receive;
  if (DDRTCM_B.testGradient_tmp - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_position[0],
                &DDRTCM_B.GPS_d.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.testGradient_tmp) * sizeof(real_T));
  }

  if (DDRTCM_B.f_size_idx_0 - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0],
                &DDRTCM_B.GPS_d.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.f_size_idx_0) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS_d.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.GPS_d.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.GnssMeasurementBase.base_position[0] = DDRTCM_B.GPS_d.base_position[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] = DDRTCM_B.GPS_d.base_position[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] = DDRTCM_B.GPS_d.base_position[2];

  // MATLAB Function: '<S5>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  ConvertGNSSMeasuremendVariableT(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.BusConversion_InsertedFor_Con_m, DDRTCM_U.usePosLLHArray,
    &DDRTCM_B.GNSSMeasurementFixed_c_k, &DDRTCM_B.state_o,
    &DDRTCM_B.sf_ConvertGNSSMeasuremendVar_c1);

  // BusCreator generated from: '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles1' incorporates:
  //   BusSelector: '<S17>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Con_d.satellite_position[0] =
    DDRTCM_DW.Galileo.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.satellite_position[1] =
    DDRTCM_DW.Galileo.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.satellite_velocity[0] =
    DDRTCM_DW.Galileo.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.satellite_velocity[1] =
    DDRTCM_DW.Galileo.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.PRN =
    DDRTCM_DW.Galileo.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.pseudorange =
    DDRTCM_DW.Galileo.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.pseudorange_raw =
    DDRTCM_DW.Galileo.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.pseudorange_satclk_corrected =
    DDRTCM_DW.Galileo.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.deltarange =
    DDRTCM_DW.Galileo.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.deltarange_raw =
    DDRTCM_DW.Galileo.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.deltarange_satclk_corrected =
    DDRTCM_DW.Galileo.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.variance_pseudorange =
    DDRTCM_DW.Galileo.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.variance_pseudorange_measured =
    DDRTCM_DW.Galileo.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.variance_deltarange =
    DDRTCM_DW.Galileo.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.carrierphase =
    DDRTCM_DW.Galileo.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.carrierphase_raw =
    DDRTCM_DW.Galileo.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.carrierphase_satclk_corrected =
    DDRTCM_DW.Galileo.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.variance_carrierphase_measured =
    DDRTCM_DW.Galileo.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.locktime =
    DDRTCM_DW.Galileo.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Con_d.CN0 =
    DDRTCM_DW.Galileo.BusSelector_DIMS19;
  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_B.Galileo.time_receive;
  if (DDRTCM_B.loop_ub_tmp_b - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_position[0],
                &DDRTCM_B.Galileo.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp_b) * sizeof(real_T));
  }

  if (DDRTCM_B.loop_ub_tmp_j - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0],
                &DDRTCM_B.Galileo.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp_j) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.Galileo.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.Galileo.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.GnssMeasurementBase.base_position[0] =
    DDRTCM_B.Galileo.base_position[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] =
    DDRTCM_B.Galileo.base_position[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] =
    DDRTCM_B.Galileo.base_position[2];

  // MATLAB Function: '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles1' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  ConvertGNSSMeasuremendVariableT(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.BusConversion_InsertedFor_Con_d, DDRTCM_U.usePosLLHArray,
    &DDRTCM_B.GNSSMeasurementFixed_j, &DDRTCM_B.state_o,
    &DDRTCM_B.sf_ConvertGNSSMeasuremendVari_j);

  // BusCreator generated from: '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles' incorporates:
  //   BusSelector: '<S16>/Bus Selector'

  DDRTCM_DW.BusConversion_InsertedFor_Con_n.satellite_position[0] =
    DDRTCM_DW.GPS.BusSelector_DIMS2[0];
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.satellite_position[1] =
    DDRTCM_DW.GPS.BusSelector_DIMS2[1];
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.satellite_velocity[0] =
    DDRTCM_DW.GPS.BusSelector_DIMS3[0];
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.satellite_velocity[1] =
    DDRTCM_DW.GPS.BusSelector_DIMS3[1];
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.PRN =
    DDRTCM_DW.GPS.BusSelector_DIMS4;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.pseudorange =
    DDRTCM_DW.GPS.BusSelector_DIMS5;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.pseudorange_raw =
    DDRTCM_DW.GPS.BusSelector_DIMS6;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.pseudorange_satclk_corrected =
    DDRTCM_DW.GPS.BusSelector_DIMS7;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.deltarange =
    DDRTCM_DW.GPS.BusSelector_DIMS8;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.deltarange_raw =
    DDRTCM_DW.GPS.BusSelector_DIMS9;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.deltarange_satclk_corrected =
    DDRTCM_DW.GPS.BusSelector_DIMS10;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.variance_pseudorange =
    DDRTCM_DW.GPS.BusSelector_DIMS11;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.variance_pseudorange_measured =
    DDRTCM_DW.GPS.BusSelector_DIMS12;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.variance_deltarange =
    DDRTCM_DW.GPS.BusSelector_DIMS13;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.carrierphase =
    DDRTCM_DW.GPS.BusSelector_DIMS14;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.carrierphase_raw =
    DDRTCM_DW.GPS.BusSelector_DIMS15;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.carrierphase_satclk_corrected =
    DDRTCM_DW.GPS.BusSelector_DIMS16;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.variance_carrierphase_measured =
    DDRTCM_DW.GPS.BusSelector_DIMS17;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.locktime =
    DDRTCM_DW.GPS.BusSelector_DIMS18;
  DDRTCM_DW.BusConversion_InsertedFor_Con_n.CN0 =
    DDRTCM_DW.GPS.BusSelector_DIMS19;
  DDRTCM_B.GnssMeasurementBase.time_receive = DDRTCM_B.GPS.time_receive;
  if (DDRTCM_B.nz - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_position[0],
                &DDRTCM_B.GPS.satellite_position[0], static_cast<uint32_T>
                (DDRTCM_B.nz) * sizeof(real_T));
  }

  if (DDRTCM_B.loop_ub_tmp_f - 1 >= 0) {
    std::memcpy(&DDRTCM_B.GnssMeasurementBase.satellite_velocity[0],
                &DDRTCM_B.GPS.satellite_velocity[0], static_cast<uint32_T>
                (DDRTCM_B.loop_ub_tmp_f) * sizeof(real_T));
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS4;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.PRN[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.PRN[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS5;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS6;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.pseudorange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS7;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.pseudorange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.pseudorange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS8;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS9;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.deltarange_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS10;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.deltarange_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.deltarange_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS11;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_pseudorange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS12;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_pseudorange_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_pseudorange_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS13;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_deltarange[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_deltarange[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS14;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.carrierphase[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS15;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_raw[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.carrierphase_raw[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS16;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.carrierphase_satclk_corrected[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.carrierphase_satclk_corrected[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS17;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.variance_carrierphase_measured[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.variance_carrierphase_measured[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS18;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.locktime[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.locktime[DDRTCM_B.b_k];
  }

  for (DDRTCM_B.b_k = 0; DDRTCM_B.b_k < DDRTCM_DW.GPS.BusSelector_DIMS19;
       DDRTCM_B.b_k++) {
    DDRTCM_B.GnssMeasurementBase.CN0[DDRTCM_B.b_k] =
      DDRTCM_B.GPS.CN0[DDRTCM_B.b_k];
  }

  DDRTCM_B.GnssMeasurementBase.base_position[0] = DDRTCM_B.GPS.base_position[0];
  DDRTCM_B.GnssMeasurementBase.base_position[1] = DDRTCM_B.GPS.base_position[1];
  DDRTCM_B.GnssMeasurementBase.base_position[2] = DDRTCM_B.GPS.base_position[2];

  // MATLAB Function: '<S4>/ConvertGNSSMeasuremendVariableToFixed_CalcAngles' incorporates:
  //   Inport: '<Root>/usePosLLHArray'

  ConvertGNSSMeasuremendVariableT(&DDRTCM_B.GnssMeasurementBase,
    &DDRTCM_DW.BusConversion_InsertedFor_Con_n, DDRTCM_U.usePosLLHArray,
    &DDRTCM_B.GNSSMeasurementFixed_a, &DDRTCM_B.state_o,
    &DDRTCM_B.sf_ConvertGNSSMeasuremendVari_n);

  // Update absolute time for base rate
  // The "clockTick0" counts the number of times the code of this task has
  //  been executed. The resolution of this integer timer is 0.1, which is the step size
  //  of the task. Size of "clockTick0" ensures timer will not overflow during the
  //  application lifespan selected.

  (&DDRTCM_M)->Timing.clockTick0++;
}

// Model initialize function
void DDRTCM::initialize()
{
  // Registration code

  // initialize non-finites
  rt_InitInfAndNaN(sizeof(real_T));

  {
    real_T rtb_HPL_i;
    real_T rtb_test_statistic_e;
    real_T state_o;

    // SystemInitialize for Atomic SubSystem: '<S4>/Mode Switch'
    // InitializeConditions for UnitDelay: '<S133>/Delay Input1'
    //
    //  Block description for '<S133>/Delay Input1':
    //
    //   Store in Global RAM

    DDRTCM_DW.DelayInput1_DSTATE_i = DDRTCM_P.DetectChange_vinit;

    // InitializeConditions for DiscreteIntegrator: '<S129>/Discrete-Time Integrator' incorporates:
    //   Constant: '<S129>/Constant1'

    DDRTCM_DW.DiscreteTimeIntegrator_DSTATE_l = DDRTCM_P.Constant1_Value;
    DDRTCM_DW.DiscreteTimeIntegrator_PrevRe_n = 2;

    // InitializeConditions for Chart: '<S130>/choose correction mode' incorporates:
    //   Memory: '<S134>/Memory'

    DDRTCM_DW.Memory_PreviousInput_h = DDRTCM_P.SRFlipFlop_initial_condition;

    // SystemInitialize for Chart: '<S130>/choose correction mode'
    DDRTC_choosecorrectionmode_Init(&state_o, &DDRTCM_B.parameters_gnss_i);

    // End of SystemInitialize for SubSystem: '<S4>/Mode Switch'

    // SystemInitialize for Enabled SubSystem: '<S4>/GPS'
    DDRTCM_GPS_Init(&DDRTCM_B.GPS, &DDRTCM_DW.GPS, &DDRTCM_P.GPS);

    // End of SystemInitialize for SubSystem: '<S4>/GPS'

    // SystemInitialize for Enabled SubSystem: '<S4>/Galileo'
    DDRTCM_Galileo_Init(&DDRTCM_B.Galileo, &DDRTCM_DW.Galileo, &DDRTCM_P.Galileo);

    // End of SystemInitialize for SubSystem: '<S4>/Galileo'

    // SystemInitialize for Atomic SubSystem: '<S5>/Mode Switch'
    // InitializeConditions for UnitDelay: '<S260>/Delay Input1'
    //
    //  Block description for '<S260>/Delay Input1':
    //
    //   Store in Global RAM

    DDRTCM_DW.DelayInput1_DSTATE = DDRTCM_P.DetectChange_vinit_o;

    // InitializeConditions for DiscreteIntegrator: '<S256>/Discrete-Time Integrator' incorporates:
    //   Constant: '<S256>/Constant1'

    DDRTCM_DW.DiscreteTimeIntegrator_DSTATE = DDRTCM_P.Constant1_Value_b;
    DDRTCM_DW.DiscreteTimeIntegrator_PrevRese = 2;

    // InitializeConditions for Chart: '<S257>/choose correction mode' incorporates:
    //   Memory: '<S261>/Memory'

    DDRTCM_DW.Memory_PreviousInput = DDRTCM_P.SRFlipFlop_initial_condition_c;

    // SystemInitialize for Chart: '<S257>/choose correction mode'
    DDRTC_choosecorrectionmode_Init(&state_o, &DDRTCM_B.parameters_gnss);

    // End of SystemInitialize for SubSystem: '<S5>/Mode Switch'

    // SystemInitialize for Enabled SubSystem: '<S5>/GPS'
    DDRTCM_GPS_Init(&DDRTCM_B.GPS_d, &DDRTCM_DW.GPS_d, &DDRTCM_P.GPS_d);

    // End of SystemInitialize for SubSystem: '<S5>/GPS'

    // SystemInitialize for Enabled SubSystem: '<S5>/Galileo'
    DDRTCM_Galileo_Init(&DDRTCM_B.Galileo_k, &DDRTCM_DW.Galileo_k,
                        &DDRTCM_P.Galileo_k);

    // End of SystemInitialize for SubSystem: '<S5>/Galileo'

    // SystemInitialize for MATLAB Function: '<S4>/Merge GNSS Measurement'
    DDRTC_MergeGNSSMeasurement_Init(&DDRTCM_DW.sf_MergeGNSSMeasurement);

    // SystemInitialize for MATLAB Function: '<S122>/MATLAB Function'
    DDRTCM_MATLABFunction_Init(&state_o, &rtb_HPL_i, &rtb_test_statistic_e,
      DDRTCM_B.faulty_PRNs_g, DDRTCM_B.PRNs_to_exclude_j,
      DDRTCM_B.PRNs_excluded_f, &DDRTCM_B.sf_MATLABFunction,
      &DDRTCM_DW.sf_MATLABFunction, &DDRTCM_P.sf_MATLABFunction);

    // SystemInitialize for MATLAB Function: '<S2>/Multipath-Detector'
    for (int32_T i{0}; i < 4400; i++) {
      DDRTCM_DW.testmeasure_Buffer[i] = (rtNaN);
    }

    for (int32_T i{0}; i < 110; i++) {
      DDRTCM_DW.CS_PRN[i] = 100.0;
    }

    // End of SystemInitialize for MATLAB Function: '<S2>/Multipath-Detector'

    // SystemInitialize for MATLAB Function: '<S5>/Merge GNSS Measurement'
    DDRTC_MergeGNSSMeasurement_Init(&DDRTCM_DW.sf_MergeGNSSMeasurement_l);

    // SystemInitialize for MATLAB Function: '<S249>/MATLAB Function'
    DDRTCM_MATLABFunction_Init(&state_o, &rtb_HPL_i, &rtb_test_statistic_e,
      DDRTCM_B.faulty_PRNs, DDRTCM_B.PRNs_to_exclude, DDRTCM_B.PRNs_excluded,
      &DDRTCM_B.sf_MATLABFunction_p, &DDRTCM_DW.sf_MATLABFunction_p,
      &DDRTCM_P.sf_MATLABFunction_p);
  }
}

// Model terminate function
void DDRTCM::terminate()
{
  // (no terminate code required)
}

// Constructor
DDRTCM::DDRTCM() :
  DDRTCM_U(),
  DDRTCM_Y(),
  DDRTCM_B(),
  DDRTCM_DW(),
  DDRTCM_M()
{
  // Currently there is no constructor body generated.
}

// Destructor
DDRTCM::~DDRTCM()
{
  // Currently there is no destructor body generated.
}

// Real-Time Model get method
DDRTCM::RT_MODEL_DDRTCM_T * DDRTCM::getRTM()
{
  return (&DDRTCM_M);
}

//
// File trailer for generated code.
//
// [EOF]
//
